
Š€€€
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64StringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]string)
		if v, changed := fastpathTV.DecMapFloat64StringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64StringV(rv2i(rv).(map[float64]string), false, d)
}
func (f fastpathT) DecMapFloat64StringX(vp *map[float64]string, d *Decoder) {
	if v, changed := f.DecMapFloat64StringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64StringV(v map[float64]string, canChange bool,
	d *Decoder) (_ map[float64]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[float64]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float64
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64UintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]uint)
		if v, changed := fastpathTV.DecMapFloat64UintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64UintV(rv2i(rv).(map[float64]uint), false, d)
}
func (f fastpathT) DecMapFloat64UintX(vp *map[float64]uint, d *Decoder) {
	if v, changed := f.DecMapFloat64UintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64UintV(v map[float64]uint, canChange bool,
	d *Decoder) (_ map[float64]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[float64]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float64
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64Uint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]uint8)
		if v, changed := fastpathTV.DecMapFloat64Uint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64Uint8V(rv2i(rv).(map[float64]uint8), false, d)
}
func (f fastpathT) DecMapFloat64Uint8X(vp *map[float64]uint8, d *Decoder) {
	if v, changed := f.DecMapFloat64Uint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64Uint8V(v map[float64]uint8, canChange bool,
	d *Decoder) (_ map[float64]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[float64]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float64
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64Uint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]uint16)
		if v, changed := fastpathTV.DecMapFloat64Uint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64Uint16V(rv2i(rv).(map[float64]uint16), false, d)
}
func (f fastpathT) DecMapFloat64Uint16X(vp *map[float64]uint16, d *Decoder) {
	if v, changed := f.DecMapFloat64Uint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64Uint16V(v map[float64]uint16, canChange bool,
	d *Decoder) (_ map[float64]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[float64]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float64
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64Uint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]uint32)
		if v, changed := fastpathTV.DecMapFloat64Uint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64Uint32V(rv2i(rv).(map[float64]uint32), false, d)
}
func (f fastpathT) DecMapFloat64Uint32X(vp *map[float64]uint32, d *Decoder) {
	if v, changed := f.DecMapFloat64Uint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64Uint32V(v map[float64]uint32, canChange bool,
	d *Decoder) (_ map[float64]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[float64]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float64
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64Uint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]uint64)
		if v, changed := fastpathTV.DecMapFloat64Uint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64Uint64V(rv2i(rv).(map[float64]uint64), false, d)
}
func (f fastpathT) DecMapFloat64Uint64X(vp *map[float64]uint64, d *Decoder) {
	if v, changed := f.DecMapFloat64Uint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64Uint64V(v map[float64]uint64, canChange bool,
	d *Decoder) (_ map[float64]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[float64]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float64
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64UintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]uintptr)
		if v, changed := fastpathTV.DecMapFloat64UintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64UintptrV(rv2i(rv).(map[float64]uintptr), false, d)
}
func (f fastpathT) DecMapFloat64UintptrX(vp *map[float64]uintptr, d *Decoder) {
	if v, changed := f.DecMapFloat64UintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64UintptrV(v map[float64]uintptr, canChange bool,
	d *Decoder) (_ map[float64]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[float64]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float64
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64IntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]int)
		if v, changed := fastpathTV.DecMapFloat64IntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64IntV(rv2i(rv).(map[float64]int), false, d)
}
func (f fastpathT) DecMapFloat64IntX(vp *map[float64]int, d *Decoder) {
	if v, changed := f.DecMapFloat64IntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64IntV(v map[float64]int, canChange bool,
	d *Decoder) (_ map[float64]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[float64]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float64
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64Int8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]int8)
		if v, changed := fastpathTV.DecMapFloat64Int8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64Int8V(rv2i(rv).(map[float64]int8), false, d)
}
func (f fastpathT) DecMapFloat64Int8X(vp *map[float64]int8, d *Decoder) {
	if v, changed := f.DecMapFloat64Int8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64Int8V(v map[float64]int8, canChange bool,
	d *Decoder) (_ map[float64]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[float64]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float64
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64Int16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]int16)
		if v, changed := fastpathTV.DecMapFloat64Int16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64Int16V(rv2i(rv).(map[float64]int16), false, d)
}
func (f fastpathT) DecMapFloat64Int16X(vp *map[float64]int16, d *Decoder) {
	if v, changed := f.DecMapFloat64Int16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64Int16V(v map[float64]int16, canChange bool,
	d *Decoder) (_ map[float64]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[float64]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float64
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64Int32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]int32)
		if v, changed := fastpathTV.DecMapFloat64Int32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64Int32V(rv2i(rv).(map[float64]int32), false, d)
}
func (f fastpathT) DecMapFloat64Int32X(vp *map[float64]int32, d *Decoder) {
	if v, changed := f.DecMapFloat64Int32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64Int32V(v map[float64]int32, canChange bool,
	d *Decoder) (_ map[float64]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[float64]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float64
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64Int64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]int64)
		if v, changed := fastpathTV.DecMapFloat64Int64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64Int64V(rv2i(rv).(map[float64]int64), false, d)
}
func (f fastpathT) DecMapFloat64Int64X(vp *map[float64]int64, d *Decoder) {
	if v, changed := f.DecMapFloat64Int64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64Int64V(v map[float64]int64, canChange bool,
	d *Decoder) (_ map[float64]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[float64]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float64
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64Float32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]float32)
		if v, changed := fastpathTV.DecMapFloat64Float32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64Float32V(rv2i(rv).(map[float64]float32), false, d)
}
func (f fastpathT) DecMapFloat64Float32X(vp *map[float64]float32, d *Decoder) {
	if v, changed := f.DecMapFloat64Float32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64Float32V(v map[float64]float32, canChange bool,
	d *Decoder) (_ map[float64]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[float64]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float64
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64Float64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]float64)
		if v, changed := fastpathTV.DecMapFloat64Float64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64Float64V(rv2i(rv).(map[float64]float64), false, d)
}
func (f fastpathT) DecMapFloat64Float64X(vp *map[float64]float64, d *Decoder) {
	if v, changed := f.DecMapFloat64Float64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64Float64V(v map[float64]float64, canChange bool,
	d *Decoder) (_ map[float64]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[float64]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float64
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64BoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]bool)
		if v, changed := fastpathTV.DecMapFloat64BoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64BoolV(rv2i(rv).(map[float64]bool), false, d)
}
func (f fastpathT) DecMapFloat64BoolX(vp *map[float64]bool, d *Decoder) {
	if v, changed := f.DecMapFloat64BoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64BoolV(v map[float64]bool, canChange bool,
	d *Decoder) (_ map[float64]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[float64]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float64
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintIntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]interface{})
		if v, changed := fastpathTV.DecMapUintIntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintIntfV(rv2i(rv).(map[uint]interface{}), false, d)
}
func (f fastpathT) DecMapUintIntfX(vp *map[uint]interface{}, d *Decoder) {
	if v, changed := f.DecMapUintIntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintIntfV(v map[uint]interface{}, canChange bool,
	d *Decoder) (_ map[uint]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[uint]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk uint
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintStringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]string)
		if v, changed := fastpathTV.DecMapUintStringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintStringV(rv2i(rv).(map[uint]string), false, d)
}
func (f fastpathT) DecMapUintStringX(vp *map[uint]string, d *Decoder) {
	if v, changed := f.DecMapUintStringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintStringV(v map[uint]string, canChange bool,
	d *Decoder) (_ map[uint]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[uint]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintUintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]uint)
		if v, changed := fastpathTV.DecMapUintUintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintUintV(rv2i(rv).(map[uint]uint), false, d)
}
func (f fastpathT) DecMapUintUintX(vp *map[uint]uint, d *Decoder) {
	if v, changed := f.DecMapUintUintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintUintV(v map[uint]uint, canChange bool,
	d *Decoder) (_ map[uint]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uint]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintUint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]uint8)
		if v, changed := fastpathTV.DecMapUintUint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintUint8V(rv2i(rv).(map[uint]uint8), false, d)
}
func (f fastpathT) DecMapUintUint8X(vp *map[uint]uint8, d *Decoder) {
	if v, changed := f.DecMapUintUint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintUint8V(v map[uint]uint8, canChange bool,
	d *Decoder) (_ map[uint]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[uint]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintUint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]uint16)
		if v, changed := fastpathTV.DecMapUintUint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintUint16V(rv2i(rv).(map[uint]uint16), false, d)
}
func (f fastpathT) DecMapUintUint16X(vp *map[uint]uint16, d *Decoder) {
	if v, changed := f.DecMapUintUint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintUint16V(v map[uint]uint16, canChange bool,
	d *Decoder) (_ map[uint]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[uint]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintUint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]uint32)
		if v, changed := fastpathTV.DecMapUintUint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintUint32V(rv2i(rv).(map[uint]uint32), false, d)
}
func (f fastpathT) DecMapUintUint32X(vp *map[uint]uint32, d *Decoder) {
	if v, changed := f.DecMapUintUint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintUint32V(v map[uint]uint32, canChange bool,
	d *Decoder) (_ map[uint]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[uint]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintUint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]uint64)
		if v, changed := fastpathTV.DecMapUintUint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintUint64V(rv2i(rv).(map[uint]uint64), false, d)
}
func (f fastpathT) DecMapUintUint64X(vp *map[uint]uint64, d *Decoder) {
	if v, changed := f.DecMapUintUint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintUint64V(v map[uint]uint64, canChange bool,
	d *Decoder) (_ map[uint]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uint]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintUintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]uintptr)
		if v, changed := fastpathTV.DecMapUintUintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintUintptrV(rv2i(rv).(map[uint]uintptr), false, d)
}
func (f fastpathT) DecMapUintUintptrX(vp *map[uint]uintptr, d *Decoder) {
	if v, changed := f.DecMapUintUintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintUintptrV(v map[uint]uintptr, canChange bool,
	d *Decoder) (_ map[uint]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uint]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintIntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]int)
		if v, changed := fastpathTV.DecMapUintIntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintIntV(rv2i(rv).(map[uint]int), false, d)
}
func (f fastpathT) DecMapUintIntX(vp *map[uint]int, d *Decoder) {
	if v, changed := f.DecMapUintIntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintIntV(v map[uint]int, canChange bool,
	d *Decoder) (_ map[uint]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uint]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintInt8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]int8)
		if v, changed := fastpathTV.DecMapUintInt8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintInt8V(rv2i(rv).(map[uint]int8), false, d)
}
func (f fastpathT) DecMapUintInt8X(vp *map[uint]int8, d *Decoder) {
	if v, changed := f.DecMapUintInt8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintInt8V(v map[uint]int8, canChange bool,
	d *Decoder) (_ map[uint]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[uint]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintInt16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]int16)
		if v, changed := fastpathTV.DecMapUintInt16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintInt16V(rv2i(rv).(map[uint]int16), false, d)
}
func (f fastpathT) DecMapUintInt16X(vp *map[uint]int16, d *Decoder) {
	if v, changed := f.DecMapUintInt16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintInt16V(v map[uint]int16, canChange bool,
	d *Decoder) (_ map[uint]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[uint]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintInt32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]int32)
		if v, changed := fastpathTV.DecMapUintInt32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintInt32V(rv2i(rv).(map[uint]int32), false, d)
}
func (f fastpathT) DecMapUintInt32X(vp *map[uint]int32, d *Decoder) {
	if v, changed := f.DecMapUintInt32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintInt32V(v map[uint]int32, canChange bool,
	d *Decoder) (_ map[uint]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[uint]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintInt64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]int64)
		if v, changed := fastpathTV.DecMapUintInt64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintInt64V(rv2i(rv).(map[uint]int64), false, d)
}
func (f fastpathT) DecMapUintInt64X(vp *map[uint]int64, d *Decoder) {
	if v, changed := f.DecMapUintInt64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintInt64V(v map[uint]int64, canChange bool,
	d *Decoder) (_ map[uint]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uint]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintFloat32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]float32)
		if v, changed := fastpathTV.DecMapUintFloat32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintFloat32V(rv2i(rv).(map[uint]float32), false, d)
}
func (f fastpathT) DecMapUintFloat32X(vp *map[uint]float32, d *Decoder) {
	if v, changed := f.DecMapUintFloat32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintFloat32V(v map[uint]float32, canChange bool,
	d *Decoder) (_ map[uint]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[uint]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintFloat64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]float64)
		if v, changed := fastpathTV.DecMapUintFloat64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintFloat64V(rv2i(rv).(map[uint]float64), false, d)
}
func (f fastpathT) DecMapUintFloat64X(vp *map[uint]float64, d *Decoder) {
	if v, changed := f.DecMapUintFloat64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintFloat64V(v map[uint]float64, canChange bool,
	d *Decoder) (_ map[uint]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uint]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintBoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint]bool)
		if v, changed := fastpathTV.DecMapUintBoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintBoolV(rv2i(rv).(map[uint]bool), false, d)
}
func (f fastpathT) DecMapUintBoolX(vp *map[uint]bool, d *Decoder) {
	if v, changed := f.DecMapUintBoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintBoolV(v map[uint]bool, canChange bool,
	d *Decoder) (_ map[uint]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[uint]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8IntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]interface{})
		if v, changed := fastpathTV.DecMapUint8IntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8IntfV(rv2i(rv).(map[uint8]interface{}), false, d)
}
func (f fastpathT) DecMapUint8IntfX(vp *map[uint8]interface{}, d *Decoder) {
	if v, changed := f.DecMapUint8IntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8IntfV(v map[uint8]interface{}, canChange bool,
	d *Decoder) (_ map[uint8]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 17)
		v = make(map[uint8]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk uint8
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8StringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]string)
		if v, changed := fastpathTV.DecMapUint8StringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8StringV(rv2i(rv).(map[uint8]string), false, d)
}
func (f fastpathT) DecMapUint8StringX(vp *map[uint8]string, d *Decoder) {
	if v, changed := f.DecMapUint8StringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8StringV(v map[uint8]string, canChange bool,
	d *Decoder) (_ map[uint8]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 17)
		v = make(map[uint8]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint8
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8UintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]uint)
		if v, changed := fastpathTV.DecMapUint8UintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8UintV(rv2i(rv).(map[uint8]uint), false, d)
}
func (f fastpathT) DecMapUint8UintX(vp *map[uint8]uint, d *Decoder) {
	if v, changed := f.DecMapUint8UintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8UintV(v map[uint8]uint, canChange bool,
	d *Decoder) (_ map[uint8]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[uint8]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint8
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8Uint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]uint8)
		if v, changed := fastpathTV.DecMapUint8Uint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8Uint8V(rv2i(rv).(map[uint8]uint8), false, d)
}
func (f fastpathT) DecMapUint8Uint8X(vp *map[uint8]uint8, d *Decoder) {
	if v, changed := f.DecMapUint8Uint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8Uint8V(v map[uint8]uint8, canChange bool,
	d *Decoder) (_ map[uint8]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 2)
		v = make(map[uint8]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint8
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8Uint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]uint16)
		if v, changed := fastpathTV.DecMapUint8Uint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8Uint16V(rv2i(rv).(map[uint8]uint16), false, d)
}
func (f fastpathT) DecMapUint8Uint16X(vp *map[uint8]uint16, d *Decoder) {
	if v, changed := f.DecMapUint8Uint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8Uint16V(v map[uint8]uint16, canChange bool,
	d *Decoder) (_ map[uint8]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 3)
		v = make(map[uint8]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint8
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8Uint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]uint32)
		if v, changed := fastpathTV.DecMapUint8Uint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8Uint32V(rv2i(rv).(map[uint8]uint32), false, d)
}
func (f fastpathT) DecMapUint8Uint32X(vp *map[uint8]uint32, d *Decoder) {
	if v, changed := f.DecMapUint8Uint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8Uint32V(v map[uint8]uint32, canChange bool,
	d *Decoder) (_ map[uint8]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[uint8]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint8
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8Uint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]uint64)
		if v, changed := fastpathTV.DecMapUint8Uint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8Uint64V(rv2i(rv).(map[uint8]uint64), false, d)
}
func (f fastpathT) DecMapUint8Uint64X(vp *map[uint8]uint64, d *Decoder) {
	if v, changed := f.DecMapUint8Uint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8Uint64V(v map[uint8]uint64, canChange bool,
	d *Decoder) (_ map[uint8]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[uint8]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint8
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8UintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]uintptr)
		if v, changed := fastpathTV.DecMapUint8UintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8UintptrV(rv2i(rv).(map[uint8]uintptr), false, d)
}
func (f fastpathT) DecMapUint8UintptrX(vp *map[uint8]uintptr, d *Decoder) {
	if v, changed := f.DecMapUint8UintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8UintptrV(v map[uint8]uintptr, canChange bool,
	d *Decoder) (_ map[uint8]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[uint8]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint8
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8IntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]int)
		if v, changed := fastpathTV.DecMapUint8IntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8IntV(rv2i(rv).(map[uint8]int), false, d)
}
func (f fastpathT) DecMapUint8IntX(vp *map[uint8]int, d *Decoder) {
	if v, changed := f.DecMapUint8IntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8IntV(v map[uint8]int, canChange bool,
	d *Decoder) (_ map[uint8]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[uint8]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint8
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8Int8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]int8)
		if v, changed := fastpathTV.DecMapUint8Int8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8Int8V(rv2i(rv).(map[uint8]int8), false, d)
}
func (f fastpathT) DecMapUint8Int8X(vp *map[uint8]int8, d *Decoder) {
	if v, changed := f.DecMapUint8Int8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8Int8V(v map[uint8]int8, canChange bool,
	d *Decoder) (_ map[uint8]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 2)
		v = make(map[uint8]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint8
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8Int16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]int16)
		if v, changed := fastpathTV.DecMapUint8Int16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8Int16V(rv2i(rv).(map[uint8]int16), false, d)
}
func (f fastpathT) DecMapUint8Int16X(vp *map[uint8]int16, d *Decoder) {
	if v, changed := f.DecMapUint8Int16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8Int16V(v map[uint8]int16, canChange bool,
	d *Decoder) (_ map[uint8]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 3)
		v = make(map[uint8]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint8
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8Int32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]int32)
		if v, changed := fastpathTV.DecMapUint8Int32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8Int32V(rv2i(rv).(map[uint8]int32), false, d)
}
func (f fastpathT) DecMapUint8Int32X(vp *map[uint8]int32, d *Decoder) {
	if v, changed := f.DecMapUint8Int32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8Int32V(v map[uint8]int32, canChange bool,
	d *Decoder) (_ map[uint8]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[uint8]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint8
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8Int64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]int64)
		if v, changed := fastpathTV.DecMapUint8Int64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8Int64V(rv2i(rv).(map[uint8]int64), false, d)
}
func (f fastpathT) DecMapUint8Int64X(vp *map[uint8]int64, d *Decoder) {
	if v, changed := f.DecMapUint8Int64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8Int64V(v map[uint8]int64, canChange bool,
	d *Decoder) (_ map[uint8]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[uint8]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint8
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8Float32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]float32)
		if v, changed := fastpathTV.DecMapUint8Float32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8Float32V(rv2i(rv).(map[uint8]float32), false, d)
}
func (f fastpathT) DecMapUint8Float32X(vp *map[uint8]float32, d *Decoder) {
	if v, changed := f.DecMapUint8Float32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8Float32V(v map[uint8]float32, canChange bool,
	d *Decoder) (_ map[uint8]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[uint8]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint8
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8Float64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]float64)
		if v, changed := fastpathTV.DecMapUint8Float64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8Float64V(rv2i(rv).(map[uint8]float64), false, d)
}
func (f fastpathT) DecMapUint8Float64X(vp *map[uint8]float64, d *Decoder) {
	if v, changed := f.DecMapUint8Float64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8Float64V(v map[uint8]float64, canChange bool,
	d *Decoder) (_ map[uint8]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[uint8]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint8
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint8BoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint8]bool)
		if v, changed := fastpathTV.DecMapUint8BoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint8BoolV(rv2i(rv).(map[uint8]bool), false, d)
}
func (f fastpathT) DecMapUint8BoolX(vp *map[uint8]bool, d *Decoder) {
	if v, changed := f.DecMapUint8BoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint8BoolV(v map[uint8]bool, canChange bool,
	d *Decoder) (_ map[uint8]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 2)
		v = make(map[uint8]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint8
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint8(dd.DecodeUint(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16IntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]interface{})
		if v, changed := fastpathTV.DecMapUint16IntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16IntfV(rv2i(rv).(map[uint16]interface{}), false, d)
}
func (f fastpathT) DecMapUint16IntfX(vp *map[uint16]interface{}, d *Decoder) {
	if v, changed := f.DecMapUint16IntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16IntfV(v map[uint16]interface{}, canChange bool,
	d *Decoder) (_ map[uint16]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 18)
		v = make(map[uint16]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk uint16
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16StringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]string)
		if v, changed := fastpathTV.DecMapUint16StringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16StringV(rv2i(rv).(map[uint16]string), false, d)
}
func (f fastpathT) DecMapUint16StringX(vp *map[uint16]string, d *Decoder) {
	if v, changed := f.DecMapUint16StringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16StringV(v map[uint16]string, canChange bool,
	d *Decoder) (_ map[uint16]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 18)
		v = make(map[uint16]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint16
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16UintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]uint)
		if v, changed := fastpathTV.DecMapUint16UintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16UintV(rv2i(rv).(map[uint16]uint), false, d)
}
func (f fastpathT) DecMapUint16UintX(vp *map[uint16]uint, d *Decoder) {
	if v, changed := f.DecMapUint16UintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16UintV(v map[uint16]uint, canChange bool,
	d *Decoder) (_ map[uint16]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[uint16]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint16
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16Uint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]uint8)
		if v, changed := fastpathTV.DecMapUint16Uint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16Uint8V(rv2i(rv).(map[uint16]uint8), false, d)
}
func (f fastpathT) DecMapUint16Uint8X(vp *map[uint16]uint8, d *Decoder) {
	if v, changed := f.DecMapUint16Uint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16Uint8V(v map[uint16]uint8, canChange bool,
	d *Decoder) (_ map[uint16]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 3)
		v = make(map[uint16]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint16
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16Uint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]uint16)
		if v, changed := fastpathTV.DecMapUint16Uint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16Uint16V(rv2i(rv).(map[uint16]uint16), false, d)
}
func (f fastpathT) DecMapUint16Uint16X(vp *map[uint16]uint16, d *Decoder) {
	if v, changed := f.DecMapUint16Uint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16Uint16V(v map[uint16]uint16, canChange bool,
	d *Decoder) (_ map[uint16]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 4)
		v = make(map[uint16]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint16
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16Uint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]uint32)
		if v, changed := fastpathTV.DecMapUint16Uint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16Uint32V(rv2i(rv).(map[uint16]uint32), false, d)
}
func (f fastpathT) DecMapUint16Uint32X(vp *map[uint16]uint32, d *Decoder) {
	if v, changed := f.DecMapUint16Uint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16Uint32V(v map[uint16]uint32, canChange bool,
	d *Decoder) (_ map[uint16]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 6)
		v = make(map[uint16]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint16
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16Uint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]uint64)
		if v, changed := fastpathTV.DecMapUint16Uint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16Uint64V(rv2i(rv).(map[uint16]uint64), false, d)
}
func (f fastpathT) DecMapUint16Uint64X(vp *map[uint16]uint64, d *Decoder) {
	if v, changed := f.DecMapUint16Uint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16Uint64V(v map[uint16]uint64, canChange bool,
	d *Decoder) (_ map[uint16]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[uint16]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint16
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16UintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]uintptr)
		if v, changed := fastpathTV.DecMapUint16UintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16UintptrV(rv2i(rv).(map[uint16]uintptr), false, d)
}
func (f fastpathT) DecMapUint16UintptrX(vp *map[uint16]uintptr, d *Decoder) {
	if v, changed := f.DecMapUint16UintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16UintptrV(v map[uint16]uintptr, canChange bool,
	d *Decoder) (_ map[uint16]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[uint16]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint16
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16IntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]int)
		if v, changed := fastpathTV.DecMapUint16IntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16IntV(rv2i(rv).(map[uint16]int), false, d)
}
func (f fastpathT) DecMapUint16IntX(vp *map[uint16]int, d *Decoder) {
	if v, changed := f.DecMapUint16IntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16IntV(v map[uint16]int, canChange bool,
	d *Decoder) (_ map[uint16]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[uint16]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint16
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16Int8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]int8)
		if v, changed := fastpathTV.DecMapUint16Int8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16Int8V(rv2i(rv).(map[uint16]int8), false, d)
}
func (f fastpathT) DecMapUint16Int8X(vp *map[uint16]int8, d *Decoder) {
	if v, changed := f.DecMapUint16Int8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16Int8V(v map[uint16]int8, canChange bool,
	d *Decoder) (_ map[uint16]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 3)
		v = make(map[uint16]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint16
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16Int16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]int16)
		if v, changed := fastpathTV.DecMapUint16Int16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16Int16V(rv2i(rv).(map[uint16]int16), false, d)
}
func (f fastpathT) DecMapUint16Int16X(vp *map[uint16]int16, d *Decoder) {
	if v, changed := f.DecMapUint16Int16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16Int16V(v map[uint16]int16, canChange bool,
	d *Decoder) (_ map[uint16]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 4)
		v = make(map[uint16]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint16
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16Int32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]int32)
		if v, changed := fastpathTV.DecMapUint16Int32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16Int32V(rv2i(rv).(map[uint16]int32), false, d)
}
func (f fastpathT) DecMapUint16Int32X(vp *map[uint16]int32, d *Decoder) {
	if v, changed := f.DecMapUint16Int32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16Int32V(v map[uint16]int32, canChange bool,
	d *Decoder) (_ map[uint16]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 6)
		v = make(map[uint16]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint16
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16Int64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]int64)
		if v, changed := fastpathTV.DecMapUint16Int64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16Int64V(rv2i(rv).(map[uint16]int64), false, d)
}
func (f fastpathT) DecMapUint16Int64X(vp *map[uint16]int64, d *Decoder) {
	if v, changed := f.DecMapUint16Int64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16Int64V(v map[uint16]int64, canChange bool,
	d *Decoder) (_ map[uint16]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[uint16]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint16
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16Float32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]float32)
		if v, changed := fastpathTV.DecMapUint16Float32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16Float32V(rv2i(rv).(map[uint16]float32), false, d)
}
func (f fastpathT) DecMapUint16Float32X(vp *map[uint16]float32, d *Decoder) {
	if v, changed := f.DecMapUint16Float32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16Float32V(v map[uint16]float32, canChange bool,
	d *Decoder) (_ map[uint16]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 6)
		v = make(map[uint16]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint16
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16Float64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]float64)
		if v, changed := fastpathTV.DecMapUint16Float64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16Float64V(rv2i(rv).(map[uint16]float64), false, d)
}
func (f fastpathT) DecMapUint16Float64X(vp *map[uint16]float64, d *Decoder) {
	if v, changed := f.DecMapUint16Float64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16Float64V(v map[uint16]float64, canChange bool,
	d *Decoder) (_ map[uint16]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[uint16]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint16
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint16BoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint16]bool)
		if v, changed := fastpathTV.DecMapUint16BoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint16BoolV(rv2i(rv).(map[uint16]bool), false, d)
}
func (f fastpathT) DecMapUint16BoolX(vp *map[uint16]bool, d *Decoder) {
	if v, changed := f.DecMapUint16BoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint16BoolV(v map[uint16]bool, canChange bool,
	d *Decoder) (_ map[uint16]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 3)
		v = make(map[uint16]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint16
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint16(dd.DecodeUint(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32IntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]interface{})
		if v, changed := fastpathTV.DecMapUint32IntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32IntfV(rv2i(rv).(map[uint32]interface{}), false, d)
}
func (f fastpathT) DecMapUint32IntfX(vp *map[uint32]interface{}, d *Decoder) {
	if v, changed := f.DecMapUint32IntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32IntfV(v map[uint32]interface{}, canChange bool,
	d *Decoder) (_ map[uint32]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 20)
		v = make(map[uint32]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk uint32
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32StringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]string)
		if v, changed := fastpathTV.DecMapUint32StringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32StringV(rv2i(rv).(map[uint32]string), false, d)
}
func (f fastpathT) DecMapUint32StringX(vp *map[uint32]string, d *Decoder) {
	if v, changed := f.DecMapUint32StringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32StringV(v map[uint32]string, canChange bool,
	d *Decoder) (_ map[uint32]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 20)
		v = make(map[uint32]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint32
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32UintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]uint)
		if v, changed := fastpathTV.DecMapUint32UintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32UintV(rv2i(rv).(map[uint32]uint), false, d)
}
func (f fastpathT) DecMapUint32UintX(vp *map[uint32]uint, d *Decoder) {
	if v, changed := f.DecMapUint32UintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32UintV(v map[uint32]uint, canChange bool,
	d *Decoder) (_ map[uint32]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[uint32]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint32
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32Uint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]uint8)
		if v, changed := fastpathTV.DecMapUint32Uint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32Uint8V(rv2i(rv).(map[uint32]uint8), false, d)
}
func (f fastpathT) DecMapUint32Uint8X(vp *map[uint32]uint8, d *Decoder) {
	if v, changed := f.DecMapUint32Uint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32Uint8V(v map[uint32]uint8, canChange bool,
	d *Decoder) (_ map[uint32]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[uint32]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint32
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32Uint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]uint16)
		if v, changed := fastpathTV.DecMapUint32Uint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32Uint16V(rv2i(rv).(map[uint32]uint16), false, d)
}
func (f fastpathT) DecMapUint32Uint16X(vp *map[uint32]uint16, d *Decoder) {
	if v, changed := f.DecMapUint32Uint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32Uint16V(v map[uint32]uint16, canChange bool,
	d *Decoder) (_ map[uint32]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 6)
		v = make(map[uint32]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint32
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32Uint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]uint32)
		if v, changed := fastpathTV.DecMapUint32Uint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32Uint32V(rv2i(rv).(map[uint32]uint32), false, d)
}
func (f fastpathT) DecMapUint32Uint32X(vp *map[uint32]uint32, d *Decoder) {
	if v, changed := f.DecMapUint32Uint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32Uint32V(v map[uint32]uint32, canChange bool,
	d *Decoder) (_ map[uint32]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 8)
		v = make(map[uint32]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint32
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32Uint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]uint64)
		if v, changed := fastpathTV.DecMapUint32Uint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32Uint64V(rv2i(rv).(map[uint32]uint64), false, d)
}
func (f fastpathT) DecMapUint32Uint64X(vp *map[uint32]uint64, d *Decoder) {
	if v, changed := f.DecMapUint32Uint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32Uint64V(v map[uint32]uint64, canChange bool,
	d *Decoder) (_ map[uint32]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[uint32]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint32
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32UintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]uintptr)
		if v, changed := fastpathTV.DecMapUint32UintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32UintptrV(rv2i(rv).(map[uint32]uintptr), false, d)
}
func (f fastpathT) DecMapUint32UintptrX(vp *map[uint32]uintptr, d *Decoder) {
	if v, changed := f.DecMapUint32UintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32UintptrV(v map[uint32]uintptr, canChange bool,
	d *Decoder) (_ map[uint32]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[uint32]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint32
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32IntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]int)
		if v, changed := fastpathTV.DecMapUint32IntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32IntV(rv2i(rv).(map[uint32]int), false, d)
}
func (f fastpathT) DecMapUint32IntX(vp *map[uint32]int, d *Decoder) {
	if v, changed := f.DecMapUint32IntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32IntV(v map[uint32]int, canChange bool,
	d *Decoder) (_ map[uint32]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[uint32]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint32
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32Int8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]int8)
		if v, changed := fastpathTV.DecMapUint32Int8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32Int8V(rv2i(rv).(map[uint32]int8), false, d)
}
func (f fastpathT) DecMapUint32Int8X(vp *map[uint32]int8, d *Decoder) {
	if v, changed := f.DecMapUint32Int8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32Int8V(v map[uint32]int8, canChange bool,
	d *Decoder) (_ map[uint32]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[uint32]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint32
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32Int16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]int16)
		if v, changed := fastpathTV.DecMapUint32Int16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32Int16V(rv2i(rv).(map[uint32]int16), false, d)
}
func (f fastpathT) DecMapUint32Int16X(vp *map[uint32]int16, d *Decoder) {
	if v, changed := f.DecMapUint32Int16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32Int16V(v map[uint32]int16, canChange bool,
	d *Decoder) (_ map[uint32]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 6)
		v = make(map[uint32]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint32
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32Int32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]int32)
		if v, changed := fastpathTV.DecMapUint32Int32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32Int32V(rv2i(rv).(map[uint32]int32), false, d)
}
func (f fastpathT) DecMapUint32Int32X(vp *map[uint32]int32, d *Decoder) {
	if v, changed := f.DecMapUint32Int32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32Int32V(v map[uint32]int32, canChange bool,
	d *Decoder) (_ map[uint32]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 8)
		v = make(map[uint32]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint32
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32Int64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]int64)
		if v, changed := fastpathTV.DecMapUint32Int64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32Int64V(rv2i(rv).(map[uint32]int64), false, d)
}
func (f fastpathT) DecMapUint32Int64X(vp *map[uint32]int64, d *Decoder) {
	if v, changed := f.DecMapUint32Int64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32Int64V(v map[uint32]int64, canChange bool,
	d *Decoder) (_ map[uint32]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[uint32]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint32
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32Float32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]float32)
		if v, changed := fastpathTV.DecMapUint32Float32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32Float32V(rv2i(rv).(map[uint32]float32), false, d)
}
func (f fastpathT) DecMapUint32Float32X(vp *map[uint32]float32, d *Decoder) {
	if v, changed := f.DecMapUint32Float32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32Float32V(v map[uint32]float32, canChange bool,
	d *Decoder) (_ map[uint32]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 8)
		v = make(map[uint32]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint32
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32Float64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]float64)
		if v, changed := fastpathTV.DecMapUint32Float64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32Float64V(rv2i(rv).(map[uint32]float64), false, d)
}
func (f fastpathT) DecMapUint32Float64X(vp *map[uint32]float64, d *Decoder) {
	if v, changed := f.DecMapUint32Float64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32Float64V(v map[uint32]float64, canChange bool,
	d *Decoder) (_ map[uint32]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[uint32]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint32
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint32BoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint32]bool)
		if v, changed := fastpathTV.DecMapUint32BoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint32BoolV(rv2i(rv).(map[uint32]bool), false, d)
}
func (f fastpathT) DecMapUint32BoolX(vp *map[uint32]bool, d *Decoder) {
	if v, changed := f.DecMapUint32BoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint32BoolV(v map[uint32]bool, canChange bool,
	d *Decoder) (_ map[uint32]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[uint32]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint32
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uint32(dd.DecodeUint(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64IntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]interface{})
		if v, changed := fastpathTV.DecMapUint64IntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64IntfV(rv2i(rv).(map[uint64]interface{}), false, d)
}
func (f fastpathT) DecMapUint64IntfX(vp *map[uint64]interface{}, d *Decoder) {
	if v, changed := f.DecMapUint64IntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64IntfV(v map[uint64]interface{}, canChange bool,
	d *Decoder) (_ map[uint64]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[uint64]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk uint64
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64StringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]string)
		if v, changed := fastpathTV.DecMapUint64StringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64StringV(rv2i(rv).(map[uint64]string), false, d)
}
func (f fastpathT) DecMapUint64StringX(vp *map[uint64]string, d *Decoder) {
	if v, changed := f.DecMapUint64StringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64StringV(v map[uint64]string, canChange bool,
	d *Decoder) (_ map[uint64]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[uint64]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint64
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64UintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]uint)
		if v, changed := fastpathTV.DecMapUint64UintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64UintV(rv2i(rv).(map[uint64]uint), false, d)
}
func (f fastpathT) DecMapUint64UintX(vp *map[uint64]uint, d *Decoder) {
	if v, changed := f.DecMapUint64UintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64UintV(v map[uint64]uint, canChange bool,
	d *Decoder) (_ map[uint64]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uint64]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint64
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64Uint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]uint8)
		if v, changed := fastpathTV.DecMapUint64Uint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64Uint8V(rv2i(rv).(map[uint64]uint8), false, d)
}
func (f fastpathT) DecMapUint64Uint8X(vp *map[uint64]uint8, d *Decoder) {
	if v, changed := f.DecMapUint64Uint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64Uint8V(v map[uint64]uint8, canChange bool,
	d *Decoder) (_ map[uint64]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[uint64]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint64
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64Uint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]uint16)
		if v, changed := fastpathTV.DecMapUint64Uint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64Uint16V(rv2i(rv).(map[uint64]uint16), false, d)
}
func (f fastpathT) DecMapUint64Uint16X(vp *map[uint64]uint16, d *Decoder) {
	if v, changed := f.DecMapUint64Uint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64Uint16V(v map[uint64]uint16, canChange bool,
	d *Decoder) (_ map[uint64]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[uint64]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint64
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64Uint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]uint32)
		if v, changed := fastpathTV.DecMapUint64Uint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64Uint32V(rv2i(rv).(map[uint64]uint32), false, d)
}
func (f fastpathT) DecMapUint64Uint32X(vp *map[uint64]uint32, d *Decoder) {
	if v, changed := f.DecMapUint64Uint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64Uint32V(v map[uint64]uint32, canChange bool,
	d *Decoder) (_ map[uint64]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[uint64]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint64
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64Uint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]uint64)
		if v, changed := fastpathTV.DecMapUint64Uint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64Uint64V(rv2i(rv).(map[uint64]uint64), false, d)
}
func (f fastpathT) DecMapUint64Uint64X(vp *map[uint64]uint64, d *Decoder) {
	if v, changed := f.DecMapUint64Uint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64Uint64V(v map[uint64]uint64, canChange bool,
	d *Decoder) (_ map[uint64]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uint64]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint64
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64UintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]uintptr)
		if v, changed := fastpathTV.DecMapUint64UintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64UintptrV(rv2i(rv).(map[uint64]uintptr), false, d)
}
func (f fastpathT) DecMapUint64UintptrX(vp *map[uint64]uintptr, d *Decoder) {
	if v, changed := f.DecMapUint64UintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64UintptrV(v map[uint64]uintptr, canChange bool,
	d *Decoder) (_ map[uint64]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uint64]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint64
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64IntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]int)
		if v, changed := fastpathTV.DecMapUint64IntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64IntV(rv2i(rv).(map[uint64]int), false, d)
}
func (f fastpathT) DecMapUint64IntX(vp *map[uint64]int, d *Decoder) {
	if v, changed := f.DecMapUint64IntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64IntV(v map[uint64]int, canChange bool,
	d *Decoder) (_ map[uint64]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uint64]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint64
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64Int8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]int8)
		if v, changed := fastpathTV.DecMapUint64Int8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64Int8V(rv2i(rv).(map[uint64]int8), false, d)
}
func (f fastpathT) DecMapUint64Int8X(vp *map[uint64]int8, d *Decoder) {
	if v, changed := f.DecMapUint64Int8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64Int8V(v map[uint64]int8, canChange bool,
	d *Decoder) (_ map[uint64]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[uint64]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint64
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64Int16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]int16)
		if v, changed := fastpathTV.DecMapUint64Int16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64Int16V(rv2i(rv).(map[uint64]int16), false, d)
}
func (f fastpathT) DecMapUint64Int16X(vp *map[uint64]int16, d *Decoder) {
	if v, changed := f.DecMapUint64Int16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64Int16V(v map[uint64]int16, canChange bool,
	d *Decoder) (_ map[uint64]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[uint64]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint64
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64Int32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]int32)
		if v, changed := fastpathTV.DecMapUint64Int32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64Int32V(rv2i(rv).(map[uint64]int32), false, d)
}
func (f fastpathT) DecMapUint64Int32X(vp *map[uint64]int32, d *Decoder) {
	if v, changed := f.DecMapUint64Int32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64Int32V(v map[uint64]int32, canChange bool,
	d *Decoder) (_ map[uint64]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[uint64]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint64
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64Int64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]int64)
		if v, changed := fastpathTV.DecMapUint64Int64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64Int64V(rv2i(rv).(map[uint64]int64), false, d)
}
func (f fastpathT) DecMapUint64Int64X(vp *map[uint64]int64, d *Decoder) {
	if v, changed := f.DecMapUint64Int64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64Int64V(v map[uint64]int64, canChange bool,
	d *Decoder) (_ map[uint64]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uint64]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint64
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64Float32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]float32)
		if v, changed := fastpathTV.DecMapUint64Float32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64Float32V(rv2i(rv).(map[uint64]float32), false, d)
}
func (f fastpathT) DecMapUint64Float32X(vp *map[uint64]float32, d *Decoder) {
	if v, changed := f.DecMapUint64Float32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64Float32V(v map[uint64]float32, canChange bool,
	d *Decoder) (_ map[uint64]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[uint64]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint64
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64Float64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]float64)
		if v, changed := fastpathTV.DecMapUint64Float64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64Float64V(rv2i(rv).(map[uint64]float64), false, d)
}
func (f fastpathT) DecMapUint64Float64X(vp *map[uint64]float64, d *Decoder) {
	if v, changed := f.DecMapUint64Float64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64Float64V(v map[uint64]float64, canChange bool,
	d *Decoder) (_ map[uint64]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uint64]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint64
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUint64BoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uint64]bool)
		if v, changed := fastpathTV.DecMapUint64BoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUint64BoolV(rv2i(rv).(map[uint64]bool), false, d)
}
func (f fastpathT) DecMapUint64BoolX(vp *map[uint64]bool, d *Decoder) {
	if v, changed := f.DecMapUint64BoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUint64BoolV(v map[uint64]bool, canChange bool,
	d *Decoder) (_ map[uint64]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[uint64]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uint64
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeUint(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrIntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]interface{})
		if v, changed := fastpathTV.DecMapUintptrIntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrIntfV(rv2i(rv).(map[uintptr]interface{}), false, d)
}
func (f fastpathT) DecMapUintptrIntfX(vp *map[uintptr]interface{}, d *Decoder) {
	if v, changed := f.DecMapUintptrIntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrIntfV(v map[uintptr]interface{}, canChange bool,
	d *Decoder) (_ map[uintptr]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[uintptr]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk uintptr
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrStringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]string)
		if v, changed := fastpathTV.DecMapUintptrStringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrStringV(rv2i(rv).(map[uintptr]string), false, d)
}
func (f fastpathT) DecMapUintptrStringX(vp *map[uintptr]string, d *Decoder) {
	if v, changed := f.DecMapUintptrStringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrStringV(v map[uintptr]string, canChange bool,
	d *Decoder) (_ map[uintptr]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[uintptr]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uintptr
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrUintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]uint)
		if v, changed := fastpathTV.DecMapUintptrUintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrUintV(rv2i(rv).(map[uintptr]uint), false, d)
}
func (f fastpathT) DecMapUintptrUintX(vp *map[uintptr]uint, d *Decoder) {
	if v, changed := f.DecMapUintptrUintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrUintV(v map[uintptr]uint, canChange bool,
	d *Decoder) (_ map[uintptr]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uintptr]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uintptr
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrUint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]uint8)
		if v, changed := fastpathTV.DecMapUintptrUint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrUint8V(rv2i(rv).(map[uintptr]uint8), false, d)
}
func (f fastpathT) DecMapUintptrUint8X(vp *map[uintptr]uint8, d *Decoder) {
	if v, changed := f.DecMapUintptrUint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrUint8V(v map[uintptr]uint8, canChange bool,
	d *Decoder) (_ map[uintptr]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[uintptr]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uintptr
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrUint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]uint16)
		if v, changed := fastpathTV.DecMapUintptrUint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrUint16V(rv2i(rv).(map[uintptr]uint16), false, d)
}
func (f fastpathT) DecMapUintptrUint16X(vp *map[uintptr]uint16, d *Decoder) {
	if v, changed := f.DecMapUintptrUint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrUint16V(v map[uintptr]uint16, canChange bool,
	d *Decoder) (_ map[uintptr]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[uintptr]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uintptr
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrUint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]uint32)
		if v, changed := fastpathTV.DecMapUintptrUint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrUint32V(rv2i(rv).(map[uintptr]uint32), false, d)
}
func (f fastpathT) DecMapUintptrUint32X(vp *map[uintptr]uint32, d *Decoder) {
	if v, changed := f.DecMapUintptrUint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrUint32V(v map[uintptr]uint32, canChange bool,
	d *Decoder) (_ map[uintptr]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[uintptr]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uintptr
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrUint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]uint64)
		if v, changed := fastpathTV.DecMapUintptrUint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrUint64V(rv2i(rv).(map[uintptr]uint64), false, d)
}
func (f fastpathT) DecMapUintptrUint64X(vp *map[uintptr]uint64, d *Decoder) {
	if v, changed := f.DecMapUintptrUint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrUint64V(v map[uintptr]uint64, canChange bool,
	d *Decoder) (_ map[uintptr]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uintptr]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uintptr
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrUintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]uintptr)
		if v, changed := fastpathTV.DecMapUintptrUintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrUintptrV(rv2i(rv).(map[uintptr]uintptr), false, d)
}
func (f fastpathT) DecMapUintptrUintptrX(vp *map[uintptr]uintptr, d *Decoder) {
	if v, changed := f.DecMapUintptrUintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrUintptrV(v map[uintptr]uintptr, canChange bool,
	d *Decoder) (_ map[uintptr]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uintptr]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uintptr
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrIntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]int)
		if v, changed := fastpathTV.DecMapUintptrIntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrIntV(rv2i(rv).(map[uintptr]int), false, d)
}
func (f fastpathT) DecMapUintptrIntX(vp *map[uintptr]int, d *Decoder) {
	if v, changed := f.DecMapUintptrIntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrIntV(v map[uintptr]int, canChange bool,
	d *Decoder) (_ map[uintptr]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uintptr]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uintptr
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrInt8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]int8)
		if v, changed := fastpathTV.DecMapUintptrInt8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrInt8V(rv2i(rv).(map[uintptr]int8), false, d)
}
func (f fastpathT) DecMapUintptrInt8X(vp *map[uintptr]int8, d *Decoder) {
	if v, changed := f.DecMapUintptrInt8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrInt8V(v map[uintptr]int8, canChange bool,
	d *Decoder) (_ map[uintptr]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[uintptr]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uintptr
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrInt16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]int16)
		if v, changed := fastpathTV.DecMapUintptrInt16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrInt16V(rv2i(rv).(map[uintptr]int16), false, d)
}
func (f fastpathT) DecMapUintptrInt16X(vp *map[uintptr]int16, d *Decoder) {
	if v, changed := f.DecMapUintptrInt16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrInt16V(v map[uintptr]int16, canChange bool,
	d *Decoder) (_ map[uintptr]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[uintptr]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uintptr
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrInt32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]int32)
		if v, changed := fastpathTV.DecMapUintptrInt32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrInt32V(rv2i(rv).(map[uintptr]int32), false, d)
}
func (f fastpathT) DecMapUintptrInt32X(vp *map[uintptr]int32, d *Decoder) {
	if v, changed := f.DecMapUintptrInt32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrInt32V(v map[uintptr]int32, canChange bool,
	d *Decoder) (_ map[uintptr]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[uintptr]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uintptr
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrInt64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]int64)
		if v, changed := fastpathTV.DecMapUintptrInt64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrInt64V(rv2i(rv).(map[uintptr]int64), false, d)
}
func (f fastpathT) DecMapUintptrInt64X(vp *map[uintptr]int64, d *Decoder) {
	if v, changed := f.DecMapUintptrInt64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrInt64V(v map[uintptr]int64, canChange bool,
	d *Decoder) (_ map[uintptr]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uintptr]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uintptr
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrFloat32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]float32)
		if v, changed := fastpathTV.DecMapUintptrFloat32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrFloat32V(rv2i(rv).(map[uintptr]float32), false, d)
}
func (f fastpathT) DecMapUintptrFloat32X(vp *map[uintptr]float32, d *Decoder) {
	if v, changed := f.DecMapUintptrFloat32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrFloat32V(v map[uintptr]float32, canChange bool,
	d *Decoder) (_ map[uintptr]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[uintptr]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uintptr
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrFloat64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]float64)
		if v, changed := fastpathTV.DecMapUintptrFloat64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrFloat64V(rv2i(rv).(map[uintptr]float64), false, d)
}
func (f fastpathT) DecMapUintptrFloat64X(vp *map[uintptr]float64, d *Decoder) {
	if v, changed := f.DecMapUintptrFloat64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrFloat64V(v map[uintptr]float64, canChange bool,
	d *Decoder) (_ map[uintptr]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[uintptr]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uintptr
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapUintptrBoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[uintptr]bool)
		if v, changed := fastpathTV.DecMapUintptrBoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapUintptrBoolV(rv2i(rv).(map[uintptr]bool), false, d)
}
func (f fastpathT) DecMapUintptrBoolX(vp *map[uintptr]bool, d *Decoder) {
	if v, changed := f.DecMapUintptrBoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapUintptrBoolV(v map[uintptr]bool, canChange bool,
	d *Decoder) (_ map[uintptr]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[uintptr]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk uintptr
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = uintptr(dd.DecodeUint(uintBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntIntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]interface{})
		if v, changed := fastpathTV.DecMapIntIntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntIntfV(rv2i(rv).(map[int]interface{}), false, d)
}
func (f fastpathT) DecMapIntIntfX(vp *map[int]interface{}, d *Decoder) {
	if v, changed := f.DecMapIntIntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntIntfV(v map[int]interface{}, canChange bool,
	d *Decoder) (_ map[int]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[int]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk int
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntStringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]string)
		if v, changed := fastpathTV.DecMapIntStringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntStringV(rv2i(rv).(map[int]string), false, d)
}
func (f fastpathT) DecMapIntStringX(vp *map[int]string, d *Decoder) {
	if v, changed := f.DecMapIntStringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntStringV(v map[int]string, canChange bool,
	d *Decoder) (_ map[int]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[int]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntUintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]uint)
		if v, changed := fastpathTV.DecMapIntUintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntUintV(rv2i(rv).(map[int]uint), false, d)
}
func (f fastpathT) DecMapIntUintX(vp *map[int]uint, d *Decoder) {
	if v, changed := f.DecMapIntUintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntUintV(v map[int]uint, canChange bool,
	d *Decoder) (_ map[int]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[int]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntUint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]uint8)
		if v, changed := fastpathTV.DecMapIntUint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntUint8V(rv2i(rv).(map[int]uint8), false, d)
}
func (f fastpathT) DecMapIntUint8X(vp *map[int]uint8, d *Decoder) {
	if v, changed := f.DecMapIntUint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntUint8V(v map[int]uint8, canChange bool,
	d *Decoder) (_ map[int]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[int]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntUint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]uint16)
		if v, changed := fastpathTV.DecMapIntUint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntUint16V(rv2i(rv).(map[int]uint16), false, d)
}
func (f fastpathT) DecMapIntUint16X(vp *map[int]uint16, d *Decoder) {
	if v, changed := f.DecMapIntUint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntUint16V(v map[int]uint16, canChange bool,
	d *Decoder) (_ map[int]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[int]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntUint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]uint32)
		if v, changed := fastpathTV.DecMapIntUint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntUint32V(rv2i(rv).(map[int]uint32), false, d)
}
func (f fastpathT) DecMapIntUint32X(vp *map[int]uint32, d *Decoder) {
	if v, changed := f.DecMapIntUint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntUint32V(v map[int]uint32, canChange bool,
	d *Decoder) (_ map[int]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[int]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntUint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]uint64)
		if v, changed := fastpathTV.DecMapIntUint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntUint64V(rv2i(rv).(map[int]uint64), false, d)
}
func (f fastpathT) DecMapIntUint64X(vp *map[int]uint64, d *Decoder) {
	if v, changed := f.DecMapIntUint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntUint64V(v map[int]uint64, canChange bool,
	d *Decoder) (_ map[int]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[int]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntUintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]uintptr)
		if v, changed := fastpathTV.DecMapIntUintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntUintptrV(rv2i(rv).(map[int]uintptr), false, d)
}
func (f fastpathT) DecMapIntUintptrX(vp *map[int]uintptr, d *Decoder) {
	if v, changed := f.DecMapIntUintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntUintptrV(v map[int]uintptr, canChange bool,
	d *Decoder) (_ map[int]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[int]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntIntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]int)
		if v, changed := fastpathTV.DecMapIntIntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntIntV(rv2i(rv).(map[int]int), false, d)
}
func (f fastpathT) DecMapIntIntX(vp *map[int]int, d *Decoder) {
	if v, changed := f.DecMapIntIntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntIntV(v map[int]int, canChange bool,
	d *Decoder) (_ map[int]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[int]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntInt8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]int8)
		if v, changed := fastpathTV.DecMapIntInt8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntInt8V(rv2i(rv).(map[int]int8), false, d)
}
func (f fastpathT) DecMapIntInt8X(vp *map[int]int8, d *Decoder) {
	if v, changed := f.DecMapIntInt8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntInt8V(v map[int]int8, canChange bool,
	d *Decoder) (_ map[int]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[int]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntInt16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]int16)
		if v, changed := fastpathTV.DecMapIntInt16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntInt16V(rv2i(rv).(map[int]int16), false, d)
}
func (f fastpathT) DecMapIntInt16X(vp *map[int]int16, d *Decoder) {
	if v, changed := f.DecMapIntInt16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntInt16V(v map[int]int16, canChange bool,
	d *Decoder) (_ map[int]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[int]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntInt32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]int32)
		if v, changed := fastpathTV.DecMapIntInt32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntInt32V(rv2i(rv).(map[int]int32), false, d)
}
func (f fastpathT) DecMapIntInt32X(vp *map[int]int32, d *Decoder) {
	if v, changed := f.DecMapIntInt32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntInt32V(v map[int]int32, canChange bool,
	d *Decoder) (_ map[int]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[int]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntInt64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]int64)
		if v, changed := fastpathTV.DecMapIntInt64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntInt64V(rv2i(rv).(map[int]int64), false, d)
}
func (f fastpathT) DecMapIntInt64X(vp *map[int]int64, d *Decoder) {
	if v, changed := f.DecMapIntInt64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntInt64V(v map[int]int64, canChange bool,
	d *Decoder) (_ map[int]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[int]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntFloat32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]float32)
		if v, changed := fastpathTV.DecMapIntFloat32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntFloat32V(rv2i(rv).(map[int]float32), false, d)
}
func (f fastpathT) DecMapIntFloat32X(vp *map[int]float32, d *Decoder) {
	if v, changed := f.DecMapIntFloat32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntFloat32V(v map[int]float32, canChange bool,
	d *Decoder) (_ map[int]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[int]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntFloat64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]float64)
		if v, changed := fastpathTV.DecMapIntFloat64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntFloat64V(rv2i(rv).(map[int]float64), false, d)
}
func (f fastpathT) DecMapIntFloat64X(vp *map[int]float64, d *Decoder) {
	if v, changed := f.DecMapIntFloat64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntFloat64V(v map[int]float64, canChange bool,
	d *Decoder) (_ map[int]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[int]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntBoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int]bool)
		if v, changed := fastpathTV.DecMapIntBoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntBoolV(rv2i(rv).(map[int]bool), false, d)
}
func (f fastpathT) DecMapIntBoolX(vp *map[int]bool, d *Decoder) {
	if v, changed := f.DecMapIntBoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntBoolV(v map[int]bool, canChange bool,
	d *Decoder) (_ map[int]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[int]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int(dd.DecodeInt(intBitsize))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8IntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]interface{})
		if v, changed := fastpathTV.DecMapInt8IntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8IntfV(rv2i(rv).(map[int8]interface{}), false, d)
}
func (f fastpathT) DecMapInt8IntfX(vp *map[int8]interface{}, d *Decoder) {
	if v, changed := f.DecMapInt8IntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8IntfV(v map[int8]interface{}, canChange bool,
	d *Decoder) (_ map[int8]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 17)
		v = make(map[int8]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk int8
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8StringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]string)
		if v, changed := fastpathTV.DecMapInt8StringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8StringV(rv2i(rv).(map[int8]string), false, d)
}
func (f fastpathT) DecMapInt8StringX(vp *map[int8]string, d *Decoder) {
	if v, changed := f.DecMapInt8StringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8StringV(v map[int8]string, canChange bool,
	d *Decoder) (_ map[int8]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 17)
		v = make(map[int8]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int8
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8UintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]uint)
		if v, changed := fastpathTV.DecMapInt8UintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8UintV(rv2i(rv).(map[int8]uint), false, d)
}
func (f fastpathT) DecMapInt8UintX(vp *map[int8]uint, d *Decoder) {
	if v, changed := f.DecMapInt8UintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8UintV(v map[int8]uint, canChange bool,
	d *Decoder) (_ map[int8]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[int8]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int8
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8Uint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]uint8)
		if v, changed := fastpathTV.DecMapInt8Uint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8Uint8V(rv2i(rv).(map[int8]uint8), false, d)
}
func (f fastpathT) DecMapInt8Uint8X(vp *map[int8]uint8, d *Decoder) {
	if v, changed := f.DecMapInt8Uint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8Uint8V(v map[int8]uint8, canChange bool,
	d *Decoder) (_ map[int8]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 2)
		v = make(map[int8]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int8
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8Uint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]uint16)
		if v, changed := fastpathTV.DecMapInt8Uint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8Uint16V(rv2i(rv).(map[int8]uint16), false, d)
}
func (f fastpathT) DecMapInt8Uint16X(vp *map[int8]uint16, d *Decoder) {
	if v, changed := f.DecMapInt8Uint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8Uint16V(v map[int8]uint16, canChange bool,
	d *Decoder) (_ map[int8]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 3)
		v = make(map[int8]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int8
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8Uint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]uint32)
		if v, changed := fastpathTV.DecMapInt8Uint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8Uint32V(rv2i(rv).(map[int8]uint32), false, d)
}
func (f fastpathT) DecMapInt8Uint32X(vp *map[int8]uint32, d *Decoder) {
	if v, changed := f.DecMapInt8Uint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8Uint32V(v map[int8]uint32, canChange bool,
	d *Decoder) (_ map[int8]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[int8]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int8
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8Uint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]uint64)
		if v, changed := fastpathTV.DecMapInt8Uint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8Uint64V(rv2i(rv).(map[int8]uint64), false, d)
}
func (f fastpathT) DecMapInt8Uint64X(vp *map[int8]uint64, d *Decoder) {
	if v, changed := f.DecMapInt8Uint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8Uint64V(v map[int8]uint64, canChange bool,
	d *Decoder) (_ map[int8]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[int8]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int8
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8UintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]uintptr)
		if v, changed := fastpathTV.DecMapInt8UintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8UintptrV(rv2i(rv).(map[int8]uintptr), false, d)
}
func (f fastpathT) DecMapInt8UintptrX(vp *map[int8]uintptr, d *Decoder) {
	if v, changed := f.DecMapInt8UintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8UintptrV(v map[int8]uintptr, canChange bool,
	d *Decoder) (_ map[int8]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[int8]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int8
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8IntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]int)
		if v, changed := fastpathTV.DecMapInt8IntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8IntV(rv2i(rv).(map[int8]int), false, d)
}
func (f fastpathT) DecMapInt8IntX(vp *map[int8]int, d *Decoder) {
	if v, changed := f.DecMapInt8IntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8IntV(v map[int8]int, canChange bool,
	d *Decoder) (_ map[int8]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[int8]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int8
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8Int8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]int8)
		if v, changed := fastpathTV.DecMapInt8Int8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8Int8V(rv2i(rv).(map[int8]int8), false, d)
}
func (f fastpathT) DecMapInt8Int8X(vp *map[int8]int8, d *Decoder) {
	if v, changed := f.DecMapInt8Int8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8Int8V(v map[int8]int8, canChange bool,
	d *Decoder) (_ map[int8]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 2)
		v = make(map[int8]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int8
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8Int16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]int16)
		if v, changed := fastpathTV.DecMapInt8Int16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8Int16V(rv2i(rv).(map[int8]int16), false, d)
}
func (f fastpathT) DecMapInt8Int16X(vp *map[int8]int16, d *Decoder) {
	if v, changed := f.DecMapInt8Int16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8Int16V(v map[int8]int16, canChange bool,
	d *Decoder) (_ map[int8]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 3)
		v = make(map[int8]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int8
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8Int32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]int32)
		if v, changed := fastpathTV.DecMapInt8Int32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8Int32V(rv2i(rv).(map[int8]int32), false, d)
}
func (f fastpathT) DecMapInt8Int32X(vp *map[int8]int32, d *Decoder) {
	if v, changed := f.DecMapInt8Int32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8Int32V(v map[int8]int32, canChange bool,
	d *Decoder) (_ map[int8]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[int8]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int8
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8Int64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]int64)
		if v, changed := fastpathTV.DecMapInt8Int64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8Int64V(rv2i(rv).(map[int8]int64), false, d)
}
func (f fastpathT) DecMapInt8Int64X(vp *map[int8]int64, d *Decoder) {
	if v, changed := f.DecMapInt8Int64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8Int64V(v map[int8]int64, canChange bool,
	d *Decoder) (_ map[int8]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[int8]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int8
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8Float32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]float32)
		if v, changed := fastpathTV.DecMapInt8Float32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8Float32V(rv2i(rv).(map[int8]float32), false, d)
}
func (f fastpathT) DecMapInt8Float32X(vp *map[int8]float32, d *Decoder) {
	if v, changed := f.DecMapInt8Float32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8Float32V(v map[int8]float32, canChange bool,
	d *Decoder) (_ map[int8]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[int8]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int8
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8Float64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]float64)
		if v, changed := fastpathTV.DecMapInt8Float64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8Float64V(rv2i(rv).(map[int8]float64), false, d)
}
func (f fastpathT) DecMapInt8Float64X(vp *map[int8]float64, d *Decoder) {
	if v, changed := f.DecMapInt8Float64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8Float64V(v map[int8]float64, canChange bool,
	d *Decoder) (_ map[int8]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[int8]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int8
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt8BoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int8]bool)
		if v, changed := fastpathTV.DecMapInt8BoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt8BoolV(rv2i(rv).(map[int8]bool), false, d)
}
func (f fastpathT) DecMapInt8BoolX(vp *map[int8]bool, d *Decoder) {
	if v, changed := f.DecMapInt8BoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt8BoolV(v map[int8]bool, canChange bool,
	d *Decoder) (_ map[int8]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 2)
		v = make(map[int8]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int8
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int8(dd.DecodeInt(8))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16IntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]interface{})
		if v, changed := fastpathTV.DecMapInt16IntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16IntfV(rv2i(rv).(map[int16]interface{}), false, d)
}
func (f fastpathT) DecMapInt16IntfX(vp *map[int16]interface{}, d *Decoder) {
	if v, changed := f.DecMapInt16IntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16IntfV(v map[int16]interface{}, canChange bool,
	d *Decoder) (_ map[int16]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 18)
		v = make(map[int16]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk int16
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16StringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]string)
		if v, changed := fastpathTV.DecMapInt16StringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16StringV(rv2i(rv).(map[int16]string), false, d)
}
func (f fastpathT) DecMapInt16StringX(vp *map[int16]string, d *Decoder) {
	if v, changed := f.DecMapInt16StringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16StringV(v map[int16]string, canChange bool,
	d *Decoder) (_ map[int16]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 18)
		v = make(map[int16]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int16
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16UintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]uint)
		if v, changed := fastpathTV.DecMapInt16UintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16UintV(rv2i(rv).(map[int16]uint), false, d)
}
func (f fastpathT) DecMapInt16UintX(vp *map[int16]uint, d *Decoder) {
	if v, changed := f.DecMapInt16UintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16UintV(v map[int16]uint, canChange bool,
	d *Decoder) (_ map[int16]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[int16]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int16
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16Uint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]uint8)
		if v, changed := fastpathTV.DecMapInt16Uint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16Uint8V(rv2i(rv).(map[int16]uint8), false, d)
}
func (f fastpathT) DecMapInt16Uint8X(vp *map[int16]uint8, d *Decoder) {
	if v, changed := f.DecMapInt16Uint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16Uint8V(v map[int16]uint8, canChange bool,
	d *Decoder) (_ map[int16]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 3)
		v = make(map[int16]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int16
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16Uint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]uint16)
		if v, changed := fastpathTV.DecMapInt16Uint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16Uint16V(rv2i(rv).(map[int16]uint16), false, d)
}
func (f fastpathT) DecMapInt16Uint16X(vp *map[int16]uint16, d *Decoder) {
	if v, changed := f.DecMapInt16Uint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16Uint16V(v map[int16]uint16, canChange bool,
	d *Decoder) (_ map[int16]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 4)
		v = make(map[int16]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int16
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16Uint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]uint32)
		if v, changed := fastpathTV.DecMapInt16Uint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16Uint32V(rv2i(rv).(map[int16]uint32), false, d)
}
func (f fastpathT) DecMapInt16Uint32X(vp *map[int16]uint32, d *Decoder) {
	if v, changed := f.DecMapInt16Uint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16Uint32V(v map[int16]uint32, canChange bool,
	d *Decoder) (_ map[int16]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 6)
		v = make(map[int16]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int16
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16Uint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]uint64)
		if v, changed := fastpathTV.DecMapInt16Uint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16Uint64V(rv2i(rv).(map[int16]uint64), false, d)
}
func (f fastpathT) DecMapInt16Uint64X(vp *map[int16]uint64, d *Decoder) {
	if v, changed := f.DecMapInt16Uint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16Uint64V(v map[int16]uint64, canChange bool,
	d *Decoder) (_ map[int16]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[int16]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int16
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16UintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]uintptr)
		if v, changed := fastpathTV.DecMapInt16UintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16UintptrV(rv2i(rv).(map[int16]uintptr), false, d)
}
func (f fastpathT) DecMapInt16UintptrX(vp *map[int16]uintptr, d *Decoder) {
	if v, changed := f.DecMapInt16UintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16UintptrV(v map[int16]uintptr, canChange bool,
	d *Decoder) (_ map[int16]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[int16]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int16
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16IntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]int)
		if v, changed := fastpathTV.DecMapInt16IntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16IntV(rv2i(rv).(map[int16]int), false, d)
}
func (f fastpathT) DecMapInt16IntX(vp *map[int16]int, d *Decoder) {
	if v, changed := f.DecMapInt16IntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16IntV(v map[int16]int, canChange bool,
	d *Decoder) (_ map[int16]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[int16]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int16
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16Int8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]int8)
		if v, changed := fastpathTV.DecMapInt16Int8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16Int8V(rv2i(rv).(map[int16]int8), false, d)
}
func (f fastpathT) DecMapInt16Int8X(vp *map[int16]int8, d *Decoder) {
	if v, changed := f.DecMapInt16Int8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16Int8V(v map[int16]int8, canChange bool,
	d *Decoder) (_ map[int16]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 3)
		v = make(map[int16]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int16
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16Int16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]int16)
		if v, changed := fastpathTV.DecMapInt16Int16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16Int16V(rv2i(rv).(map[int16]int16), false, d)
}
func (f fastpathT) DecMapInt16Int16X(vp *map[int16]int16, d *Decoder) {
	if v, changed := f.DecMapInt16Int16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16Int16V(v map[int16]int16, canChange bool,
	d *Decoder) (_ map[int16]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 4)
		v = make(map[int16]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int16
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16Int32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]int32)
		if v, changed := fastpathTV.DecMapInt16Int32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16Int32V(rv2i(rv).(map[int16]int32), false, d)
}
func (f fastpathT) DecMapInt16Int32X(vp *map[int16]int32, d *Decoder) {
	if v, changed := f.DecMapInt16Int32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16Int32V(v map[int16]int32, canChange bool,
	d *Decoder) (_ map[int16]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 6)
		v = make(map[int16]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int16
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16Int64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]int64)
		if v, changed := fastpathTV.DecMapInt16Int64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16Int64V(rv2i(rv).(map[int16]int64), false, d)
}
func (f fastpathT) DecMapInt16Int64X(vp *map[int16]int64, d *Decoder) {
	if v, changed := f.DecMapInt16Int64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16Int64V(v map[int16]int64, canChange bool,
	d *Decoder) (_ map[int16]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[int16]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int16
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16Float32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]float32)
		if v, changed := fastpathTV.DecMapInt16Float32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16Float32V(rv2i(rv).(map[int16]float32), false, d)
}
func (f fastpathT) DecMapInt16Float32X(vp *map[int16]float32, d *Decoder) {
	if v, changed := f.DecMapInt16Float32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16Float32V(v map[int16]float32, canChange bool,
	d *Decoder) (_ map[int16]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 6)
		v = make(map[int16]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int16
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16Float64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]float64)
		if v, changed := fastpathTV.DecMapInt16Float64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16Float64V(rv2i(rv).(map[int16]float64), false, d)
}
func (f fastpathT) DecMapInt16Float64X(vp *map[int16]float64, d *Decoder) {
	if v, changed := f.DecMapInt16Float64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16Float64V(v map[int16]float64, canChange bool,
	d *Decoder) (_ map[int16]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[int16]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int16
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt16BoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int16]bool)
		if v, changed := fastpathTV.DecMapInt16BoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt16BoolV(rv2i(rv).(map[int16]bool), false, d)
}
func (f fastpathT) DecMapInt16BoolX(vp *map[int16]bool, d *Decoder) {
	if v, changed := f.DecMapInt16BoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt16BoolV(v map[int16]bool, canChange bool,
	d *Decoder) (_ map[int16]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 3)
		v = make(map[int16]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int16
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int16(dd.DecodeInt(16))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32IntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]interface{})
		if v, changed := fastpathTV.DecMapInt32IntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32IntfV(rv2i(rv).(map[int32]interface{}), false, d)
}
func (f fastpathT) DecMapInt32IntfX(vp *map[int32]interface{}, d *Decoder) {
	if v, changed := f.DecMapInt32IntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32IntfV(v map[int32]interface{}, canChange bool,
	d *Decoder) (_ map[int32]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 20)
		v = make(map[int32]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk int32
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32StringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]string)
		if v, changed := fastpathTV.DecMapInt32StringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32StringV(rv2i(rv).(map[int32]string), false, d)
}
func (f fastpathT) DecMapInt32StringX(vp *map[int32]string, d *Decoder) {
	if v, changed := f.DecMapInt32StringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32StringV(v map[int32]string, canChange bool,
	d *Decoder) (_ map[int32]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 20)
		v = make(map[int32]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int32
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32UintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]uint)
		if v, changed := fastpathTV.DecMapInt32UintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32UintV(rv2i(rv).(map[int32]uint), false, d)
}
func (f fastpathT) DecMapInt32UintX(vp *map[int32]uint, d *Decoder) {
	if v, changed := f.DecMapInt32UintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32UintV(v map[int32]uint, canChange bool,
	d *Decoder) (_ map[int32]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[int32]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int32
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32Uint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]uint8)
		if v, changed := fastpathTV.DecMapInt32Uint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32Uint8V(rv2i(rv).(map[int32]uint8), false, d)
}
func (f fastpathT) DecMapInt32Uint8X(vp *map[int32]uint8, d *Decoder) {
	if v, changed := f.DecMapInt32Uint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32Uint8V(v map[int32]uint8, canChange bool,
	d *Decoder) (_ map[int32]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[int32]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int32
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32Uint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]uint16)
		if v, changed := fastpathTV.DecMapInt32Uint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32Uint16V(rv2i(rv).(map[int32]uint16), false, d)
}
func (f fastpathT) DecMapInt32Uint16X(vp *map[int32]uint16, d *Decoder) {
	if v, changed := f.DecMapInt32Uint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32Uint16V(v map[int32]uint16, canChange bool,
	d *Decoder) (_ map[int32]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 6)
		v = make(map[int32]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int32
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32Uint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]uint32)
		if v, changed := fastpathTV.DecMapInt32Uint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32Uint32V(rv2i(rv).(map[int32]uint32), false, d)
}
func (f fastpathT) DecMapInt32Uint32X(vp *map[int32]uint32, d *Decoder) {
	if v, changed := f.DecMapInt32Uint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32Uint32V(v map[int32]uint32, canChange bool,
	d *Decoder) (_ map[int32]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 8)
		v = make(map[int32]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int32
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32Uint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]uint64)
		if v, changed := fastpathTV.DecMapInt32Uint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32Uint64V(rv2i(rv).(map[int32]uint64), false, d)
}
func (f fastpathT) DecMapInt32Uint64X(vp *map[int32]uint64, d *Decoder) {
	if v, changed := f.DecMapInt32Uint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32Uint64V(v map[int32]uint64, canChange bool,
	d *Decoder) (_ map[int32]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[int32]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int32
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32UintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]uintptr)
		if v, changed := fastpathTV.DecMapInt32UintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32UintptrV(rv2i(rv).(map[int32]uintptr), false, d)
}
func (f fastpathT) DecMapInt32UintptrX(vp *map[int32]uintptr, d *Decoder) {
	if v, changed := f.DecMapInt32UintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32UintptrV(v map[int32]uintptr, canChange bool,
	d *Decoder) (_ map[int32]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[int32]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int32
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32IntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]int)
		if v, changed := fastpathTV.DecMapInt32IntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32IntV(rv2i(rv).(map[int32]int), false, d)
}
func (f fastpathT) DecMapInt32IntX(vp *map[int32]int, d *Decoder) {
	if v, changed := f.DecMapInt32IntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32IntV(v map[int32]int, canChange bool,
	d *Decoder) (_ map[int32]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[int32]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int32
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32Int8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]int8)
		if v, changed := fastpathTV.DecMapInt32Int8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32Int8V(rv2i(rv).(map[int32]int8), false, d)
}
func (f fastpathT) DecMapInt32Int8X(vp *map[int32]int8, d *Decoder) {
	if v, changed := f.DecMapInt32Int8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32Int8V(v map[int32]int8, canChange bool,
	d *Decoder) (_ map[int32]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[int32]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int32
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32Int16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]int16)
		if v, changed := fastpathTV.DecMapInt32Int16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32Int16V(rv2i(rv).(map[int32]int16), false, d)
}
func (f fastpathT) DecMapInt32Int16X(vp *map[int32]int16, d *Decoder) {
	if v, changed := f.DecMapInt32Int16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32Int16V(v map[int32]int16, canChange bool,
	d *Decoder) (_ map[int32]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 6)
		v = make(map[int32]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int32
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32Int32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]int32)
		if v, changed := fastpathTV.DecMapInt32Int32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32Int32V(rv2i(rv).(map[int32]int32), false, d)
}
func (f fastpathT) DecMapInt32Int32X(vp *map[int32]int32, d *Decoder) {
	if v, changed := f.DecMapInt32Int32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32Int32V(v map[int32]int32, canChange bool,
	d *Decoder) (_ map[int32]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 8)
		v = make(map[int32]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int32
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32Int64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]int64)
		if v, changed := fastpathTV.DecMapInt32Int64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32Int64V(rv2i(rv).(map[int32]int64), false, d)
}
func (f fastpathT) DecMapInt32Int64X(vp *map[int32]int64, d *Decoder) {
	if v, changed := f.DecMapInt32Int64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32Int64V(v map[int32]int64, canChange bool,
	d *Decoder) (_ map[int32]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[int32]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int32
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32Float32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]float32)
		if v, changed := fastpathTV.DecMapInt32Float32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32Float32V(rv2i(rv).(map[int32]float32), false, d)
}
func (f fastpathT) DecMapInt32Float32X(vp *map[int32]float32, d *Decoder) {
	if v, changed := f.DecMapInt32Float32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32Float32V(v map[int32]float32, canChange bool,
	d *Decoder) (_ map[int32]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 8)
		v = make(map[int32]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int32
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32Float64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]float64)
		if v, changed := fastpathTV.DecMapInt32Float64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32Float64V(rv2i(rv).(map[int32]float64), false, d)
}
func (f fastpathT) DecMapInt32Float64X(vp *map[int32]float64, d *Decoder) {
	if v, changed := f.DecMapInt32Float64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32Float64V(v map[int32]float64, canChange bool,
	d *Decoder) (_ map[int32]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[int32]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int32
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt32BoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int32]bool)
		if v, changed := fastpathTV.DecMapInt32BoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt32BoolV(rv2i(rv).(map[int32]bool), false, d)
}
func (f fastpathT) DecMapInt32BoolX(vp *map[int32]bool, d *Decoder) {
	if v, changed := f.DecMapInt32BoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt32BoolV(v map[int32]bool, canChange bool,
	d *Decoder) (_ map[int32]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[int32]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int32
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = int32(dd.DecodeInt(32))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64IntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]interface{})
		if v, changed := fastpathTV.DecMapInt64IntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64IntfV(rv2i(rv).(map[int64]interface{}), false, d)
}
func (f fastpathT) DecMapInt64IntfX(vp *map[int64]interface{}, d *Decoder) {
	if v, changed := f.DecMapInt64IntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64IntfV(v map[int64]interface{}, canChange bool,
	d *Decoder) (_ map[int64]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[int64]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk int64
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64StringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]string)
		if v, changed := fastpathTV.DecMapInt64StringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64StringV(rv2i(rv).(map[int64]string), false, d)
}
func (f fastpathT) DecMapInt64StringX(vp *map[int64]string, d *Decoder) {
	if v, changed := f.DecMapInt64StringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64StringV(v map[int64]string, canChange bool,
	d *Decoder) (_ map[int64]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[int64]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int64
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)€€