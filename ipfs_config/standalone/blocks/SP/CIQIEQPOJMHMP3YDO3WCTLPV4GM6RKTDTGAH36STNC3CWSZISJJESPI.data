
Š€€€tptr(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrUintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrUintptrV(rv2i(rv).(map[uintptr]uintptr), e)
}
func (_ fastpathT) EncMapUintptrUintptrV(v map[uintptr]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[uintptr(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrIntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrIntV(rv2i(rv).(map[uintptr]int), e)
}
func (_ fastpathT) EncMapUintptrIntV(v map[uintptr]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uintptr(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrInt8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrInt8V(rv2i(rv).(map[uintptr]int8), e)
}
func (_ fastpathT) EncMapUintptrInt8V(v map[uintptr]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uintptr(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrInt16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrInt16V(rv2i(rv).(map[uintptr]int16), e)
}
func (_ fastpathT) EncMapUintptrInt16V(v map[uintptr]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uintptr(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrInt32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrInt32V(rv2i(rv).(map[uintptr]int32), e)
}
func (_ fastpathT) EncMapUintptrInt32V(v map[uintptr]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uintptr(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrInt64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrInt64V(rv2i(rv).(map[uintptr]int64), e)
}
func (_ fastpathT) EncMapUintptrInt64V(v map[uintptr]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uintptr(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrFloat32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrFloat32V(rv2i(rv).(map[uintptr]float32), e)
}
func (_ fastpathT) EncMapUintptrFloat32V(v map[uintptr]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v[uintptr(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrFloat64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrFloat64V(rv2i(rv).(map[uintptr]float64), e)
}
func (_ fastpathT) EncMapUintptrFloat64V(v map[uintptr]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v[uintptr(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrBoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrBoolV(rv2i(rv).(map[uintptr]bool), e)
}
func (_ fastpathT) EncMapUintptrBoolV(v map[uintptr]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v[uintptr(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntIntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntIntfV(rv2i(rv).(map[int]interface{}), e)
}
func (_ fastpathT) EncMapIntIntfV(v map[int]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[int(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntStringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntStringV(rv2i(rv).(map[int]string), e)
}
func (_ fastpathT) EncMapIntStringV(v map[int]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v[int(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntUintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntUintV(rv2i(rv).(map[int]uint), e)
}
func (_ fastpathT) EncMapIntUintV(v map[int]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntUint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntUint8V(rv2i(rv).(map[int]uint8), e)
}
func (_ fastpathT) EncMapIntUint8V(v map[int]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntUint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntUint16V(rv2i(rv).(map[int]uint16), e)
}
func (_ fastpathT) EncMapIntUint16V(v map[int]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntUint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntUint32V(rv2i(rv).(map[int]uint32), e)
}
func (_ fastpathT) EncMapIntUint32V(v map[int]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntUint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntUint64V(rv2i(rv).(map[int]uint64), e)
}
func (_ fastpathT) EncMapIntUint64V(v map[int]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntUintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntUintptrV(rv2i(rv).(map[int]uintptr), e)
}
func (_ fastpathT) EncMapIntUintptrV(v map[int]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[int(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntIntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntIntV(rv2i(rv).(map[int]int), e)
}
func (_ fastpathT) EncMapIntIntV(v map[int]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntInt8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntInt8V(rv2i(rv).(map[int]int8), e)
}
func (_ fastpathT) EncMapIntInt8V(v map[int]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntInt16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntInt16V(rv2i(rv).(map[int]int16), e)
}
func (_ fastpathT) EncMapIntInt16V(v map[int]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntInt32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntInt32V(rv2i(rv).(map[int]int32), e)
}
func (_ fastpathT) EncMapIntInt32V(v map[int]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntInt64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntInt64V(rv2i(rv).(map[int]int64), e)
}
func (_ fastpathT) EncMapIntInt64V(v map[int]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntFloat32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntFloat32V(rv2i(rv).(map[int]float32), e)
}
func (_ fastpathT) EncMapIntFloat32V(v map[int]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v[int(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntFloat64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntFloat64V(rv2i(rv).(map[int]float64), e)
}
func (_ fastpathT) EncMapIntFloat64V(v map[int]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v[int(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntBoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntBoolV(rv2i(rv).(map[int]bool), e)
}
func (_ fastpathT) EncMapIntBoolV(v map[int]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v[int(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8IntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8IntfV(rv2i(rv).(map[int8]interface{}), e)
}
func (_ fastpathT) EncMapInt8IntfV(v map[int8]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[int8(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8StringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8StringV(rv2i(rv).(map[int8]string), e)
}
func (_ fastpathT) EncMapInt8StringV(v map[int8]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v[int8(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8UintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8UintV(rv2i(rv).(map[int8]uint), e)
}
func (_ fastpathT) EncMapInt8UintV(v map[int8]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8Uint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8Uint8V(rv2i(rv).(map[int8]uint8), e)
}
func (_ fastpathT) EncMapInt8Uint8V(v map[int8]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8Uint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8Uint16V(rv2i(rv).(map[int8]uint16), e)
}
func (_ fastpathT) EncMapInt8Uint16V(v map[int8]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8Uint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8Uint32V(rv2i(rv).(map[int8]uint32), e)
}
func (_ fastpathT) EncMapInt8Uint32V(v map[int8]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8Uint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8Uint64V(rv2i(rv).(map[int8]uint64), e)
}
func (_ fastpathT) EncMapInt8Uint64V(v map[int8]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8UintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8UintptrV(rv2i(rv).(map[int8]uintptr), e)
}
func (_ fastpathT) EncMapInt8UintptrV(v map[int8]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[int8(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8IntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8IntV(rv2i(rv).(map[int8]int), e)
}
func (_ fastpathT) EncMapInt8IntV(v map[int8]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8Int8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8Int8V(rv2i(rv).(map[int8]int8), e)
}
func (_ fastpathT) EncMapInt8Int8V(v map[int8]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8Int16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8Int16V(rv2i(rv).(map[int8]int16), e)
}
func (_ fastpathT) EncMapInt8Int16V(v map[int8]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8Int32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8Int32V(rv2i(rv).(map[int8]int32), e)
}
func (_ fastpathT) EncMapInt8Int32V(v map[int8]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8Int64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8Int64V(rv2i(rv).(map[int8]int64), e)
}
func (_ fastpathT) EncMapInt8Int64V(v map[int8]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8Float32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8Float32V(rv2i(rv).(map[int8]float32), e)
}
func (_ fastpathT) EncMapInt8Float32V(v map[int8]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v[int8(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8Float64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8Float64V(rv2i(rv).(map[int8]float64), e)
}
func (_ fastpathT) EncMapInt8Float64V(v map[int8]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v[int8(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt8BoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt8BoolV(rv2i(rv).(map[int8]bool), e)
}
func (_ fastpathT) EncMapInt8BoolV(v map[int8]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v[int8(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16IntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16IntfV(rv2i(rv).(map[int16]interface{}), e)
}
func (_ fastpathT) EncMapInt16IntfV(v map[int16]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[int16(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16StringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16StringV(rv2i(rv).(map[int16]string), e)
}
func (_ fastpathT) EncMapInt16StringV(v map[int16]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v[int16(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16UintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16UintV(rv2i(rv).(map[int16]uint), e)
}
func (_ fastpathT) EncMapInt16UintV(v map[int16]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16Uint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16Uint8V(rv2i(rv).(map[int16]uint8), e)
}
func (_ fastpathT) EncMapInt16Uint8V(v map[int16]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16Uint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16Uint16V(rv2i(rv).(map[int16]uint16), e)
}
func (_ fastpathT) EncMapInt16Uint16V(v map[int16]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16Uint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16Uint32V(rv2i(rv).(map[int16]uint32), e)
}
func (_ fastpathT) EncMapInt16Uint32V(v map[int16]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16Uint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16Uint64V(rv2i(rv).(map[int16]uint64), e)
}
func (_ fastpathT) EncMapInt16Uint64V(v map[int16]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16UintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16UintptrV(rv2i(rv).(map[int16]uintptr), e)
}
func (_ fastpathT) EncMapInt16UintptrV(v map[int16]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[int16(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16IntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16IntV(rv2i(rv).(map[int16]int), e)
}
func (_ fastpathT) EncMapInt16IntV(v map[int16]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16Int8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16Int8V(rv2i(rv).(map[int16]int8), e)
}
func (_ fastpathT) EncMapInt16Int8V(v map[int16]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16Int16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16Int16V(rv2i(rv).(map[int16]int16), e)
}
func (_ fastpathT) EncMapInt16Int16V(v map[int16]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16Int32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16Int32V(rv2i(rv).(map[int16]int32), e)
}
func (_ fastpathT) EncMapInt16Int32V(v map[int16]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16Int64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16Int64V(rv2i(rv).(map[int16]int64), e)
}
func (_ fastpathT) EncMapInt16Int64V(v map[int16]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16Float32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16Float32V(rv2i(rv).(map[int16]float32), e)
}
func (_ fastpathT) EncMapInt16Float32V(v map[int16]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v[int16(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16Float64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16Float64V(rv2i(rv).(map[int16]float64), e)
}
func (_ fastpathT) EncMapInt16Float64V(v map[int16]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v[int16(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt16BoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt16BoolV(rv2i(rv).(map[int16]bool), e)
}
func (_ fastpathT) EncMapInt16BoolV(v map[int16]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v[int16(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32IntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32IntfV(rv2i(rv).(map[int32]interface{}), e)
}
func (_ fastpathT) EncMapInt32IntfV(v map[int32]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[int32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32StringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32StringV(rv2i(rv).(map[int32]string), e)
}
func (_ fastpathT) EncMapInt32StringV(v map[int32]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v[int32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32UintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32UintV(rv2i(rv).(map[int32]uint), e)
}
func (_ fastpathT) EncMapInt32UintV(v map[int32]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32Uint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32Uint8V(rv2i(rv).(map[int32]uint8), e)
}
func (_ fastpathT) EncMapInt32Uint8V(v map[int32]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32Uint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32Uint16V(rv2i(rv).(map[int32]uint16), e)
}
func (_ fastpathT) EncMapInt32Uint16V(v map[int32]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32Uint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32Uint32V(rv2i(rv).(map[int32]uint32), e)
}
func (_ fastpathT) EncMapInt32Uint32V(v map[int32]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32Uint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32Uint64V(rv2i(rv).(map[int32]uint64), e)
}
func (_ fastpathT) EncMapInt32Uint64V(v map[int32]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32UintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32UintptrV(rv2i(rv).(map[int32]uintptr), e)
}
func (_ fastpathT) EncMapInt32UintptrV(v map[int32]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[int32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32IntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32IntV(rv2i(rv).(map[int32]int), e)
}
func (_ fastpathT) EncMapInt32IntV(v map[int32]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32Int8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32Int8V(rv2i(rv).(map[int32]int8), e)
}
func (_ fastpathT) EncMapInt32Int8V(v map[int32]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32Int16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32Int16V(rv2i(rv).(map[int32]int16), e)
}
func (_ fastpathT) EncMapInt32Int16V(v map[int32]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32Int32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32Int32V(rv2i(rv).(map[int32]int32), e)
}
func (_ fastpathT) EncMapInt32Int32V(v map[int32]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32Int64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32Int64V(rv2i(rv).(map[int32]int64), e)
}
func (_ fastpathT) EncMapInt32Int64V(v map[int32]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32Float32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32Float32V(rv2i(rv).(map[int32]float32), e)
}
func (_ fastpathT) EncMapInt32Float32V(v map[int32]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v[int32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32Float64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32Float64V(rv2i(rv).(map[int32]float64), e)
}
func (_ fastpathT) EncMapInt32Float64V(v map[int32]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v[int32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt32BoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt32BoolV(rv2i(rv).(map[int32]bool), e)
}
func (_ fastpathT) EncMapInt32BoolV(v map[int32]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v[int32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64IntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64IntfV(rv2i(rv).(map[int64]interface{}), e)
}
func (_ fastpathT) EncMapInt64IntfV(v map[int64]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[int64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64StringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64StringV(rv2i(rv).(map[int64]string), e)
}
func (_ fastpathT) EncMapInt64StringV(v map[int64]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v[int64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64UintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64UintV(rv2i(rv).(map[int64]uint), e)
}
func (_ fastpathT) EncMapInt64UintV(v map[int64]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64Uint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64Uint8V(rv2i(rv).(map[int64]uint8), e)
}
func (_ fastpathT) EncMapInt64Uint8V(v map[int64]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64Uint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64Uint16V(rv2i(rv).(map[int64]uint16), e)
}
func (_ fastpathT) EncMapInt64Uint16V(v map[int64]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64Uint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64Uint32V(rv2i(rv).(map[int64]uint32), e)
}
func (_ fastpathT) EncMapInt64Uint32V(v map[int64]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64Uint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64Uint64V(rv2i(rv).(map[int64]uint64), e)
}
func (_ fastpathT) EncMapInt64Uint64V(v map[int64]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[int64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64UintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64UintptrV(rv2i(rv).(map[int64]uintptr), e)
}
func (_ fastpathT) EncMapInt64UintptrV(v map[int64]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[int64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64IntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64IntV(rv2i(rv).(map[int64]int), e)
}
func (_ fastpathT) EncMapInt64IntV(v map[int64]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64Int8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64Int8V(rv2i(rv).(map[int64]int8), e)
}
func (_ fastpathT) EncMapInt64Int8V(v map[int64]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64Int16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64Int16V(rv2i(rv).(map[int64]int16), e)
}
func (_ fastpathT) EncMapInt64Int16V(v map[int64]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64Int32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64Int32V(rv2i(rv).(map[int64]int32), e)
}
func (_ fastpathT) EncMapInt64Int32V(v map[int64]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64Int64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64Int64V(rv2i(rv).(map[int64]int64), e)
}
func (_ fastpathT) EncMapInt64Int64V(v map[int64]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[int64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64Float32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64Float32V(rv2i(rv).(map[int64]float32), e)
}
func (_ fastpathT) EncMapInt64Float32V(v map[int64]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v[int64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64Float64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64Float64V(rv2i(rv).(map[int64]float64), e)
}
func (_ fastpathT) EncMapInt64Float64V(v map[int64]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v[int64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapInt64BoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapInt64BoolV(rv2i(rv).(map[int64]bool), e)
}
func (_ fastpathT) EncMapInt64BoolV(v map[int64]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]int64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = int64(k)
			i++
		}
		sort.Sort(intSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(int64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v[int64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeInt(int64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolIntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolIntfV(rv2i(rv).(map[bool]interface{}), e)
}
func (_ fastpathT) EncMapBoolIntfV(v map[bool]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[bool(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolStringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolStringV(rv2i(rv).(map[bool]string), e)
}
func (_ fastpathT) EncMapBoolStringV(v map[bool]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v[bool(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolUintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolUintV(rv2i(rv).(map[bool]uint), e)
}
func (_ fastpathT) EncMapBoolUintV(v map[bool]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[bool(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolUint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolUint8V(rv2i(rv).(map[bool]uint8), e)
}
func (_ fastpathT) EncMapBoolUint8V(v map[bool]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[bool(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolUint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolUint16V(rv2i(rv).(map[bool]uint16), e)
}
func (_ fastpathT) EncMapBoolUint16V(v map[bool]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[bool(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolUint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolUint32V(rv2i(rv).(map[bool]uint32), e)
}
func (_ fastpathT) EncMapBoolUint32V(v map[bool]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[bool(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolUint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolUint64V(rv2i(rv).(map[bool]uint64), e)
}
func (_ fastpathT) EncMapBoolUint64V(v map[bool]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[bool(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolUintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolUintptrV(rv2i(rv).(map[bool]uintptr), e)
}
func (_ fastpathT) EncMapBoolUintptrV(v map[bool]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[bool(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolIntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolIntV(rv2i(rv).(map[bool]int), e)
}
func (_ fastpathT) EncMapBoolIntV(v map[bool]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[bool(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolInt8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolInt8V(rv2i(rv).(map[bool]int8), e)
}
func (_ fastpathT) EncMapBoolInt8V(v map[bool]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[bool(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolInt16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolInt16V(rv2i(rv).(map[bool]int16), e)
}
func (_ fastpathT) EncMapBoolInt16V(v map[bool]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[bool(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolInt32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolInt32V(rv2i(rv).(map[bool]int32), e)
}
func (_ fastpathT) EncMapBoolInt32V(v map[bool]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[bool(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolInt64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolInt64V(rv2i(rv).(map[bool]int64), e)
}
func (_ fastpathT) EncMapBoolInt64V(v map[bool]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[bool(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolFloat32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolFloat32V(rv2i(rv).(map[bool]float32), e)
}
func (_ fastpathT) EncMapBoolFloat32V(v map[bool]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v[bool(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolFloat64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolFloat64V(rv2i(rv).(map[bool]float64), e)
}
func (_ fastpathT) EncMapBoolFloat64V(v map[bool]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v[bool(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapBoolBoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapBoolBoolV(rv2i(rv).(map[bool]bool), e)
}
func (_ fastpathT) EncMapBoolBoolV(v map[bool]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]bool, len(v))
		var i int
		for k, _ := range v {
			v2[i] = bool(k)
			i++
		}
		sort.Sort(boolSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(bool(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v[bool(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeBool(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

// -- decode

// -- -- fast path type switch
func fastpathDecodeTypeSwitch(iv interface{}, d *Decoder) bool {
	switch v := iv.(type) {

	case []interface{}:
		fastpathTV.DecSliceIntfV(v, false, d)
	case *[]interface{}:
		if v2, changed2 := fastpathTV.DecSliceIntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]interface{}:
		fastpathTV.DecMapIntfIntfV(v, false, d)
	case *map[interface{}]interface{}:
		if v2, changed2 := fastpathTV.DecMapIntfIntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]string:
		fastpathTV.DecMapIntfStringV(v, false, d)
	case *map[interface{}]string:
		if v2, changed2 := fastpathTV.DecMapIntfStringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]uint:
		fastpathTV.DecMapIntfUintV(v, false, d)
	case *map[interface{}]uint:
		if v2, changed2 := fastpathTV.DecMapIntfUintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]uint8:
		fastpathTV.DecMapIntfUint8V(v, false, d)
	case *map[interface{}]uint8:
		if v2, changed2 := fastpathTV.DecMapIntfUint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]uint16:
		fastpathTV.DecMapIntfUint16V(v, false, d)
	case *map[interface{}]uint16:
		if v2, changed2 := fastpathTV.DecMapIntfUint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]uint32:
		fastpathTV.DecMapIntfUint32V(v, false, d)
	case *map[interface{}]uint32:
		if v2, changed2 := fastpathTV.DecMapIntfUint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]uint64:
		fastpathTV.DecMapIntfUint64V(v, false, d)
	case *map[interface{}]uint64:
		if v2, changed2 := fastpathTV.DecMapIntfUint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]uintptr:
		fastpathTV.DecMapIntfUintptrV(v, false, d)
	case *map[interface{}]uintptr:
		if v2, changed2 := fastpathTV.DecMapIntfUintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]int:
		fastpathTV.DecMapIntfIntV(v, false, d)
	case *map[interface{}]int:
		if v2, changed2 := fastpathTV.DecMapIntfIntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]int8:
		fastpathTV.DecMapIntfInt8V(v, false, d)
	case *map[interface{}]int8:
		if v2, changed2 := fastpathTV.DecMapIntfInt8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]int16:
		fastpathTV.DecMapIntfInt16V(v, false, d)
	case *map[interface{}]int16:
		if v2, changed2 := fastpathTV.DecMapIntfInt16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]int32:
		fastpathTV.DecMapIntfInt32V(v, false, d)
	case *map[interface{}]int32:
		if v2, changed2 := fastpathTV.DecMapIntfInt32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]int64:
		fastpathTV.DecMapIntfInt64V(v, false, d)
	case *map[interface{}]int64:
		if v2, changed2 := fastpathTV.DecMapIntfInt64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]float32:
		fastpathTV.DecMapIntfFloat32V(v, false, d)
	case *map[interface{}]float32:
		if v2, changed2 := fastpathTV.DecMapIntfFloat32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]float64:
		fastpathTV.DecMapIntfFloat64V(v, false, d)
	case *map[interface{}]float64:
		if v2, changed2 := fastpathTV.DecMapIntfFloat64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[interface{}]bool:
		fastpathTV.DecMapIntfBoolV(v, false, d)
	case *map[interface{}]bool:
		if v2, changed2 := fastpathTV.DecMapIntfBoolV(*v, true, d); changed2 {
			*v = v2
		}

	case []string:
		fastpathTV.DecSliceStringV(v, false, d)
	case *[]string:
		if v2, changed2 := fastpathTV.DecSliceStringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]interface{}:
		fastpathTV.DecMapStringIntfV(v, false, d)
	case *map[string]interface{}:
		if v2, changed2 := fastpathTV.DecMapStringIntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]string:
		fastpathTV.DecMapStringStringV(v, false, d)
	case *map[string]string:
		if v2, changed2 := fastpathTV.DecMapStringStringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]uint:
		fastpathTV.DecMapStringUintV(v, false, d)
	case *map[string]uint:
		if v2, changed2 := fastpathTV.DecMapStringUintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]uint8:
		fastpathTV.DecMapStringUint8V(v, false, d)
	case *map[string]uint8:
		if v2, changed2 := fastpathTV.DecMapStringUint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]uint16:
		fastpathTV.DecMapStringUint16V(v, false, d)
	case *map[string]uint16:
		if v2, changed2 := fastpathTV.DecMapStringUint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]uint32:
		fastpathTV.DecMapStringUint32V(v, false, d)
	case *map[string]uint32:
		if v2, changed2 := fastpathTV.DecMapStringUint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]uint64:
		fastpathTV.DecMapStringUint64V(v, false, d)
	case *map[string]uint64:
		if v2, changed2 := fastpathTV.DecMapStringUint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]uintptr:
		fastpathTV.DecMapStringUintptrV(v, false, d)
	case *map[string]uintptr:
		if v2, changed2 := fastpathTV.DecMapStringUintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]int:
		fastpathTV.DecMapStringIntV(v, false, d)
	case *map[string]int:
		if v2, changed2 := fastpathTV.DecMapStringIntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]int8:
		fastpathTV.DecMapStringInt8V(v, false, d)
	case *map[string]int8:
		if v2, changed2 := fastpathTV.DecMapStringInt8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]int16:
		fastpathTV.DecMapStringInt16V(v, false, d)
	case *map[string]int16:
		if v2, changed2 := fastpathTV.DecMapStringInt16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]int32:
		fastpathTV.DecMapStringInt32V(v, false, d)
	case *map[string]int32:
		if v2, changed2 := fastpathTV.DecMapStringInt32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]int64:
		fastpathTV.DecMapStringInt64V(v, false, d)
	case *map[string]int64:
		if v2, changed2 := fastpathTV.DecMapStringInt64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]float32:
		fastpathTV.DecMapStringFloat32V(v, false, d)
	case *map[string]float32:
		if v2, changed2 := fastpathTV.DecMapStringFloat32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]float64:
		fastpathTV.DecMapStringFloat64V(v, false, d)
	case *map[string]float64:
		if v2, changed2 := fastpathTV.DecMapStringFloat64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[string]bool:
		fastpathTV.DecMapStringBoolV(v, false, d)
	case *map[string]bool:
		if v2, changed2 := fastpathTV.DecMapStringBoolV(*v, true, d); changed2 {
			*v = v2
		}

	case []float32:
		fastpathTV.DecSliceFloat32V(v, false, d)
	case *[]float32:
		if v2, changed2 := fastpathTV.DecSliceFloat32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]interface{}:
		fastpathTV.DecMapFloat32IntfV(v, false, d)
	case *map[float32]interface{}:
		if v2, changed2 := fastpathTV.DecMapFloat32IntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]string:
		fastpathTV.DecMapFloat32StringV(v, false, d)
	case *map[float32]string:
		if v2, changed2 := fastpathTV.DecMapFloat32StringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]uint:
		fastpathTV.DecMapFloat32UintV(v, false, d)
	case *map[float32]uint:
		if v2, changed2 := fastpathTV.DecMapFloat32UintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]uint8:
		fastpathTV.DecMapFloat32Uint8V(v, false, d)
	case *map[float32]uint8:
		if v2, changed2 := fastpathTV.DecMapFloat32Uint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]uint16:
		fastpathTV.DecMapFloat32Uint16V(v, false, d)
	case *map[float32]uint16:
		if v2, changed2 := fastpathTV.DecMapFloat32Uint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]uint32:
		fastpathTV.DecMapFloat32Uint32V(v, false, d)
	case *map[float32]uint32:
		if v2, changed2 := fastpathTV.DecMapFloat32Uint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]uint64:
		fastpathTV.DecMapFloat32Uint64V(v, false, d)
	case *map[float32]uint64:
		if v2, changed2 := fastpathTV.DecMapFloat32Uint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]uintptr:
		fastpathTV.DecMapFloat32UintptrV(v, false, d)
	case *map[float32]uintptr:
		if v2, changed2 := fastpathTV.DecMapFloat32UintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]int:
		fastpathTV.DecMapFloat32IntV(v, false, d)
	case *map[float32]int:
		if v2, changed2 := fastpathTV.DecMapFloat32IntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]int8:
		fastpathTV.DecMapFloat32Int8V(v, false, d)
	case *map[float32]int8:
		if v2, changed2 := fastpathTV.DecMapFloat32Int8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]int16:
		fastpathTV.DecMapFloat32Int16V(v, false, d)
	case *map[float32]int16:
		if v2, changed2 := fastpathTV.DecMapFloat32Int16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]int32:
		fastpathTV.DecMapFloat32Int32V(v, false, d)
	case *map[float32]int32:
		if v2, changed2 := fastpathTV.DecMapFloat32Int32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]int64:
		fastpathTV.DecMapFloat32Int64V(v, false, d)
	case *map[float32]int64:
		if v2, changed2 := fastpathTV.DecMapFloat32Int64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]float32:
		fastpathTV.DecMapFloat32Float32V(v, false, d)
	case *map[float32]float32:
		if v2, changed2 := fastpathTV.DecMapFloat32Float32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]float64:
		fastpathTV.DecMapFloat32Float64V(v, false, d)
	case *map[float32]float64:
		if v2, changed2 := fastpathTV.DecMapFloat32Float64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float32]bool:
		fastpathTV.DecMapFloat32BoolV(v, false, d)
	case *map[float32]bool:
		if v2, changed2 := fastpathTV.DecMapFloat32BoolV(*v, true, d); changed2 {
			*v = v2
		}

	case []float64:
		fastpathTV.DecSliceFloat64V(v, false, d)
	case *[]float64:
		if v2, changed2 := fastpathTV.DecSliceFloat64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]interface{}:
		fastpathTV.DecMapFloat64IntfV(v, false, d)
	case *map[float64]interface{}:
		if v2, changed2 := fastpathTV.DecMapFloat64IntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]string:
		fastpathTV.DecMapFloat64StringV(v, false, d)
	case *map[float64]string:
		if v2, changed2 := fastpathTV.DecMapFloat64StringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]uint:
		fastpathTV.DecMapFloat64UintV(v, false, d)
	case *map[float64]uint:
		if v2, changed2 := fastpathTV.DecMapFloat64UintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]uint8:
		fastpathTV.DecMapFloat64Uint8V(v, false, d)
	case *map[float64]uint8:
		if v2, changed2 := fastpathTV.DecMapFloat64Uint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]uint16:
		fastpathTV.DecMapFloat64Uint16V(v, false, d)
	case *map[float64]uint16:
		if v2, changed2 := fastpathTV.DecMapFloat64Uint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]uint32:
		fastpathTV.DecMapFloat64Uint32V(v, false, d)
	case *map[float64]uint32:
		if v2, changed2 := fastpathTV.DecMapFloat64Uint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]uint64:
		fastpathTV.DecMapFloat64Uint64V(v, false, d)
	case *map[float64]uint64:
		if v2, changed2 := fastpathTV.DecMapFloat64Uint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]uintptr:
		fastpathTV.DecMapFloat64UintptrV(v, false, d)
	case *map[float64]uintptr:
		if v2, changed2 := fastpathTV.DecMapFloat64UintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]int:
		fastpathTV.DecMapFloat64IntV(v, false, d)
	case *map[float64]int:
		if v2, changed2 := fastpathTV.DecMapFloat64IntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]int8:
		fastpathTV.DecMapFloat64Int8V(v, false, d)
	case *map[float64]int8:
		if v2, changed2 := fastpathTV.DecMapFloat64Int8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]int16:
		fastpathTV.DecMapFloat64Int16V(v, false, d)
	case *map[float64]int16:
		if v2, changed2 := fastpathTV.DecMapFloat64Int16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]int32:
		fastpathTV.DecMapFloat64Int32V(v, false, d)
	case *map[float64]int32:
		if v2, changed2 := fastpathTV.DecMapFloat64Int32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]int64:
		fastpathTV.DecMapFloat64Int64V(v, false, d)
	case *map[float64]int64:
		if v2, changed2 := fastpathTV.DecMapFloat64Int64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]float32:
		fastpathTV.DecMapFloat64Float32V(v, false, d)
	case *map[float64]float32:
		if v2, changed2 := fastpathTV.DecMapFloat64Float32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]float64:
		fastpathTV.DecMapFloat64Float64V(v, false, d)
	case *map[float64]float64:
		if v2, changed2 := fastpathTV.DecMapFloat64Float64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[float64]bool:
		fastpathTV.DecMapFloat64BoolV(v, false, d)
	case *map[float64]bool:
		if v2, changed2 := fastpathTV.DecMapFloat64BoolV(*v, true, d); changed2 {
			*v = v2
		}

	case []uint:
		fastpathTV.DecSliceUintV(v, false, d)
	case *[]uint:
		if v2, changed2 := fastpathTV.DecSliceUintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]interface{}:
		fastpathTV.DecMapUintIntfV(v, false, d)
	case *map[uint]interface{}:
		if v2, changed2 := fastpathTV.DecMapUintIntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]string:
		fastpathTV.DecMapUintStringV(v, false, d)
	case *map[uint]string:
		if v2, changed2 := fastpathTV.DecMapUintStringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]uint:
		fastpathTV.DecMapUintUintV(v, false, d)
	case *map[uint]uint:
		if v2, changed2 := fastpathTV.DecMapUintUintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]uint8:
		fastpathTV.DecMapUintUint8V(v, false, d)
	case *map[uint]uint8:
		if v2, changed2 := fastpathTV.DecMapUintUint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]uint16:
		fastpathTV.DecMapUintUint16V(v, false, d)
	case *map[uint]uint16:
		if v2, changed2 := fastpathTV.DecMapUintUint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]uint32:
		fastpathTV.DecMapUintUint32V(v, false, d)
	case *map[uint]uint32:
		if v2, changed2 := fastpathTV.DecMapUintUint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]uint64:
		fastpathTV.DecMapUintUint64V(v, false, d)
	case *map[uint]uint64:
		if v2, changed2 := fastpathTV.DecMapUintUint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]uintptr:
		fastpathTV.DecMapUintUintptrV(v, false, d)
	case *map[uint]uintptr:
		if v2, changed2 := fastpathTV.DecMapUintUintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]int:
		fastpathTV.DecMapUintIntV(v, false, d)
	case *map[uint]int:
		if v2, changed2 := fastpathTV.DecMapUintIntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]int8:
		fastpathTV.DecMapUintInt8V(v, false, d)
	case *map[uint]int8:
		if v2, changed2 := fastpathTV.DecMapUintInt8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]int16:
		fastpathTV.DecMapUintInt16V(v, false, d)
	case *map[uint]int16:
		if v2, changed2 := fastpathTV.DecMapUintInt16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]int32:
		fastpathTV.DecMapUintInt32V(v, false, d)
	case *map[uint]int32:
		if v2, changed2 := fastpathTV.DecMapUintInt32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]int64:
		fastpathTV.DecMapUintInt64V(v, false, d)
	case *map[uint]int64:
		if v2, changed2 := fastpathTV.DecMapUintInt64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]float32:
		fastpathTV.DecMapUintFloat32V(v, false, d)
	case *map[uint]float32:
		if v2, changed2 := fastpathTV.DecMapUintFloat32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]float64:
		fastpathTV.DecMapUintFloat64V(v, false, d)
	case *map[uint]float64:
		if v2, changed2 := fastpathTV.DecMapUintFloat64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint]bool:
		fastpathTV.DecMapUintBoolV(v, false, d)
	case *map[uint]bool:
		if v2, changed2 := fastpathTV.DecMapUintBoolV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]interface{}:
		fastpathTV.DecMapUint8IntfV(v, false, d)
	case *map[uint8]interface{}:
		if v2, changed2 := fastpathTV.DecMapUint8IntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]string:
		fastpathTV.DecMapUint8StringV(v, false, d)
	case *map[uint8]string:
		if v2, changed2 := fastpathTV.DecMapUint8StringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]uint:
		fastpathTV.DecMapUint8UintV(v, false, d)
	case *map[uint8]uint:
		if v2, changed2 := fastpathTV.DecMapUint8UintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]uint8:
		fastpathTV.DecMapUint8Uint8V(v, false, d)
	case *map[uint8]uint8:
		if v2, changed2 := fastpathTV.DecMapUint8Uint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]uint16:
		fastpathTV.DecMapUint8Uint16V(v, false, d)
	case *map[uint8]uint16:
		if v2, changed2 := fastpathTV.DecMapUint8Uint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]uint32:
		fastpathTV.DecMapUint8Uint32V(v, false, d)
	case *map[uint8]uint32:
		if v2, changed2 := fastpathTV.DecMapUint8Uint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]uint64:
		fastpathTV.DecMapUint8Uint64V(v, false, d)
	case *map[uint8]uint64:
		if v2, changed2 := fastpathTV.DecMapUint8Uint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]uintptr:
		fastpathTV.DecMapUint8UintptrV(v, false, d)
	case *map[uint8]uintptr:
		if v2, changed2 := fastpathTV.DecMapUint8UintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]int:
		fastpathTV.DecMapUint8IntV(v, false, d)
	case *map[uint8]int:
		if v2, changed2 := fastpathTV.DecMapUint8IntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]int8:
		fastpathTV.DecMapUint8Int8V(v, false, d)
	case *map[uint8]int8:
		if v2, changed2 := fastpathTV.DecMapUint8Int8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]int16:
		fastpathTV.DecMapUint8Int16V(v, false, d)
	case *map[uint8]int16:
		if v2, changed2 := fastpathTV.DecMapUint8Int16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]int32:
		fastpathTV.DecMapUint8Int32V(v, false, d)
	case *map[uint8]int32:
		if v2, changed2 := fastpathTV.DecMapUint8Int32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]int64:
		fastpathTV.DecMapUint8Int64V(v, false, d)
	case *map[uint8]int64:
		if v2, changed2 := fastpathTV.DecMapUint8Int64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]float32:
		fastpathTV.DecMapUint8Float32V(v, false, d)
	case *map[uint8]float32:
		if v2, changed2 := fastpathTV.DecMapUint8Float32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]float64:
		fastpathTV.DecMapUint8Float64V(v, false, d)
	case *map[uint8]float64:
		if v2, changed2 := fastpathTV.DecMapUint8Float64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint8]bool:
		fastpathTV.DecMapUint8BoolV(v, false, d)
	case *map[uint8]bool:
		if v2, changed2 := fastpathTV.DecMapUint8BoolV(*v, true, d); changed2 {
			*v = v2
		}

	case []uint16:
		fastpathTV.DecSliceUint16V(v, false, d)
	case *[]uint16:
		if v2, changed2 := fastpathTV.DecSliceUint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]interface{}:
		fastpathTV.DecMapUint16IntfV(v, false, d)
	case *map[uint16]interface{}:
		if v2, changed2 := fastpathTV.DecMapUint16IntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]string:
		fastpathTV.DecMapUint16StringV(v, false, d)
	case *map[uint16]string:
		if v2, changed2 := fastpathTV.DecMapUint16StringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]uint:
		fastpathTV.DecMapUint16UintV(v, false, d)
	case *map[uint16]uint:
		if v2, changed2 := fastpathTV.DecMapUint16UintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]uint8:
		fastpathTV.DecMapUint16Uint8V(v, false, d)
	case *map[uint16]uint8:
		if v2, changed2 := fastpathTV.DecMapUint16Uint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]uint16:
		fastpathTV.DecMapUint16Uint16V(v, false, d)
	case *map[uint16]uint16:
		if v2, changed2 := fastpathTV.DecMapUint16Uint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]uint32:
		fastpathTV.DecMapUint16Uint32V(v, false, d)
	case *map[uint16]uint32:
		if v2, changed2 := fastpathTV.DecMapUint16Uint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]uint64:
		fastpathTV.DecMapUint16Uint64V(v, false, d)
	case *map[uint16]uint64:
		if v2, changed2 := fastpathTV.DecMapUint16Uint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]uintptr:
		fastpathTV.DecMapUint16UintptrV(v, false, d)
	case *map[uint16]uintptr:
		if v2, changed2 := fastpathTV.DecMapUint16UintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]int:
		fastpathTV.DecMapUint16IntV(v, false, d)
	case *map[uint16]int:
		if v2, changed2 := fastpathTV.DecMapUint16IntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]int8:
		fastpathTV.DecMapUint16Int8V(v, false, d)
	case *map[uint16]int8:
		if v2, changed2 := fastpathTV.DecMapUint16Int8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]int16:
		fastpathTV.DecMapUint16Int16V(v, false, d)
	case *map[uint16]int16:
		if v2, changed2 := fastpathTV.DecMapUint16Int16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]int32:
		fastpathTV.DecMapUint16Int32V(v, false, d)
	case *map[uint16]int32:
		if v2, changed2 := fastpathTV.DecMapUint16Int32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]int64:
		fastpathTV.DecMapUint16Int64V(v, false, d)
	case *map[uint16]int64:
		if v2, changed2 := fastpathTV.DecMapUint16Int64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]float32:
		fastpathTV.DecMapUint16Float32V(v, false, d)
	case *map[uint16]float32:
		if v2, changed2 := fastpathTV.DecMapUint16Float32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]float64:
		fastpathTV.DecMapUint16Float64V(v, false, d)
	case *map[uint16]float64:
		if v2, changed2 := fastpathTV.DecMapUint16Float64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint16]bool:
		fastpathTV.DecMapUint16BoolV(v, false, d)
	case *map[uint16]bool:
		if v2, changed2 := fastpathTV.DecMapUint16BoolV(*v, true, d); changed2 {
			*v = v2
		}

	case []uint32:
		fastpathTV.DecSliceUint32V(v, false, d)
	case *[]uint32:
		if v2, changed2 := fastpathTV.DecSliceUint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]interface{}:
		fastpathTV.DecMapUint32IntfV(v, false, d)
	case *map[uint32]interface{}:
		if v2, changed2 := fastpathTV.DecMapUint32IntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]string:
		fastpathTV.DecMapUint32StringV(v, false, d)
	case *map[uint32]string:
		if v2, changed2 := fastpathTV.DecMapUint32StringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]uint:
		fastpathTV.DecMapUint32UintV(v, false, d)
	case *map[uint32]uint:
		if v2, changed2 := fastpathTV.DecMapUint32UintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]uint8:
		fastpathTV.DecMapUint32Uint8V(v, false, d)
	case *map[uint32]uint8:
		if v2, changed2 := fastpathTV.DecMapUint32Uint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]uint16:
		fastpathTV.DecMapUint32Uint16V(v, false, d)
	case *map[uint32]uint16:
		if v2, changed2 := fastpathTV.DecMapUint32Uint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]uint32:
		fastpathTV.DecMapUint32Uint32V(v, false, d)
	case *map[uint32]uint32:
		if v2, changed2 := fastpathTV.DecMapUint32Uint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]uint64:
		fastpathTV.DecMapUint32Uint64V(v, false, d)
	case *map[uint32]uint64:
		if v2, changed2 := fastpathTV.DecMapUint32Uint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]uintptr:
		fastpathTV.DecMapUint32UintptrV(v, false, d)
	case *map[uint32]uintptr:
		if v2, changed2 := fastpathTV.DecMapUint32UintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]int:
		fastpathTV.DecMapUint32IntV(v, false, d)
	case *map[uint32]int:
		if v2, changed2 := fastpathTV.DecMapUint32IntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]int8:
		fastpathTV.DecMapUint32Int8V(v, false, d)
	case *map[uint32]int8:
		if v2, changed2 := fastpathTV.DecMapUint32Int8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]int16:
		fastpathTV.DecMapUint32Int16V(v, false, d)
	case *map[uint32]int16:
		if v2, changed2 := fastpathTV.DecMapUint32Int16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]int32:
		fastpathTV.DecMapUint32Int32V(v, false, d)
	case *map[uint32]int32:
		if v2, changed2 := fastpathTV.DecMapUint32Int32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]int64:
		fastpathTV.DecMapUint32Int64V(v, false, d)
	case *map[uint32]int64:
		if v2, changed2 := fastpathTV.DecMapUint32Int64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]float32:
		fastpathTV.DecMapUint32Float32V(v, false, d)
	case *map[uint32]float32:
		if v2, changed2 := fastpathTV.DecMapUint32Float32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]float64:
		fastpathTV.DecMapUint32Float64V(v, false, d)
	case *map[uint32]float64:
		if v2, changed2 := fastpathTV.DecMapUint32Float64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint32]bool:
		fastpathTV.DecMapUint32BoolV(v, false, d)
	case *map[uint32]bool:
		if v2, changed2 := fastpathTV.DecMapUint32BoolV(*v, true, d); changed2 {
			*v = v2
		}

	case []uint64:
		fastpathTV.DecSliceUint64V(v, false, d)
	case *[]uint64:
		if v2, changed2 := fastpathTV.DecSliceUint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]interface{}:
		fastpathTV.DecMapUint64IntfV(v, false, d)
	case *map[uint64]interface{}:
		if v2, changed2 := fastpathTV.DecMapUint64IntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]string:
		fastpathTV.DecMapUint64StringV(v, false, d)
	case *map[uint64]string:
		if v2, changed2 := fastpathTV.DecMapUint64StringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]uint:
		fastpathTV.DecMapUint64UintV(v, false, d)
	case *map[uint64]uint:
		if v2, changed2 := fastpathTV.DecMapUint64UintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]uint8:
		fastpathTV.DecMapUint64Uint8V(v, false, d)
	case *map[uint64]uint8:
		if v2, changed2 := fastpathTV.DecMapUint64Uint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]uint16:
		fastpathTV.DecMapUint64Uint16V(v, false, d)
	case *map[uint64]uint16:
		if v2, changed2 := fastpathTV.DecMapUint64Uint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]uint32:
		fastpathTV.DecMapUint64Uint32V(v, false, d)
	case *map[uint64]uint32:
		if v2, changed2 := fastpathTV.DecMapUint64Uint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]uint64:
		fastpathTV.DecMapUint64Uint64V(v, false, d)
	case *map[uint64]uint64:
		if v2, changed2 := fastpathTV.DecMapUint64Uint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]uintptr:
		fastpathTV.DecMapUint64UintptrV(v, false, d)
	case *map[uint64]uintptr:
		if v2, changed2 := fastpathTV.DecMapUint64UintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]int:
		fastpathTV.DecMapUint64IntV(v, false, d)
	case *map[uint64]int:
		if v2, changed2 := fastpathTV.DecMapUint64IntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]int8:
		fastpathTV.DecMapUint64Int8V(v, false, d)
	case *map[uint64]int8:
		if v2, changed2 := fastpathTV.DecMapUint64Int8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]int16:
		fastpathTV.DecMapUint64Int16V(v, false, d)
	case *map[uint64]int16:
		if v2, changed2 := fastpathTV.DecMapUint64Int16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]int32:
		fastpathTV.DecMapUint64Int32V(v, false, d)
	case *map[uint64]int32:
		if v2, changed2 := fastpathTV.DecMapUint64Int32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]int64:
		fastpathTV.DecMapUint64Int64V(v, false, d)
	case *map[uint64]int64:
		if v2, changed2 := fastpathTV.DecMapUint64Int64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]float32:
		fastpathTV.DecMapUint64Float32V(v, false, d)
	case *map[uint64]float32:
		if v2, changed2 := fastpathTV.DecMapUint64Float32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]float64:
		fastpathTV.DecMapUint64Float64V(v, false, d)
	case *map[uint64]float64:
		if v2, changed2 := fastpathTV.DecMapUint64Float64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uint64]bool:
		fastpathTV.DecMapUint64BoolV(v, false, d)
	case *map[uint64]bool:
		if v2, changed2 := fastpathTV.DecMapUint64BoolV(*v, true, d); changed2 {
			*v = v2
		}

	case []uintptr:
		fastpathTV.DecSliceUintptrV(v, false, d)
	case *[]uintptr:
		if v2, changed2 := fastpathTV.DecSliceUintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]interface{}:
		fastpathTV.DecMapUintptrIntfV(v, false, d)
	case *map[uintptr]interface{}:
		if v2, changed2 := fastpathTV.DecMapUintptrIntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]string:
		fastpathTV.DecMapUintptrStringV(v, false, d)
	case *map[uintptr]string:
		if v2, changed2 := fastpathTV.DecMapUintptrStringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]uint:
		fastpathTV.DecMapUintptrUintV(v, false, d)
	case *map[uintptr]uint:
		if v2, changed2 := fastpathTV.DecMapUintptrUintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]uint8:
		fastpathTV.DecMapUintptrUint8V(v, false, d)
	case *map[uintptr]uint8:
		if v2, changed2 := fastpathTV.DecMapUintptrUint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]uint16:
		fastpathTV.DecMapUintptrUint16V(v, false, d)
	case *map[uintptr]uint16:
		if v2, changed2 := fastpathTV.DecMapUintptrUint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]uint32:
		fastpathTV.DecMapUintptrUint32V(v, false, d)
	case *map[uintptr]uint32:
		if v2, changed2 := fastpathTV.DecMapUintptrUint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]uint64:
		fastpathTV.DecMapUintptrUint64V(v, false, d)
	case *map[uintptr]uint64:
		if v2, changed2 := fastpathTV.DecMapUintptrUint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]uintptr:
		fastpathTV.DecMapUintptrUintptrV(v, false, d)
	case *map[uintptr]uintptr:
		if v2, changed2 := fastpathTV.DecMapUintptrUintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]int:
		fastpathTV.DecMapUintptrIntV(v, false, d)
	case *map[uintptr]int:
		if v2, changed2 := fastpathTV.DecMapUintptrIntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]int8:
		fastpathTV.DecMapUintptrInt8V(v, false, d)
	case *map[uintptr]int8:
		if v2, changed2 := fastpathTV.DecMapUintptrInt8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]int16:
		fastpathTV.DecMapUintptrInt16V(v, false, d)
	case *map[uintptr]int16:
		if v2, changed2 := fastpathTV.DecMapUintptrInt16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]int32:
		fastpathTV.DecMapUintptrInt32V(v, false, d)
	case *map[uintptr]int32:
		if v2, changed2 := fastpathTV.DecMapUintptrInt32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]int64:
		fastpathTV.DecMapUintptrInt64V(v, false, d)
	case *map[uintptr]int64:
		if v2, changed2 := fastpathTV.DecMapUintptrInt64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]float32:
		fastpathTV.DecMapUintptrFloat32V(v, false, d)
	case *map[uintptr]float32:
		if v2, changed2 := fastpathTV.DecMapUintptrFloat32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]float64:
		fastpathTV.DecMapUintptrFloat64V(v, false, d)
	case *map[uintptr]float64:
		if v2, changed2 := fastpathTV.DecMapUintptrFloat64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[uintptr]bool:
		fastpathTV.DecMapUintptrBoolV(v, false, d)
	case *map[uintptr]bool:
		if v2, changed2 := fastpathTV.DecMapUintptrBoolV(*v, true, d); changed2 {
			*v = v2
		}

	case []int:
		fastpathTV.DecSliceIntV(v, false, d)
	case *[]int:
		if v2, changed2 := fastpathTV.DecSliceIntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]interface{}:
		fastpathTV.DecMapIntIntfV(v, false, d)
	case *map[int]interface{}:
		if v2, changed2 := fastpathTV.DecMapIntIntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]string:
		fastpathTV.DecMapIntStringV(v, false, d)
	case *map[int]string:
		if v2, changed2 := fastpathTV.DecMapIntStringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]uint:
		fastpathTV.DecMapIntUintV(v, false, d)
	case *map[int]uint:
		if v2, changed2 := fastpathTV.DecMapIntUintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]uint8:
		fastpathTV.DecMapIntUint8V(v, false, d)
	case *map[int]uint8:
		if v2, changed2 := fastpathTV.DecMapIntUint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]uint16:
		fastpathTV.DecMapIntUint16V(v, false, d)
	case *map[int]uint16:
		if v2, changed2 := fastpathTV.DecMapIntUint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]uint32:
		fastpathTV.DecMapIntUint32V(v, false, d)
	case *map[int]uint32:
		if v2, changed2 := fastpathTV.DecMapIntUint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]uint64:
		fastpathTV.DecMapIntUint64V(v, false, d)
	case *map[int]uint64:
		if v2, changed2 := fastpathTV.DecMapIntUint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]uintptr:
		fastpathTV.DecMapIntUintptrV(v, false, d)
	case *map[int]uintptr:
		if v2, changed2 := fastpathTV.DecMapIntUintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]int:
		fastpathTV.DecMapIntIntV(v, false, d)
	case *map[int]int:
		if v2, changed2 := fastpathTV.DecMapIntIntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]int8:
		fastpathTV.DecMapIntInt8V(v, false, d)
	case *map[int]int8:
		if v2, changed2 := fastpathTV.DecMapIntInt8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]int16:
		fastpathTV.DecMapIntInt16V(v, false, d)
	case *map[int]int16:
		if v2, changed2 := fastpathTV.DecMapIntInt16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]int32:
		fastpathTV.DecMapIntInt32V(v, false, d)
	case *map[int]int32:
		if v2, changed2 := fastpathTV.DecMapIntInt32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]int64:
		fastpathTV.DecMapIntInt64V(v, false, d)
	case *map[int]int64:
		if v2, changed2 := fastpathTV.DecMapIntInt64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]float32:
		fastpathTV.DecMapIntFloat32V(v, false, d)
	case *map[int]float32:
		if v2, changed2 := fastpathTV.DecMapIntFloat32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]float64:
		fastpathTV.DecMapIntFloat64V(v, false, d)
	case *map[int]float64:
		if v2, changed2 := fastpathTV.DecMapIntFloat64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int]bool:
		fastpathTV.DecMapIntBoolV(v, false, d)
	case *map[int]bool:
		if v2, changed2 := fastpathTV.DecMapIntBoolV(*v, true, d); changed2 {
			*v = v2
		}

	case []int8:
		fastpathTV.DecSliceInt8V(v, false, d)
	case *[]int8:
		if v2, changed2 := fastpathTV.DecSliceInt8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]interface{}:
		fastpathTV.DecMapInt8IntfV(v, false, d)
	case *map[int8]interface{}:
		if v2, changed2 := fastpathTV.DecMapInt8IntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]string:
		fastpathTV.DecMapInt8StringV(v, false, d)
	case *map[int8]string:
		if v2, changed2 := fastpathTV.DecMapInt8StringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]uint:
		fastpathTV.DecMapInt8UintV(v, false, d)
	case *map[int8]uint:
		if v2, changed2 := fastpathTV.DecMapInt8UintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]uint8:
		fastpathTV.DecMapInt8Uint8V(v, false, d)
	case *map[int8]uint8:
		if v2, changed2 := fastpathTV.DecMapInt8Uint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]uint16:
		fastpathTV.DecMapInt8Uint16V(v, false, d)
	case *map[int8]uint16:
		if v2, changed2 := fastpathTV.DecMapInt8Uint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]uint32:
		fastpathTV.DecMapInt8Uint32V(v, false, d)
	case *map[int8]uint32:
		if v2, changed2 := fastpathTV.DecMapInt8Uint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]uint64:
		fastpathTV.DecMapInt8Uint64V(v, false, d)
	case *map[int8]uint64:
		if v2, changed2 := fastpathTV.DecMapInt8Uint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]uintptr:
		fastpathTV.DecMapInt8UintptrV(v, false, d)
	case *map[int8]uintptr:
		if v2, changed2 := fastpathTV.DecMapInt8UintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]int:
		fastpathTV.DecMapInt8IntV(v, false, d)
	case *map[int8]int:
		if v2, changed2 := fastpathTV.DecMapInt8IntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]int8:
		fastpathTV.DecMapInt8Int8V(v, false, d)
	case *map[int8]int8:
		if v2, changed2 := fastpathTV.DecMapInt8Int8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]int16:
		fastpathTV.DecMapInt8Int16V(v, false, d)
	case *map[int8]int16:
		if v2, changed2 := fastpathTV.DecMapInt8Int16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]int32:
		fastpathTV.DecMapInt8Int32V(v, false, d)
	case *map[int8]int32:
		if v2, changed2 := fastpathTV.DecMapInt8Int32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]int64:
		fastpathTV.DecMapInt8Int64V(v, false, d)
	case *map[int8]int64:
		if v2, changed2 := fastpathTV.DecMapInt8Int64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]float32:
		fastpathTV.DecMapInt8Float32V(v, false, d)
	case *map[int8]float32:
		if v2, changed2 := fastpathTV.DecMapInt8Float32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]float64:
		fastpathTV.DecMapInt8Float64V(v, false, d)
	case *map[int8]float64:
		if v2, changed2 := fastpathTV.DecMapInt8Float64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int8]bool:
		fastpathTV.DecMapInt8BoolV(v, false, d)
	case *map[int8]bool:
		if v2, changed2 := fastpathTV.DecMapInt8BoolV(*v, true, d); changed2 {
			*v = v2
		}

	case []int16:
		fastpathTV.DecSliceInt16V(v, false, d)
	case *[]int16:
		if v2, changed2 := fastpathTV.DecSliceInt16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]interface{}:
		fastpathTV.DecMapInt16IntfV(v, false, d)
	case *map[int16]interface{}:
		if v2, changed2 := fastpathTV.DecMapInt16IntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]string:
		fastpathTV.DecMapInt16StringV(v, false, d)
	case *map[int16]string:
		if v2, changed2 := fastpathTV.DecMapInt16StringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]uint:
		fastpathTV.DecMapInt16UintV(v, false, d)
	case *map[int16]uint:
		if v2, changed2 := fastpathTV.DecMapInt16UintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]uint8:
		fastpathTV.DecMapInt16Uint8V(v, false, d)
	case *map[int16]uint8:
		if v2, changed2 := fastpathTV.DecMapInt16Uint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]uint16:
		fastpathTV.DecMapInt16Uint16V(v, false, d)
	case *map[int16]uint16:
		if v2, changed2 := fastpathTV.DecMapInt16Uint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]uint32:
		fastpathTV.DecMapInt16Uint32V(v, false, d)
	case *map[int16]uint32:
		if v2, changed2 := fastpathTV.DecMapInt16Uint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]uint64:
		fastpathTV.DecMapInt16Uint64V(v, false, d)
	case *map[int16]uint64:
		if v2, changed2 := fastpathTV.DecMapInt16Uint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]uintptr:
		fastpathTV.DecMapInt16UintptrV(v, false, d)
	case *map[int16]uintptr:
		if v2, changed2 := fastpathTV.DecMapInt16UintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]int:
		fastpathTV.DecMapInt16IntV(v, false, d)
	case *map[int16]int:
		if v2, changed2 := fastpathTV.DecMapInt16IntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]int8:
		fastpathTV.DecMapInt16Int8V(v, false, d)
	case *map[int16]int8:
		if v2, changed2 := fastpathTV.DecMapInt16Int8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]int16:
		fastpathTV.DecMapInt16Int16V(v, false, d)
	case *map[int16]int16:
		if v2, changed2 := fastpathTV.DecMapInt16Int16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]int32:
		fastpathTV.DecMapInt16Int32V(v, false, d)
	case *map[int16]int32:
		if v2, changed2 := fastpathTV.DecMapInt16Int32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]int64:
		fastpathTV.DecMapInt16Int64V(v, false, d)
	case *map[int16]int64:
		if v2, changed2 := fastpathTV.DecMapInt16Int64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]float32:
		fastpathTV.DecMapInt16Float32V(v, false, d)
	case *map[int16]float32:
		if v2, changed2 := fastpathTV.DecMapInt16Float32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]float64:
		fastpathTV.DecMapInt16Float64V(v, false, d)
	case *map[int16]float64:
		if v2, changed2 := fastpathTV.DecMapInt16Float64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int16]bool:
		fastpathTV.DecMapInt16BoolV(v, false, d)
	case *map[int16]bool:
		if v2, changed2 := fastpathTV.DecMapInt16BoolV(*v, true, d); changed2 {
			*v = v2
		}

	case []int32:
		fastpathTV.DecSliceInt32V(v, false, d)
	case *[]int32:
		if v2, changed2 := fastpathTV.DecSliceInt32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]interface{}:
		fastpathTV.DecMapInt32IntfV(v, false, d)
	case *map[int32]interface{}:
		if v2, changed2 := fastpathTV.DecMapInt32IntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]string:
		fastpathTV.DecMapInt32StringV(v, false, d)
	case *map[int32]string:
		if v2, changed2 := fastpathTV.DecMapInt32StringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]uint:
		fastpathTV.DecMapInt32UintV(v, false, d)
	case *map[int32]uint:
		if v2, changed2 := fastpathTV.DecMapInt32UintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]uint8:
		fastpathTV.DecMapInt32Uint8V(v, false, d)
	case *map[int32]uint8:
		if v2, changed2 := fastpathTV.DecMapInt32Uint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]uint16:
		fastpathTV.DecMapInt32Uint16V(v, false, d)
	case *map[int32]uint16:
		if v2, changed2 := fastpathTV.DecMapInt32Uint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]uint32:
		fastpathTV.DecMapInt32Uint32V(v, false, d)
	case *map[int32]uint32:
		if v2, changed2 := fastpathTV.DecMapInt32Uint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]uint64:
		fastpathTV.DecMapInt32Uint64V(v, false, d)
	case *map[int32]uint64:
		if v2, changed2 := fastpathTV.DecMapInt32Uint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]uintptr:
		fastpathTV.DecMapInt32UintptrV(v, false, d)
	case *map[int32]uintptr:
		if v2, changed2 := fastpathTV.DecMapInt32UintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]int:
		fastpathTV.DecMapInt32IntV(v, false, d)
	case *map[int32]int:
		if v2, changed2 := fastpathTV.DecMapInt32IntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]int8:
		fastpathTV.DecMapInt32Int8V(v, false, d)
	case *map[int32]int8:
		if v2, changed2 := fastpathTV.DecMapInt32Int8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]int16:
		fastpathTV.DecMapInt32Int16V(v, false, d)
	case *map[int32]int16:
		if v2, changed2 := fastpathTV.DecMapInt32Int16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]int32:
		fastpathTV.DecMapInt32Int32V(v, false, d)
	case *map[int32]int32:
		if v2, changed2 := fastpathTV.DecMapInt32Int32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]int64:
		fastpathTV.DecMapInt32Int64V(v, false, d)
	case *map[int32]int64:
		if v2, changed2 := fastpathTV.DecMapInt32Int64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]float32:
		fastpathTV.DecMapInt32Float32V(v, false, d)
	case *map[int32]float32:
		if v2, changed2 := fastpathTV.DecMapInt32Float32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]float64:
		fastpathTV.DecMapInt32Float64V(v, false, d)
	case *map[int32]float64:
		if v2, changed2 := fastpathTV.DecMapInt32Float64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int32]bool:
		fastpathTV.DecMapInt32BoolV(v, false, d)
	case *map[int32]bool:
		if v2, changed2 := fastpathTV.DecMapInt32BoolV(*v, true, d); changed2 {
			*v = v2
		}

	case []int64:
		fastpathTV.DecSliceInt64V(v, false, d)
	case *[]int64:
		if v2, changed2 := fastpathTV.DecSliceInt64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]interface{}:
		fastpathTV.DecMapInt64IntfV(v, false, d)
	case *map[int64]interface{}:
		if v2, changed2 := fastpathTV.DecMapInt64IntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]string:
		fastpathTV.DecMapInt64StringV(v, false, d)
	case *map[int64]string:
		if v2, changed2 := fastpathTV.DecMapInt64StringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]uint:
		fastpathTV.DecMapInt64UintV(v, false, d)
	case *map[int64]uint:
		if v2, changed2 := fastpathTV.DecMapInt64UintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]uint8:
		fastpathTV.DecMapInt64Uint8V(v, false, d)
	case *map[int64]uint8:
		if v2, changed2 := fastpathTV.DecMapInt64Uint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]uint16:
		fastpathTV.DecMapInt64Uint16V(v, false, d)
	case *map[int64]uint16:
		if v2, changed2 := fastpathTV.DecMapInt64Uint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]uint32:
		fastpathTV.DecMapInt64Uint32V(v, false, d)
	case *map[int64]uint32:
		if v2, changed2 := fastpathTV.DecMapInt64Uint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]uint64:
		fastpathTV.DecMapInt64Uint64V(v, false, d)
	case *map[int64]uint64:
		if v2, changed2 := fastpathTV.DecMapInt64Uint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]uintptr:
		fastpathTV.DecMapInt64UintptrV(v, false, d)
	case *map[int64]uintptr:
		if v2, changed2 := fastpathTV.DecMapInt64UintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]int:
		fastpathTV.DecMapInt64IntV(v, false, d)
	case *map[int64]int:
		if v2, changed2 := fastpathTV.DecMapInt64IntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]int8:
		fastpathTV.DecMapInt64Int8V(v, false, d)
	case *map[int64]int8:
		if v2, changed2 := fastpathTV.DecMapInt64Int8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]int16:
		fastpathTV.DecMapInt64Int16V(v, false, d)
	case *map[int64]int16:
		if v2, changed2 := fastpathTV.DecMapInt64Int16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]int32:
		fastpathTV.DecMapInt64Int32V(v, false, d)
	case *map[int64]int32:
		if v2, changed2 := fastpathTV.DecMapInt64Int32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]int64:
		fastpathTV.DecMapInt64Int64V(v, false, d)
	case *map[int64]int64:
		if v2, changed2 := fastpathTV.DecMapInt64Int64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]float32:
		fastpathTV.DecMapInt64Float32V(v, false, d)
	case *map[int64]float32:
		if v2, changed2 := fastpathTV.DecMapInt64Float32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]float64:
		fastpathTV.DecMapInt64Float64V(v, false, d)
	case *map[int64]float64:
		if v2, changed2 := fastpathTV.DecMapInt64Float64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[int64]bool:
		fastpathTV.DecMapInt64BoolV(v, false, d)
	case *map[int64]bool:
		if v2, changed2 := fastpathTV.DecMapInt64BoolV(*v, true, d); changed2 {
			*v = v2
		}

	case []bool:
		fastpathTV.DecSliceBoolV(v, false, d)
	case *[]bool:
		if v2, changed2 := fastpathTV.DecSliceBoolV(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]interface{}:
		fastpathTV.DecMapBoolIntfV(v, false, d)
	case *map[bool]interface{}:
		if v2, changed2 := fastpathTV.DecMapBoolIntfV(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]string:
		fastpathTV.DecMapBoolStringV(v, false, d)
	case *map[bool]string:
		if v2, changed2 := fastpathTV.DecMapBoolStringV(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]uint:
		fastpathTV.DecMapBoolUintV(v, false, d)
	case *map[bool]uint:
		if v2, changed2 := fastpathTV.DecMapBoolUintV(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]uint8:
		fastpathTV.DecMapBoolUint8V(v, false, d)
	case *map[bool]uint8:
		if v2, changed2 := fastpathTV.DecMapBoolUint8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]uint16:
		fastpathTV.DecMapBoolUint16V(v, false, d)
	case *map[bool]uint16:
		if v2, changed2 := fastpathTV.DecMapBoolUint16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]uint32:
		fastpathTV.DecMapBoolUint32V(v, false, d)
	case *map[bool]uint32:
		if v2, changed2 := fastpathTV.DecMapBoolUint32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]uint64:
		fastpathTV.DecMapBoolUint64V(v, false, d)
	case *map[bool]uint64:
		if v2, changed2 := fastpathTV.DecMapBoolUint64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]uintptr:
		fastpathTV.DecMapBoolUintptrV(v, false, d)
	case *map[bool]uintptr:
		if v2, changed2 := fastpathTV.DecMapBoolUintptrV(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]int:
		fastpathTV.DecMapBoolIntV(v, false, d)
	case *map[bool]int:
		if v2, changed2 := fastpathTV.DecMapBoolIntV(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]int8:
		fastpathTV.DecMapBoolInt8V(v, false, d)
	case *map[bool]int8:
		if v2, changed2 := fastpathTV.DecMapBoolInt8V(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]int16:
		fastpathTV.DecMapBoolInt16V(v, false, d)
	case *map[bool]int16:
		if v2, changed2 := fastpathTV.DecMapBoolInt16V(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]int32:
		fastpathTV.DecMapBoolInt32V(v, false, d)
	case *map[bool]int32:
		if v2, changed2 := fastpathTV.DecMapBoolInt32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]int64:
		fastpathTV.DecMapBoolInt64V(v, false, d)
	case *map[bool]int64:
		if v2, changed2 := fastpathTV.DecMapBoolInt64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]float32:
		fastpathTV.DecMapBoolFloat32V(v, false, d)
	case *map[bool]float32:
		if v2, changed2 := fastpathTV.DecMapBoolFloat32V(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]float64:
		fastpathTV.DecMapBoolFloat64V(v, false, d)
	case *map[bool]float64:
		if v2, changed2 := fastpathTV.DecMapBoolFloat64V(*v, true, d); changed2 {
			*v = v2
		}

	case map[bool]bool:
		fastpathTV.DecMapBoolBoolV(v, false, d)
	case *map[bool]bool:
		if v2, changed2 := fastpathTV.DecMapBoolBoolV(*v, true, d); changed2 {
			*v = v2
		}

	default:
		_ = v // TODO: workaround https://github.com/golang/go/issues/12927 (remove after go 1.6 release)
		return false
	}
	return true
}

func fastpathDecodeSetZeroTypeSwitch(iv interface{}, d *Decoder) bool {
	switch v := iv.(type) {

	case *[]interface{}:
		*v = nil

	case *map[interface{}]interface{}:
		*v = nil

	case *map[interface{}]string:
		*v = nil

	case *map[interface{}]uint:
		*v = nil

	case *map[interface{}]uint8:
		*v = nil

	case *map[interface{}]uint16:
		*v = nil

	case *map[interface{}]uint32:
		*v = nil

	case *map[interface{}]uint64:
		*v = nil

	case *map[interface{}]uintptr:
		*v = nil

	case *map[interface{}]int:
		*v = nil

	case *map[interface{}]int8:
		*v = nil

	case *map[interface{}]int16:
		*v = nil

	case *map[interface{}]int32:
		*v = nil

	case *map[interface{}]int64:
		*v = nil

	case *map[interface{}]float32:
		*v = nil

	case *map[interface{}]float64:
		*v = nil

	case *map[interface{}]bool:
		*v = nil

	case *[]string:
		*v = nil

	case *map[string]interface{}:
		*v = nil

	case *map[string]string:
		*v = nil

	case *map[string]uint:
		*v = nil

	case *map[string]uint8:
		*v = nil

	case *map[string]uint16:
		*v = nil

	case *map[string]uint32:
		*v = nil

	case *map[string]uint64:
		*v = nil

	case *map[string]uintptr:
		*v = nil

	case *map[string]int:
		*v = nil

	case *map[string]int8:
		*v = nil

	case *map[string]int16:
		*v = nil

	case *map[string]int32:
		*v = nil

	case *map[string]int64:
		*v = nil

	case *map[string]float32:
		*v = nil

	case *map[string]float64:
		*v = nil

	case *map[string]bool:
		*v = nil

	case *[]float32:
		*v = nil

	case *map[float32]interface{}:
		*v = nil

	case *map[float32]string:
		*v = nil

	case *map[float32]uint:
		*v = nil

	case *map[float32]uint8:
		*v = nil

	case *map[float32]uint16:
		*v = nil

	case *map[float32]uint32:
		*v = nil

	case *map[float32]uint64:
		*v = nil

	case *map[float32]uintptr:
		*v = nil

	case *map[float32]int:
		*v = nil

	case *map[float32]int8:
		*v = nil

	case *map[float32]int16:
		*v = nil

	case *map[float32]int32:
		*v = nil

	case *map[float32]int64:
		*v = nil

	case *map[float32]float32:
		*v = nil

	case *map[float32]float64:
		*v = nil

	case *map[float32]bool:
		*v = nil

	case *[]float64:
		*v = nil

	case *map[float64]interface{}:
		*v = nil

	case *map[float64]string:
		*v = nil

	case *map[float64]uint:
		*v = nil

	case *map[float64]uint8:
		*v = nil

	case *map[float64]uint16:
		*v = nil

	case *map[float64]uint32:
		*v = nil

	case *map[float64]uint64:
		*v = nil

	case *map[float64]uintptr:
		*v = nil

	case *map[float64]int:
		*v = nil

	case *map[float64]int8:
		*v = nil

	case *map[float64]int16:
		*v = nil

	case *map[float64]int32:
		*v = nil

	case *map[float64]int64:
		*v = nil

	case *map[float64]float32:
		*v = nil

	case *map[float64]float64:
		*v = nil

	case *map[float64]bool:
		*v = nil

	case *[]uint:
		*v = nil

	case *map[uint]interface{}:
		*v = nil

	case *map[uint]string:
		*v = nil

	case *map[uint]uint:
		*v = nil

	case *map[uint]uint8:
		*v = nil

	case *map[uint]uint16:
		*v = nil

	case *map[uint]uint32:
		*v = nil

	case *map[uint]uint64:
		*v = nil

	case *map[uint]uintptr:
		*v = nil

	case *map[uint]int:
		*v = nil

	case *map[uint]int8:
		*v = nil

	case *map[uint]int16:
		*v = nil

	case *map[uint]int32:
		*v = nil

	case *map[uint]int64:
		*v = nil

	case *map[uint]float32:
		*v = nil

	case *map[uint]float64:
		*v = nil

	case *map[uint]bool:
		*v = nil

	case *map[uint8]interface{}:
		*v = nil

	case *map[uint8]string:
		*v = nil

	case *map[uint8]uint:
		*v = nil

	case *map[uint8]uint8:
		*v = nil

	case *map[uint8]uint16:
		*v = nil

	case *map[uint8]uint32:
		*v = nil

	case *map[uint8]uint64:
		*v = nil

	case *map[uint8]uintptr:
		*v = nil

	case *map[uint8]int:
		*v = nil

	case *map[uint8]int8:
		*v = nil

	case *map[uint8]int16:
		*v = nil

	case *map[uint8]int32:
		*v = nil

	case *map[uint8]int64:
		*v = nil

	case *map[uint8]float32:
		*v = nil

	case *map[uint8]float64:
		*v = nil

	case *map[uint8]bool:
		*v = nil

	case *[]uint16:
		*v = nil

	case *map[uint16]interface{}:
		*v = nil

	case *map[uint16]string:
		*v = nil

	case *map[uint16]uint:
		*v = nil

	case *map[uint16]uint8:
		*v = nil

	case *map[uint16]uint16:
		*v = nil

	case *map[uint16]uint32:
		*v = nil

	case *map[uint16]uint64:
		*v = nil

	case *map[uint16]uintptr:
		*v = nil

	case *map[uint16]int:
		*v = nil

	case *map[uint16]int8:
		*v = nil

	case *map[uint16]int16:
		*v = nil

	case *map[uint16]int32:
		*v = nil

	case *map[uint16]int64:
		*v = nil

	case *map[uint16]float32:
		*v = nil

	case *map[uint16]float64:
		*v = nil

	case *map[uint16]bool:
		*v = nil

	case *[]uint32:
		*v = nil

	case *map[uint32]interface{}:
		*v = nil

	case *map[uint32]string:
		*v = nil

	case *map[uint32]uint:
		*v = nil

	case *map[uint32]uint8:
		*v = nil

	case *map[uint32]uint16:
		*v = nil

	case *map[uint32]uint32:
		*v = nil

	case *map[uint32]uint64:
		*v = nil

	case *map[uint32]uintptr:
		*v = nil

	case *map[uint32]int:
		*v = nil

	case *map[uint32]int8:
		*v = nil

	case *map[uint32]int16:
		*v = nil

	case *map[uint32]int32:
		*v = nil

	case *map[uint32]int64:
		*v = nil

	case *map[uint32]float32:
		*v = nil

	case *map[uint32]float64:
		*v = nil

	case *map[uint32]bool:
		*v = nil

	case *[]uint64:
		*v = nil

	case *map[uint64]interface{}:
		*v = nil

	case *map[uint64]string:
		*v = nil

	case *map[uint64]uint:
		*v = nil

	case *map[uint64]uint8:
		*v = nil

	case *map[uint64]uint16:
		*v = nil

	case *map[uint64]uint32:
		*v = nil

	case *map[uint64]uint64:
		*v = nil

	case *map[uint64]uintptr:
		*v = nil

	case *map[uint64]int:
		*v = nil

	case *map[uint64]int8:
		*v = nil

	case *map[uint64]int16:
		*v = nil

	case *map[uint64]int32:
		*v = nil

	case *map[uint64]int64:
		*v = nil

	case *map[uint64]float32:
		*v = nil

	case *map[uint64]float64:
		*v = nil

	case *map[uint64]bool:
		*v = nil

	case *[]uintptr:
		*v = nil

	case *map[uintptr]interface{}:
		*v = nil

	case *map[uintptr]string:
		*v = nil

	case *map[uintptr]uint:
		*v = nil

	case *map[uintptr]uint8:
		*v = nil

	case *map[uintptr]uint16:
		*v = nil

	case *map[uintptr]uint32:
		*v = nil

	case *map[uintptr]uint64:
		*v = nil

	case *map[uintptr]uintptr:
		*v = nil

	case *map[uintptr]int:
		*v = nil

	case *map[uintptr]int8:
		*v = nil

	case *map[uintptr]int16:
		*v = nil

	case *map[uintptr]int32:
		*v = nil

	case *map[uintptr]int64:
		*v = nil

	case *map[uintptr]float32:
		*v = nil

	case *map[uintptr]float64:
		*v = nil

	case *map[uintptr]bool:
		*v = nil

	case *[]int:
		*v = nil

	case *map[int]interface{}:
		*v = nil

	case *map[int]string:
		*v = nil

	case *map[int]uint:
		*v = nil

	case *map[int]uint8:
		*v = nil

	case *map[int]uint16:
		*v = nil

	case *map[int]uint32:
		*v = nil

	case *map[int]uint64:
		*v = nil

	case *map[int]uintptr:
		*v = nil

	case *map[int]int:
		*v = nil

	case *map[int]int8:
		*v = nil

	case *map[int]int16:
		*v = nil

	case *map[int]int32:
		*v = nil

	case *map[int]int64:
		*v = nil

	case *map[int]float32:
		*v = nil

	case *map[int]float64:
		*v = nil

	case *map[int]bool:
		*v = nil

	case *[]int8:
		*v = nil

	case *map[int8]interface{}:
		*v = nil

	case *map[int8]string:
		*v = nil

	case *map[int8]uint:
		*v = nil

	case *map[int8]uint8:
		*v = nil

	case *map[int8]uint16:
		*v = nil

	case *map[int8]uint32:
		*v = nil

	case *map[int8]uint64:
		*v = nil

	case *map[int8]uintptr:
		*v = nil

	case *map[int8]int:
		*v = nil

	case *map[int8]int8:
		*v = nil

	case *map[int8]int16:
		*v = nil

	case *map[int8]int32:
		*v = nil

	case *map[int8]int64:
		*v = nil

	case *map[int8]float32:
		*v = nil

	case *map[int8]float64:
		*v = nil

	case *map[int8]bool:
		*v = nil

	case *[]int16:
		*v = nil

	case *map[int16]interface{}:
		*v = nil

	case *map[int16]string:
		*v = nil

	case *map[int16]uint:
		*v = nil

	case *map[int16]uint8:
		*v = nil

	case *map[int16]uint16:
		*v = nil

	case *map[int16]uint32:
		*v = nil

	case *map[int16]uint64:
		*v = nil

	case *map[int16]uintptr:
		*v = nil

	case *map[int16]int:
		*v = nil

	case *map[int16]int8:
		*v = nil

	case *map[int16]int16:
		*v = nil

	case *map[int16]int32:
		*v = nil

	case *map[int16]int64:
		*v = nil

	case *map[int16]float32:
		*v = nil

	case *map[int16]float64:
		*v = nil

	case *map[int16]bool:
		*v = nil

	case *[]int32:
		*v = nil

	case *map[int32]interface{}:
		*v = nil

	case *map[int32]string:
		*v = nil

	case *map[int32]uint:
		*v = nil

	case *map[int32]uint8:
		*v = nil

	case *map[int32]uint16:
		*v = nil

	case *map[int32]uint32:
		*v = nil

	case *map[int32]uint64:
		*v = nil

	case *map[int32]uintptr:
		*v = nil

	case *map[int32]int:
		*v = nil

	case *map[int32]int8:
		*v = nil

	case *map[int32]int16:
		*v = nil

	case *map[int32]int32:
		*v = nil

	case *map[int32]int64:
		*v = nil

	case *map[int32]float32:
		*v = nil

	case *map[int32]float64:
		*v = nil

	case *map[int32]bool:
		*v = nil

	case *[]int64:
		*v = nil

	case *map[int64]interface{}:
		*v = nil

	case *map[int64]string:
		*v = nil

	case *map[int64]uint:
		*v = nil

	case *map[int64]uint8:
		*v = nil

	case *map[int64]uint16:
		*v = nil

	case *map[int64]uint32:
		*v = nil

	case *map[int64]uint64:
		*v = nil

	case *map[int64]uintptr:
		*v = nil

	case *map[int64]int:
		*v = nil

	case *map[int64]int8:
		*v = nil

	case *map[int64]int16:
		*v = nil

	case *map[int64]int32:
		*v = nil

	case *map[int64]int64:
		*v = nil

	case *map[int64]float32:
		*v = nil

	case *map[int64]float64:
		*v = nil

	case *map[int64]bool:
		*v = nil

	case *[]bool:
		*v = nil

	case *map[bool]interface{}:
		*v = nil

	case *map[bool]string:
		*v = nil

	case *map[bool]uint:
		*v = nil

	case *map[bool]uint8:
		*v = nil

	case *map[bool]uint16:
		*v = nil

	case *map[bool]uint32:
		*v = nil

	case *map[bool]uint64:
		*v = nil

	case *map[bool]uintptr:
		*v = nil

	case *map[bool]int:
		*v = nil

	case *map[bool]int8:
		*v = nil

	case *map[bool]int16:
		*v = nil

	case *map[bool]int32:
		*v = nil

	case *map[bool]int64:
		*v = nil

	case *map[bool]float32:
		*v = nil

	case *map[bool]float64:
		*v = nil

	case *map[bool]bool:
		*v = nil

	default:
		_ = v // TODO: workaround https://github.com/golang/go/issues/12927 (remove after go 1.6 release)
		return false
	}
	return true
}

// -- -- fast path functions

func (d *Decoder) fastpathDecSliceIntfR(f *codecFnInfo, rv reflect.Value) {
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr {
		var vp = rv2i(rv).(*[]interface{})
		if v, changed := fastpathTV.DecSliceIntfV(*vp, !array, d); changed {
			*vp = v
		}
	} else {
		fastpathTV.DecSliceIntfV(rv2i(rv).([]interface{}), !array, d)
	}
}

func (f fastpathT) DecSliceIntfX(vp *[]interface{}, d *Decoder) {
	if v, changed := f.DecSliceIntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecSliceIntfV(v []interface{}, canChange bool, d *Decoder) (_ []interface{}, changed bool) {
	dd := d.d

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 {
		if canChange {
			if v == nil {
				v = []interface{}{}
			} else if len(v) != 0 {
				v = v[:0]
			}
			changed = true
		}
		slh.End()
		return v, changed
	}

	hasLen := containerLenS > 0
	var xlen int
	if hasLen && canChange {
		if containerLenS > cap(v) {
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, 16)
			if xlen <= cap(v) {
				v = v[:xlen]
			} else {
				v = make([]interface{}, xlen)
			}
			changed = true
		} else if containerLenS != len(v) {
			v = v[:containerLenS]
			changed = true
		}
	}
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ {
		if j == 0 && len(v) == 0 {
			if hasLen {
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, 16)
			} else {
				xlen = 8
			}
			v = make([]interface{}, xlen)
			changed = true
		}
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) {
			if canChange {
				v = append(v, nil)
				changed = true
			} else {
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			}
		}
		slh.ElemContainerState(j)
		if decodeIntoBlank {
			d.swallow()
		} else {
			d.decode(&v[j])
		}
	}
	if canChange {
		if j < len(v) {
			v = v[:j]
			changed = true
		} else if j == 0 && v == nil {
			v = make([]interface{}, 0)
			changed = true
		}
	}
	slh.End()
	return v, changed
}

func (d *Decoder) fastpathDecSliceStringR(f *codecFnInfo, rv reflect.Value) {
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr {
		var vp = rv2i(rv).(*[]string)
		if v, changed := fastpathTV.DecSliceStringV(*vp, !array, d); changed {
			*vp = v
		}
	} else {
		fastpathTV.DecSliceStringV(rv2i(rv).([]string), !array, d)
	}
}

func (f fastpathT) DecSliceStringX(vp *[]string, d *Decoder) {
	if v, changed := f.DecSliceStringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecSliceStringV(v []string, canChange bool, d *Decoder) (_ []string, changed bool) {
	dd := d.d

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 {
		if canChange {
			if v == nil {
				v = []string{}
			} else if len(v) != 0 {
				v = v[:0]
			}
			changed = true
		}
		slh.End()
		return v, changed
	}

	hasLen := containerLenS > 0
	var xlen int
	if hasLen && canChange {
		if containerLenS > cap(v) {
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, 16)
			if xlen <= cap(v) {
				v = v[:xlen]
			} else {
				v = make([]string, xlen)
			}
			changed = true
		} else if containerLenS != len(v) {
			v = v[:containerLenS]
			changed = true
		}
	}
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ {
		if j == 0 && len(v) == 0 {
			if hasLen {
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, 16)
			} else {
				xlen = 8
			}
			v = make([]string, xlen)
			changed = true
		}
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) {
			if canChange {
				v = append(v, "")
				changed = true
			} else {
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			}
		}
		slh.ElemContainerState(j)
		if decodeIntoBlank {
			d.swallow()
		} else {
			v[j] = dd.DecodeString()
		}
	}
	if canChange {
		if j < len(v) {
			v = v[:j]
			changed = true
		} else if j == 0 && v == nil {
			v = make([]string, 0)
			changed = true
		}
	}
	slh.End()
	return v, changed
}

func (d *Decoder) fastpathDecSliceFloat32R(f *codecFnInfo, rv reflect.Value) {
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr {
		var vp = rv2i(rv).(*[]float32)
		if v, changed := fastpathTV.DecSliceFloat32V(*vp, !array, d); changed {
			*vp = v
		}
	} else {
		fastpathTV.DecSliceFloat32V(rv2i(rv).([]float32), !array, d)
	}
}

func (f fastpathT) DecSliceFloat32X(vp *[]float32, d *Decoder) {
	if v, changed := f.DecSliceFloat32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecSliceFloat32V(v []float32, canChange bool, d *Decoder) (_ []float32, changed bool) {
	dd := d.d

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 {
		if canChange {
			if v == nil {
				v = []float32{}
			} else if len(v) != 0 {
				v = v[:0]
			}
			changed = true
		}
		slh.End()
		return v, changed
	}

	hasLen := containerLenS > 0
	var xlen int
	if hasLen && canChange {
		if containerLenS > cap(v) {
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, 4)
			if xlen <= cap(v) {
				v = v[:xlen]
			} else {
				v = make([]float32, xlen)
			}
			changed = true
		} else if containerLenS != len(v) {
			v = v[:containerLenS]
			changed = true
		}
	}
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ {
		if j == 0 && len(v) == 0 {
			if hasLen {
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, 4)
			} else {
				xlen = 8
			}
			v = make([]float32, xlen)
			changed = true
		}
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) {
			if canChange {
				v = append(v, 0)
				changed = true
			} else {
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			}
		}
		slh.ElemContainerState(j)
		if decodeIntoBlank {
			d.swallow()
		} else {
			v[j] = float32(dd.DecodeFloat(true))
		}
	}
	if canChange {
		if j < len(v) {
			v = v[:j]
			changed = true
		} else if j == 0 && v == nil {
			v = make([]float32, 0)
			changed = true
		}
	}
	slh.End()
	return v, changed
}

func (d *Decoder) fastpathDecSliceFloat64R(f *codecFnInfo, rv reflect.Value) {
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr {
		var vp = rv2i(rv).(*[]float64)
		if v, changed := fastpathTV.DecSliceFloat64V(*vp, !array, d); changed {
			*vp = v
		}
	} else {
		fastpathTV.DecSliceFloat64V(rv2i(rv).([]float64), !array, d)
	}
}

func (f fastpathT) DecSliceFloat64X(vp *[]float64, d *Decoder) {
	if v, changed := f.DecSliceFloat64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecSliceFloat64V(v []float64, canChange bool, d *Decoder) (_ []float64, changed bool) {
	dd := d.d

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 {
		if canChange {
			if v == nil {
				v = []float64{}
			} else if len(v) != 0 {
				v = v[:0]
			}
			changed = true
		}
		slh.End()
		return v, changed
	}

	hasLen := containerLenS > 0
	var xlen int
	if hasLen && canChange {
		if containerLenS > cap(v) {
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, 8)
			if xlen <= cap(v) {
				v = v[:xlen]
			} else {
				v = make([]float64, xlen)
			}
			changed = true
		} else if containerLenS != len(v) {
			v = v[:containerLenS]
			changed = true
		}
	}
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ {
		if j == 0 && len(v) == 0 {
			if hasLen {
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, 8)
			} else {
				xlen = 8
			}
			v = make([]float64, xlen)
			changed = true
		}
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) {
			if canChange {
				v = append(v, 0)
				changed = true
			} else {
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			}
		}
		slh.ElemContainerState(j)
		if decodeIntoBlank {
			d.swallow()
		} else {
			v[j] = dd.DecodeFloat(false)
		}
	}
	if canChange {
		if j < len(v) {
			v = v[:j]
			changed = true
		} else if j == 0 && v == nil {
			v = make([]float64, 0)
			changed = true
		}
	}
	slh.End()
	return v, changed
}

func (d *Decoder) fastpathDecSliceUintR(f *codecFnInfo, rv reflect.Value) {
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr {
		var vp = rv2i(rv).(*[]uint)
		if v, changed := fastpathTV.DecSliceUintV(*vp, !array, d); changed {
			*vp = v
		}
	} else {
		fastpathTV.DecSliceUintV(rv2i(rv).([]uint), !array, d)
	}
}

func (f fastpathT) DecSliceUintX(vp *[]uint, d *Decoder) {
	if v, changed := f.DecSliceUintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecSliceUintV(v []uint, canChange bool, d *Decoder) (_ []uint, changed bool) {
	dd := d.d

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 {
		if canChange {
			if v == nil {
				v = []uint{}
			} else if len(v) != 0 {
				v = v[:0]
			}
			changed = true
		}
		slh.End()
		return v, changed
	}

	hasLen := containerLenS > 0
	var xlen int
	if hasLen && canChange {
		if containerLenS > cap(v) {
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, 8)
			if xlen <= cap(v) {
				v = v[:xlen]
			} else {
				v = make([]uint, xlen)
			}
			changed = true
		} else if containerLenS != len(v) {
			v = v[:containerLenS]
			changed = true
		}
	}
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ {
		if j == 0 && len(v) == 0 {
			if hasLen {
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, 8)
			} else {
				xlen = 8
			}
			v = make([]uint, xlen)
			changed = true
		}
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) {
			if canChange {
				v = append(v, 0)
				changed = true
			} else {
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			}
		}
		slh.ElemContainerState(j)
		if decodeIntoBlank {
			d.swallow()
		} else {
			v[j] = uint(dd.DecodeUint(uintBitsize))
		}
	}
	if canChange {
		if j < len(v) {
			v = v[:j]
			changed = true
		} else if j == 0 && v == nil {
			v = make([]uint, 0)
			changed = true
		}
	}
	slh.End()
	return v, changed
}

func (d *Decoder) fastpathDecSliceUint16R(f *codecFnInfo, rv reflect.Value) {
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr {
		var vp = rv2i(rv).(*[]uint16)
		if v, changed := fastpathTV.DecSliceUint16V(*vp, !array, d); changed {
			*vp = v
		}
	} else {
		fastpathTV.DecSliceUint16V(rv2i(rv).([]uint16), !array, d)
	}
}

func (f fastpathT) DecSliceUint16X(vp *[]uint16, d *Decoder) {
	if v, changed := f.DecSliceUint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecSliceUint16V(v []uint16, canChange bool, d *Decoder) (_ []uint16, changed bool) {
	dd := d.d

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 {
		if canChange {
			if v == nil {
				v = []uint16{}
			} else if len(v) != 0 {
				v = v[:0]
			}
			changed = true
		}
		slh.End()
		return v, changed
	}

	hasLen := containerLenS > 0
	var xlen int
	if hasLen && canChange {
		if containerLenS > cap(v) {
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, 2)
			if xlen <= cap(v) {
				v = v[:xlen]
			} else {
				v = make([]uint16, xlen)
			}
			changed = true
		} else if containerLenS != len(v) {
			v = v[:containerLenS]
			changed = true
		}
	}
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ {
		if j == 0 && len(v) == 0 {
			if hasLen {
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, 2)
			} else {
				xlen = 8
			}
			v = make([]uint16, xlen)
			changed = true
		}
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) {
			if canChange {
				v = append(v, 0)
				changed = true
			} else {
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			}
		}
		slh.ElemContainerState(j)
		if decodeIntoBlank {
			d.swallow()
		} else {
			v[j] = uint16(dd.DecodeUint(16))
		}
	}
	if canChange {
		if j < len(v) {
			v = v[:j]
			changed = true
		} else if j == 0 && v == nil {
			v = make([]uint16, 0)
			changed = true
		}
	}
	slh.End()
	return v, changed
}

func (d *Decoder) fastpathDecSliceUint32R(f *codecFnInfo, rv reflect.Value) {
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr {
		var vp = rv2i(rv).(*[]uint32)
		if v, changed := fastpathTV.DecSliceUint32V(*vp, !array, d); changed {
			*vp = v
		}
	} else {
		fastpathTV.DecSliceUint32V(rv2i(rv).([]uint32), !array, d)
	}
}

func (f fastpathT) DecSliceUint32X(vp *[]uint32, d *Decoder) {
	if v, changed := f.DecSliceUint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecSliceUint32V(v []uint32, canChange bool, d *Decoder) (_ []uint32, changed bool) {
	dd := d.d

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 {
		if canChange {
			if v == nil {
				v = []uint32{}
			} else if len(v) != 0 {
				v = v[:0]
			}
			changed = true
		}
		slh.End()
		return v, changed
	}

	hasLen := containerLenS > 0
	var xlen int
	if hasLen && canChange {
		if containerLenS > cap(v) {
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, 4)
			if xlen <= cap(v) {
				v = v[:xlen]
			} else {
				v = make([]uint32, xlen)
			}
			changed = true
		} else if containerLenS != len(v) {
			v = v[:containerLenS]
			changed = true
		}
	}
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ {
		if j == 0 && len(v) == 0 {
			if hasLen {
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, 4)
			} else {
				xlen = 8
			}
			v = make([]uint32, xlen)
			changed = true
		}
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) {
			if canChange {
				v = append(v, 0)
				changed = true
			} else {
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			}
		}
		slh.ElemContainerState(j)
		if decodeIntoBlank {
			d.swallow()
		} else {
			v[j] = uint32(dd.DecodeUint(32))
		}
	}
	if canChange {
		if j < len(v) {
			v = v[:j]
			changed = true
		} else if j == 0 && v == nil {
			v = make([]uint32, 0)
			changed = true
		}
	}
	slh.End()
	return v, changed
}

func (d *Decoder) fastpathDecSliceUint64R(f *codecFnInfo, rv reflect.Value) {
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr {
		var vp = rv2i(rv).(*[]uint64)
		if v, changed := fastpathTV.DecSliceUint64V(*vp, !array, d); changed {
			*vp = v
		}
	} else {
		fastpathTV.DecSliceUint64V(rv2i(rv).([]uint64), !array, d)
	}
}

func (f fastpathT) DecSliceUint64X(vp *[]uint64, d *Decoder) {
	if v, changed := f.DecSliceUint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecSliceUint64V(v []uint64, canChange bool, d *Decoder) (_ []uint64, changed bool) {
	dd := d.d

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 {
		if canChange {
			if v == nil {
				v = []uint64{}
			} else if len(v) != 0 {
				v = v[:0]
			}
			changed = true
		}
		slh.End()
		return v, changed
	}

	hasLen := containerLenS > 0
	var xlen int
	if hasLen && canChange {
		if containerLenS > cap(v) {
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, 8)
			if xlen <= cap(v) {
				v = v[:xlen]
			} else {
				v = make([]uint64, xlen)
			}
			changed = true
		} else if containerLenS != len(v) {
			v = v[:containerLenS]
			changed = true
		}
	}
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ {
		if j == 0 && len(v) == 0 {
			if hasLen {
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, 8)
			} else {
				xlen = 8
			}
			v = make([]uint64, xlen)
			changed = true
		}
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) {
			if canChange {
				v = append(v, 0)
				changed = true
			} else {
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			}
		}
		slh.ElemContainerState(j)
		if decodeIntoBlank {
			d.swallow()
		} else {
			v[j] = dd.DecodeUint(64)
		}
	}
	if canChange {
		if j < len(v) {
			v = v[:j]
			changed = true
		} else if j == 0 && v == nil {
			v = make([]uint64, 0)
			changed = true
		}
	}
	slh.End()
	return v, changed
}

func (d *Decoder) fastpathDecSliceUintptrR(f *codecFnInfo, rv reflect.Value) {
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr {
		var vp = rv2i(rv).(*[]uintptr)
		if v, changed := fastpathTV.DecSliceUintptrV(*vp, !array, d); changed {
			*vp = v
		}
	} else {
		fastpathTV.DecSliceUintptrV(rv2i(rv).([]uintptr), !array, d)
	}
}

func (f fastpathT) DecSliceUintptrX(vp *[]uintptr, d *Decoder) {
	if v, changed := f.DecSliceUintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecSliceUintptrV(v []uintptr, canChange bool, d *Decoder) (_ []uintptr, changed bool) {
	dd := d.d

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 {
		if canChange {
			if v == nil {
				v = []uintptr{}
			} else if len(v) != 0 {
				v = v[:0]
			}
			changed = true
		}
		slh.End()
		return v, changed
	}

	hasLen := containerLenS > 0
	var xlen int
	if hasLen && canChange {
		if containerLenS > cap(v) {
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, 8)
			if xlen <= cap(v) {
				v = v[:xlen]
			} else {
				v = make([]uintptr, xlen)
			}
			changed = true
		} else if containerLenS != len(v) {
			v = v[:containerLenS]
			changed = true
		}
	}
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ {
		if j == 0 && len(v) == 0 {
			if hasLen {
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, 8)
			} else {
				xlen = 8
			}
			v = make([]uintptr, xlen)
			changed = true
		}
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) {
			if canChange {
				v = append(v, 0)
				changed = true
			} else {
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			}
		}
		slh.ElemContainerState(j)
		if decodeIntoBlank {
			d.swallow()
		} else {
			v[j] = uintptr(dd.DecodeUint(uintBitsize))
		}
	}
	if canChange {
		if j < len(v) {
			v = v[:j]
			changed = true
		} else if j == 0 && v == nil {
			v = make([]uintptr, 0)
			changed = true
		}
	}
	slh.End()
	return v, changed
}

func (d *Decoder) fastpathDecSliceIntR(f *codecFnInfo, rv reflect.Value) {
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr {
		var vp = rv2i(rv).(*[]int)
		if v, changed := fastpathTV.DecSliceIntV(*vp, !array, d); changed {
			*vp = v
		}
	} else {
		fastpathTV.DecSliceIntV(rv2i(rv).([]int), !array, d)
	}
}

func (f fastpathT) DecSliceIntX(vp *[]int, d *Decoder) {
	if v, changed := f.DecSliceIntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecSliceIntV(v []int, canChange bool, d *Decoder) (_ []int, changed bool) {
	dd := d.d

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 {
		if canChange {
			if v == nil {
				v = []int{}
			} else if len(v) != 0 {
				v = v[:0]
			}
			changed = true
		}
		slh.End()
		return v, changed
	}

	hasLen := containerLenS > 0
	var xlen int
	if hasLen && canChange {
		if containerLenS > cap(v) {
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, 8)
			if xlen <= cap(v) {
				v = v[:xlen]
			} else {
				v = make([]int, xlen)
			}
			changed = true
		} else if containerLenS != len(v) {
			v = v[:containerLenS]
			changed = true
		}
	}
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ {
		if j == 0 && len(v) == 0 {
			if hasLen {
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, 8)
			} else {
				xlen = 8
			}
			v = make([]int, xlen)
			changed = true
		}
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) {
			if canChange {
				v = append(v, 0)
				changed = true
			} else {
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			}
		}
		slh.ElemContainerState(j)
		if decodeIntoBlank {
			d.swallow()
		} else {
			v[j] = int(dd.DecodeInt(intBitsize))
		}
	}
	if canChange {
		if j < len(v) {
			v = v[:j]
			changed = true
		} else if j == 0 && v == nil {
			v = make([]int, 0)
			changed = true
		}
	}
	slh.End()
	return v, changed
}

func (d *Decoder) fastpathDecSliceInt8R(f *codecFnInfo, rv reflect.Value) {
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr {
		var vp = rv2i(rv).(*[]int8)
		if v, changed := fastpathTV.DecSliceInt8V(*vp, !array, d); changed {
			*vp = v
		}
	} else {
		fastpathTV.DecSliceInt8V(rv2i(rv).([]int8), !array, d)
	}
}

func (f fastpathT) DecSliceInt8X(vp *[]int8, d *Decoder) {
	if v, changed := f.DecSliceInt8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecSliceInt8V(v []int8, canChange bool, d *Decoder) (_ []int8, changed bool) {
	dd := d.d

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 {
		if canChange {
			if v == nil {
				v = []int8{}
			} else if len(v) != 0 {
				v = v[:0]
			}
			changed = true
		}
		slh.End()
		return v, changed
	}

	hasLen := containerLenS > 0
	var xlen int
	if hasLen && canChange {
		if containerLenS > cap(v) {
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, 1)
			if xlen <= cap(v) {
				v = v[:xlen]
			} else {
				v = make([]int8, xlen)
			}
			changed = true
		} else if containerLenS != len(v) {
			v = v[:containerLenS]
			changed = true
		}
	}
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ {
		if j == 0 && len(v) == 0 {
			if hasLen {
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, 1)
			} else {
				xlen = 8
			}
			v = make([]int8, xlen)
			changed = true
		}
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) {
			if canChange {
				v = append(v, 0)
				changed = true
			} else {
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			}
		}
		slh.ElemContainerState(j)
		if decodeIntoBlank {
			d.swallow()
		} else {
			v[j] = int8(dd.DecodeInt(8))
		}
	}
	if canChange {
		if j < len(v) {
			v = v[:j]
			changed = true
		} else if j == 0 && v == nil {
			v = make([]int8, 0)
			changed = true
		}
	}
	slh.End()
	return v, changed
}

func (d *Decoder) fastpathDecSliceInt16R(f *codecFnInfo, rv reflect.Value) {
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr {
		var vp = rv2i(rv).(*[]int16)
		if v, changed := fastpathTV.DecSliceInt16V(*vp, !array, d); changed {
			*vp = v
		}
	} else {
		fastpathTV.DecSliceInt16V(rv2i(rv).([]int16), !array, d)
	}
}

func (f fastpathT) DecSliceInt16X(vp *[]int16, d *Decoder) {
	if v, changed := f.DecSliceInt16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecSliceInt16V(v []int16, canChange bool, d *Decoder) (_ []int16, changed bool) {
	dd := d.d

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 {
		if canChange {
			if v == nil {
				v = []int16{}
			} else if len(v) != 0 {
				v = v[:0]
			}
			changed = true
		}
		slh.End()
		return v, changed
	}

	hasLen := containerLenS > 0
	var xlen int
	if hasLen && canChange {
		if containerLenS > cap(v) {
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, 2)
			if xlen <= cap(v) {
				v = v[:xlen]
			} else {
				v = make([]int16, xlen)
			}
			changed = true
		} else if containerLenS != len(v) {
			v = v[:containerLenS]
			changed = true
		}
	}
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ {
		if j == 0 && len(v) == 0 {
			if hasLen {
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, 2)
			} else {
				xlen = 8
			}
			v = make([]int16, xlen)
			changed = true
		}
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) {
			if canChange {
				v = append(v, 0)
				changed = true
			} else {
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			}
		}
		slh.ElemContainerState(j)
		if decodeIntoBlank {
			d.swallow()
		} else {
			v[j] = int16(dd.DecodeInt(16))
		}
	}
	if canChange {
		if j < len(v) {
			v = v[:j]
			changed = true
		} else if j == 0 && v == nil {
			v = make([]int16, 0)
			changed = true
		}
	}
	slh.End()
	return v, changed
}

func (d *Decoder) fastpathDecSliceInt32R(f *codecFnInfo, rv reflect.Value) {
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr {
		var vp = rv2i(rv).(*[]int32)
		if v, changed := fastpathTV.DecSliceInt32V(*vp, !array, d); changed {
			*vp = v
		}
	} else {
		fastpathTV.DecSliceInt32V(rv2i(rv).([]int32), !array, d)
	}
}

func (f fastpathT) DecSliceInt32X(vp *[]int32, d *Decoder) {
	if v, changed := f.DecSliceInt32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecSliceInt32V(v []int32, canChange bool, d *Decoder) (_ []int32, changed bool) {
	dd := d.d

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 {
		if canChange {
			if v == nil {
				v = []int32{}
			} else if len(v) != 0 {
				v = v[:0]
			}
			changed = true
		}
		slh.End()
		return v, changed
	}

	hasLen := containerLenS > 0
	var xlen int
	if hasLen && canChange {
		if containerLenS > cap(v) {
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, 4)
			if xlen <= cap(v) {
				v = v[:xlen]
			} else {
				v = make([]int32, xlen)
			}
			changed = true
		} else if containerLenS != len(v) {
			v = v[:containerLenS]
			changed = true
		}
	}
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ {
		if j == 0 && len(v) == 0 {
			if hasLen {
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, 4)
			} else {
				xlen = 8
			}
			v = make([]int32, xlen)
			changed = true
		}
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) {
			if canChange {
				v = append(v, 0)
				changed = true
			} else {
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			}
		}
		slh.ElemContainerState(j)
		if decodeIntoBlank {
			d.swallow()
		} else {
			v[j] = int32(dd.DecodeInt(32))
		}
	}
	if canChange {
		if j < len(v) {
			v = v[:j]
			changed = true
		} else if j == 0 && v == nil {
			v = make([]int32, 0)
			changed = true
		}
	}
	slh.End()
	return v, changed
}

func (d *Decoder) fastpathDecSliceInt64R(f *codecFnInfo, rv reflect.Value) {
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr {
		var vp = rv2i(rv).(*[]int64)
		if v, changed := fastpathTV.DecSliceInt64V(*vp, !array, d); changed {
			*vp = v
		}
	} else {
		fastpathTV.DecSliceInt64V(rv2i(rv).([]int64), !array, d)
	}
}

func (f fastpathT) DecSliceInt64X(vp *[]int64, d *Decoder) {
	if v, changed := f.DecSliceInt64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecSliceInt64V(v []int64, canChange bool, d *Decoder) (_ []int64, changed bool) {
	dd := d.d

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 {
		if canChange {
			if v == nil {
				v = []int64{}
			} else if len(v) != 0 {
				v = v[:0]
			}
			changed = true
		}
		slh.End()
		return v, changed
	}

	hasLen := containerLenS > 0
	var xlen int
	if hasLen && canChange {
		if containerLenS > cap(v) {
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, 8)
			if xlen <= cap(v) {
				v = v[:xlen]
			} else {
				v = make([]int64, xlen)
			}
			changed = true
		} else if containerLenS != len(v) {
			v = v[:containerLenS]
			changed = true
		}
	}
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ {
		if j == 0 && len(v) == 0 {
			if hasLen {
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, 8)
			} else {
				xlen = 8
			}
			v = make([]int64, xlen)
			changed = true
		}
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) {
			if canChange {
				v = append(v, 0)
				changed = true
			} else {
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			}
		}
		slh.ElemContainerState(j)
		if decodeIntoBlank {
			d.swallow()
		} else {
			v[j] = dd.DecodeInt(64)
		}
	}
	if canChange {
		if j < len(v) {
			v = v[:j]
			changed = true
		} else if j == 0 && v == nil {
			v = make([]int64, 0)
			changed = true
		}
	}
	slh.End()
	return v, changed
}

func (d *Decoder) fastpathDecSliceBoolR(f *codecFnInfo, rv reflect.Value) {
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr {
		var vp = rv2i(rv).(*[]bool)
		if v, changed := fastpathTV.DecSliceBoolV(*vp, !array, d); changed {
			*vp = v
		}
	} else {
		fastpathTV.DecSliceBoolV(rv2i(rv).([]bool), !array, d)
	}
}

func (f fastpathT) DecSliceBoolX(vp *[]bool, d *Decoder) {
	if v, changed := f.DecSliceBoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecSliceBoolV(v []bool, canChange bool, d *Decoder) (_ []bool, changed bool) {
	dd := d.d

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 {
		if canChange {
			if v == nil {
				v = []bool{}
			} else if len(v) != 0 {
				v = v[:0]
			}
			changed = true
		}
		slh.End()
		return v, changed
	}

	hasLen := containerLenS > 0
	var xlen int
	if hasLen && canChange {
		if containerLenS > cap(v) {
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, 1)
			if xlen <= cap(v) {
				v = v[:xlen]
			} else {
				v = make([]bool, xlen)
			}
			changed = true
		} else if containerLenS != len(v) {
			v = v[:containerLenS]
			changed = true
		}
	}
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ {
		if j == 0 && len(v) == 0 {
			if hasLen {
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, 1)
			} else {
				xlen = 8
			}
			v = make([]bool, xlen)
			changed = true
		}
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) {
			if canChange {
				v = append(v, false)
				changed = true
			} else {
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			}
		}
		slh.ElemContainerState(j)
		if decodeIntoBlank {
			d.swallow()
		} else {
			v[j] = dd.DecodeBool()
		}
	}
	if canChange {
		if j < len(v) {
			v = v[:j]
			changed = true
		} else if j == 0 && v == nil {
			v = make([]bool, 0)
			changed = true
		}
	}
	slh.End()
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfIntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]interface{})
		if v, changed := fastpathTV.DecMapIntfIntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfIntfV(rv2i(rv).(map[interface{}]interface{}), false, d)
}
func (f fastpathT) DecMapIntfIntfX(vp *map[interface{}]interface{}, d *Decoder) {
	if v, changed := f.DecMapIntfIntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfIntfV(v map[interface{}]interface{}, canChange bool,
	d *Decoder) (_ map[interface{}]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 32)
		v = make(map[interface{}]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk interface{}
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfStringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]string)
		if v, changed := fastpathTV.DecMapIntfStringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfStringV(rv2i(rv).(map[interface{}]string), false, d)
}
func (f fastpathT) DecMapIntfStringX(vp *map[interface{}]string, d *Decoder) {
	if v, changed := f.DecMapIntfStringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfStringV(v map[interface{}]string, canChange bool,
	d *Decoder) (_ map[interface{}]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 32)
		v = make(map[interface{}]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk interface{}
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfUintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]uint)
		if v, changed := fastpathTV.DecMapIntfUintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfUintV(rv2i(rv).(map[interface{}]uint), false, d)
}
func (f fastpathT) DecMapIntfUintX(vp *map[interface{}]uint, d *Decoder) {
	if v, changed := f.DecMapIntfUintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfUintV(v map[interface{}]uint, canChange bool,
	d *Decoder) (_ map[interface{}]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[interface{}]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk interface{}
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfUint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]uint8)
		if v, changed := fastpathTV.DecMapIntfUint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfUint8V(rv2i(rv).(map[interface{}]uint8), false, d)
}
func (f fastpathT) DecMapIntfUint8X(vp *map[interface{}]uint8, d *Decoder) {
	if v, changed := f.DecMapIntfUint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfUint8V(v map[interface{}]uint8, canChange bool,
	d *Decoder) (_ map[interface{}]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 17)
		v = make(map[interface{}]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk interface{}
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfUint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]uint16)
		if v, changed := fastpathTV.DecMapIntfUint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfUint16V(rv2i(rv).(map[interface{}]uint16), false, d)
}
func (f fastpathT) DecMapIntfUint16X(vp *map[interface{}]uint16, d *Decoder) {
	if v, changed := f.DecMapIntfUint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfUint16V(v map[interface{}]uint16, canChange bool,
	d *Decoder) (_ map[interface{}]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 18)
		v = make(map[interface{}]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk interface{}
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfUint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]uint32)
		if v, changed := fastpathTV.DecMapIntfUint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfUint32V(rv2i(rv).(map[interface{}]uint32), false, d)
}
func (f fastpathT) DecMapIntfUint32X(vp *map[interface{}]uint32, d *Decoder) {
	if v, changed := f.DecMapIntfUint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfUint32V(v map[interface{}]uint32, canChange bool,
	d *Decoder) (_ map[interface{}]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 20)
		v = make(map[interface{}]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk interface{}
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfUint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]uint64)
		if v, changed := fastpathTV.DecMapIntfUint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfUint64V(rv2i(rv).(map[interface{}]uint64), false, d)
}
func (f fastpathT) DecMapIntfUint64X(vp *map[interface{}]uint64, d *Decoder) {
	if v, changed := f.DecMapIntfUint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfUint64V(v map[interface{}]uint64, canChange bool,
	d *Decoder) (_ map[interface{}]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[interface{}]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk interface{}
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfUintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]uintptr)
		if v, changed := fastpathTV.DecMapIntfUintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfUintptrV(rv2i(rv).(map[interface{}]uintptr), false, d)
}
func (f fastpathT) DecMapIntfUintptrX(vp *map[interface{}]uintptr, d *Decoder) {
	if v, changed := f.DecMapIntfUintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfUintptrV(v map[interface{}]uintptr, canChange bool,
	d *Decoder) (_ map[interface{}]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[interface{}]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk interface{}
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfIntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]int)
		if v, changed := fastpathTV.DecMapIntfIntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfIntV(rv2i(rv).(map[interface{}]int), false, d)
}
func (f fastpathT) DecMapIntfIntX(vp *map[interface{}]int, d *Decoder) {
	if v, changed := f.DecMapIntfIntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfIntV(v map[interface{}]int, canChange bool,
	d *Decoder) (_ map[interface{}]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[interface{}]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk interface{}
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfInt8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]int8)
		if v, changed := fastpathTV.DecMapIntfInt8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfInt8V(rv2i(rv).(map[interface{}]int8), false, d)
}
func (f fastpathT) DecMapIntfInt8X(vp *map[interface{}]int8, d *Decoder) {
	if v, changed := f.DecMapIntfInt8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfInt8V(v map[interface{}]int8, canChange bool,
	d *Decoder) (_ map[interface{}]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 17)
		v = make(map[interface{}]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk interface{}
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfInt16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]int16)
		if v, changed := fastpathTV.DecMapIntfInt16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfInt16V(rv2i(rv).(map[interface{}]int16), false, d)
}
func (f fastpathT) DecMapIntfInt16X(vp *map[interface{}]int16, d *Decoder) {
	if v, changed := f.DecMapIntfInt16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfInt16V(v map[interface{}]int16, canChange bool,
	d *Decoder) (_ map[interface{}]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 18)
		v = make(map[interface{}]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk interface{}
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfInt32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]int32)
		if v, changed := fastpathTV.DecMapIntfInt32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfInt32V(rv2i(rv).(map[interface{}]int32), false, d)
}
func (f fastpathT) DecMapIntfInt32X(vp *map[interface{}]int32, d *Decoder) {
	if v, changed := f.DecMapIntfInt32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfInt32V(v map[interface{}]int32, canChange bool,
	d *Decoder) (_ map[interface{}]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 20)
		v = make(map[interface{}]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk interface{}
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfInt64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]int64)
		if v, changed := fastpathTV.DecMapIntfInt64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfInt64V(rv2i(rv).(map[interface{}]int64), false, d)
}
func (f fastpathT) DecMapIntfInt64X(vp *map[interface{}]int64, d *Decoder) {
	if v, changed := f.DecMapIntfInt64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfInt64V(v map[interface{}]int64, canChange bool,
	d *Decoder) (_ map[interface{}]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[interface{}]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk interface{}
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfFloat32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]float32)
		if v, changed := fastpathTV.DecMapIntfFloat32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfFloat32V(rv2i(rv).(map[interface{}]float32), false, d)
}
func (f fastpathT) DecMapIntfFloat32X(vp *map[interface{}]float32, d *Decoder) {
	if v, changed := f.DecMapIntfFloat32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfFloat32V(v map[interface{}]float32, canChange bool,
	d *Decoder) (_ map[interface{}]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 20)
		v = make(map[interface{}]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk interface{}
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfFloat64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]float64)
		if v, changed := fastpathTV.DecMapIntfFloat64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfFloat64V(rv2i(rv).(map[interface{}]float64), false, d)
}
func (f fastpathT) DecMapIntfFloat64X(vp *map[interface{}]float64, d *Decoder) {
	if v, changed := f.DecMapIntfFloat64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfFloat64V(v map[interface{}]float64, canChange bool,
	d *Decoder) (_ map[interface{}]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[interface{}]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk interface{}
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapIntfBoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[interface{}]bool)
		if v, changed := fastpathTV.DecMapIntfBoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapIntfBoolV(rv2i(rv).(map[interface{}]bool), false, d)
}
func (f fastpathT) DecMapIntfBoolX(vp *map[interface{}]bool, d *Decoder) {
	if v, changed := f.DecMapIntfBoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapIntfBoolV(v map[interface{}]bool, canChange bool,
	d *Decoder) (_ map[interface{}]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 17)
		v = make(map[interface{}]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk interface{}
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = nil
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok {
			mk = d.string(bv)
		}
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringIntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]interface{})
		if v, changed := fastpathTV.DecMapStringIntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringIntfV(rv2i(rv).(map[string]interface{}), false, d)
}
func (f fastpathT) DecMapStringIntfX(vp *map[string]interface{}, d *Decoder) {
	if v, changed := f.DecMapStringIntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringIntfV(v map[string]interface{}, canChange bool,
	d *Decoder) (_ map[string]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 32)
		v = make(map[string]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk string
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringStringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]string)
		if v, changed := fastpathTV.DecMapStringStringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringStringV(rv2i(rv).(map[string]string), false, d)
}
func (f fastpathT) DecMapStringStringX(vp *map[string]string, d *Decoder) {
	if v, changed := f.DecMapStringStringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringStringV(v map[string]string, canChange bool,
	d *Decoder) (_ map[string]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 32)
		v = make(map[string]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk string
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringUintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]uint)
		if v, changed := fastpathTV.DecMapStringUintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringUintV(rv2i(rv).(map[string]uint), false, d)
}
func (f fastpathT) DecMapStringUintX(vp *map[string]uint, d *Decoder) {
	if v, changed := f.DecMapStringUintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringUintV(v map[string]uint, canChange bool,
	d *Decoder) (_ map[string]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[string]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk string
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringUint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]uint8)
		if v, changed := fastpathTV.DecMapStringUint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringUint8V(rv2i(rv).(map[string]uint8), false, d)
}
func (f fastpathT) DecMapStringUint8X(vp *map[string]uint8, d *Decoder) {
	if v, changed := f.DecMapStringUint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringUint8V(v map[string]uint8, canChange bool,
	d *Decoder) (_ map[string]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 17)
		v = make(map[string]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk string
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringUint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]uint16)
		if v, changed := fastpathTV.DecMapStringUint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringUint16V(rv2i(rv).(map[string]uint16), false, d)
}
func (f fastpathT) DecMapStringUint16X(vp *map[string]uint16, d *Decoder) {
	if v, changed := f.DecMapStringUint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringUint16V(v map[string]uint16, canChange bool,
	d *Decoder) (_ map[string]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 18)
		v = make(map[string]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk string
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringUint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]uint32)
		if v, changed := fastpathTV.DecMapStringUint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringUint32V(rv2i(rv).(map[string]uint32), false, d)
}
func (f fastpathT) DecMapStringUint32X(vp *map[string]uint32, d *Decoder) {
	if v, changed := f.DecMapStringUint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringUint32V(v map[string]uint32, canChange bool,
	d *Decoder) (_ map[string]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 20)
		v = make(map[string]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk string
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringUint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]uint64)
		if v, changed := fastpathTV.DecMapStringUint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringUint64V(rv2i(rv).(map[string]uint64), false, d)
}
func (f fastpathT) DecMapStringUint64X(vp *map[string]uint64, d *Decoder) {
	if v, changed := f.DecMapStringUint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringUint64V(v map[string]uint64, canChange bool,
	d *Decoder) (_ map[string]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[string]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk string
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringUintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]uintptr)
		if v, changed := fastpathTV.DecMapStringUintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringUintptrV(rv2i(rv).(map[string]uintptr), false, d)
}
func (f fastpathT) DecMapStringUintptrX(vp *map[string]uintptr, d *Decoder) {
	if v, changed := f.DecMapStringUintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringUintptrV(v map[string]uintptr, canChange bool,
	d *Decoder) (_ map[string]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[string]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk string
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringIntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]int)
		if v, changed := fastpathTV.DecMapStringIntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringIntV(rv2i(rv).(map[string]int), false, d)
}
func (f fastpathT) DecMapStringIntX(vp *map[string]int, d *Decoder) {
	if v, changed := f.DecMapStringIntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringIntV(v map[string]int, canChange bool,
	d *Decoder) (_ map[string]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[string]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk string
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringInt8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]int8)
		if v, changed := fastpathTV.DecMapStringInt8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringInt8V(rv2i(rv).(map[string]int8), false, d)
}
func (f fastpathT) DecMapStringInt8X(vp *map[string]int8, d *Decoder) {
	if v, changed := f.DecMapStringInt8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringInt8V(v map[string]int8, canChange bool,
	d *Decoder) (_ map[string]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 17)
		v = make(map[string]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk string
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringInt16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]int16)
		if v, changed := fastpathTV.DecMapStringInt16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringInt16V(rv2i(rv).(map[string]int16), false, d)
}
func (f fastpathT) DecMapStringInt16X(vp *map[string]int16, d *Decoder) {
	if v, changed := f.DecMapStringInt16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringInt16V(v map[string]int16, canChange bool,
	d *Decoder) (_ map[string]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 18)
		v = make(map[string]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk string
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringInt32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]int32)
		if v, changed := fastpathTV.DecMapStringInt32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringInt32V(rv2i(rv).(map[string]int32), false, d)
}
func (f fastpathT) DecMapStringInt32X(vp *map[string]int32, d *Decoder) {
	if v, changed := f.DecMapStringInt32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringInt32V(v map[string]int32, canChange bool,
	d *Decoder) (_ map[string]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 20)
		v = make(map[string]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk string
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringInt64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]int64)
		if v, changed := fastpathTV.DecMapStringInt64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringInt64V(rv2i(rv).(map[string]int64), false, d)
}
func (f fastpathT) DecMapStringInt64X(vp *map[string]int64, d *Decoder) {
	if v, changed := f.DecMapStringInt64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringInt64V(v map[string]int64, canChange bool,
	d *Decoder) (_ map[string]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[string]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk string
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringFloat32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]float32)
		if v, changed := fastpathTV.DecMapStringFloat32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringFloat32V(rv2i(rv).(map[string]float32), false, d)
}
func (f fastpathT) DecMapStringFloat32X(vp *map[string]float32, d *Decoder) {
	if v, changed := f.DecMapStringFloat32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringFloat32V(v map[string]float32, canChange bool,
	d *Decoder) (_ map[string]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 20)
		v = make(map[string]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk string
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringFloat64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]float64)
		if v, changed := fastpathTV.DecMapStringFloat64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringFloat64V(rv2i(rv).(map[string]float64), false, d)
}
func (f fastpathT) DecMapStringFloat64X(vp *map[string]float64, d *Decoder) {
	if v, changed := f.DecMapStringFloat64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringFloat64V(v map[string]float64, canChange bool,
	d *Decoder) (_ map[string]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[string]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk string
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapStringBoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[string]bool)
		if v, changed := fastpathTV.DecMapStringBoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapStringBoolV(rv2i(rv).(map[string]bool), false, d)
}
func (f fastpathT) DecMapStringBoolX(vp *map[string]bool, d *Decoder) {
	if v, changed := f.DecMapStringBoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapStringBoolV(v map[string]bool, canChange bool,
	d *Decoder) (_ map[string]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 17)
		v = make(map[string]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk string
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeString()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32IntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]interface{})
		if v, changed := fastpathTV.DecMapFloat32IntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32IntfV(rv2i(rv).(map[float32]interface{}), false, d)
}
func (f fastpathT) DecMapFloat32IntfX(vp *map[float32]interface{}, d *Decoder) {
	if v, changed := f.DecMapFloat32IntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32IntfV(v map[float32]interface{}, canChange bool,
	d *Decoder) (_ map[float32]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 20)
		v = make(map[float32]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk float32
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32StringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]string)
		if v, changed := fastpathTV.DecMapFloat32StringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32StringV(rv2i(rv).(map[float32]string), false, d)
}
func (f fastpathT) DecMapFloat32StringX(vp *map[float32]string, d *Decoder) {
	if v, changed := f.DecMapFloat32StringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32StringV(v map[float32]string, canChange bool,
	d *Decoder) (_ map[float32]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 20)
		v = make(map[float32]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float32
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32UintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]uint)
		if v, changed := fastpathTV.DecMapFloat32UintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32UintV(rv2i(rv).(map[float32]uint), false, d)
}
func (f fastpathT) DecMapFloat32UintX(vp *map[float32]uint, d *Decoder) {
	if v, changed := f.DecMapFloat32UintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32UintV(v map[float32]uint, canChange bool,
	d *Decoder) (_ map[float32]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[float32]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float32
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32Uint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]uint8)
		if v, changed := fastpathTV.DecMapFloat32Uint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32Uint8V(rv2i(rv).(map[float32]uint8), false, d)
}
func (f fastpathT) DecMapFloat32Uint8X(vp *map[float32]uint8, d *Decoder) {
	if v, changed := f.DecMapFloat32Uint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32Uint8V(v map[float32]uint8, canChange bool,
	d *Decoder) (_ map[float32]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[float32]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float32
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32Uint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]uint16)
		if v, changed := fastpathTV.DecMapFloat32Uint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32Uint16V(rv2i(rv).(map[float32]uint16), false, d)
}
func (f fastpathT) DecMapFloat32Uint16X(vp *map[float32]uint16, d *Decoder) {
	if v, changed := f.DecMapFloat32Uint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32Uint16V(v map[float32]uint16, canChange bool,
	d *Decoder) (_ map[float32]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 6)
		v = make(map[float32]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float32
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32Uint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]uint32)
		if v, changed := fastpathTV.DecMapFloat32Uint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32Uint32V(rv2i(rv).(map[float32]uint32), false, d)
}
func (f fastpathT) DecMapFloat32Uint32X(vp *map[float32]uint32, d *Decoder) {
	if v, changed := f.DecMapFloat32Uint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32Uint32V(v map[float32]uint32, canChange bool,
	d *Decoder) (_ map[float32]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 8)
		v = make(map[float32]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float32
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32Uint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]uint64)
		if v, changed := fastpathTV.DecMapFloat32Uint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32Uint64V(rv2i(rv).(map[float32]uint64), false, d)
}
func (f fastpathT) DecMapFloat32Uint64X(vp *map[float32]uint64, d *Decoder) {
	if v, changed := f.DecMapFloat32Uint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32Uint64V(v map[float32]uint64, canChange bool,
	d *Decoder) (_ map[float32]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[float32]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float32
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32UintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]uintptr)
		if v, changed := fastpathTV.DecMapFloat32UintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32UintptrV(rv2i(rv).(map[float32]uintptr), false, d)
}
func (f fastpathT) DecMapFloat32UintptrX(vp *map[float32]uintptr, d *Decoder) {
	if v, changed := f.DecMapFloat32UintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32UintptrV(v map[float32]uintptr, canChange bool,
	d *Decoder) (_ map[float32]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[float32]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float32
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32IntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]int)
		if v, changed := fastpathTV.DecMapFloat32IntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32IntV(rv2i(rv).(map[float32]int), false, d)
}
func (f fastpathT) DecMapFloat32IntX(vp *map[float32]int, d *Decoder) {
	if v, changed := f.DecMapFloat32IntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32IntV(v map[float32]int, canChange bool,
	d *Decoder) (_ map[float32]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[float32]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float32
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32Int8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]int8)
		if v, changed := fastpathTV.DecMapFloat32Int8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32Int8V(rv2i(rv).(map[float32]int8), false, d)
}
func (f fastpathT) DecMapFloat32Int8X(vp *map[float32]int8, d *Decoder) {
	if v, changed := f.DecMapFloat32Int8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32Int8V(v map[float32]int8, canChange bool,
	d *Decoder) (_ map[float32]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[float32]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float32
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32Int16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]int16)
		if v, changed := fastpathTV.DecMapFloat32Int16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32Int16V(rv2i(rv).(map[float32]int16), false, d)
}
func (f fastpathT) DecMapFloat32Int16X(vp *map[float32]int16, d *Decoder) {
	if v, changed := f.DecMapFloat32Int16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32Int16V(v map[float32]int16, canChange bool,
	d *Decoder) (_ map[float32]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 6)
		v = make(map[float32]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float32
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32Int32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]int32)
		if v, changed := fastpathTV.DecMapFloat32Int32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32Int32V(rv2i(rv).(map[float32]int32), false, d)
}
func (f fastpathT) DecMapFloat32Int32X(vp *map[float32]int32, d *Decoder) {
	if v, changed := f.DecMapFloat32Int32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32Int32V(v map[float32]int32, canChange bool,
	d *Decoder) (_ map[float32]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 8)
		v = make(map[float32]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float32
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32Int64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]int64)
		if v, changed := fastpathTV.DecMapFloat32Int64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32Int64V(rv2i(rv).(map[float32]int64), false, d)
}
func (f fastpathT) DecMapFloat32Int64X(vp *map[float32]int64, d *Decoder) {
	if v, changed := f.DecMapFloat32Int64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32Int64V(v map[float32]int64, canChange bool,
	d *Decoder) (_ map[float32]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[float32]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float32
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32Float32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]float32)
		if v, changed := fastpathTV.DecMapFloat32Float32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32Float32V(rv2i(rv).(map[float32]float32), false, d)
}
func (f fastpathT) DecMapFloat32Float32X(vp *map[float32]float32, d *Decoder) {
	if v, changed := f.DecMapFloat32Float32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32Float32V(v map[float32]float32, canChange bool,
	d *Decoder) (_ map[float32]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 8)
		v = make(map[float32]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float32
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32Float64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]float64)
		if v, changed := fastpathTV.DecMapFloat32Float64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32Float64V(rv2i(rv).(map[float32]float64), false, d)
}
func (f fastpathT) DecMapFloat32Float64X(vp *map[float32]float64, d *Decoder) {
	if v, changed := f.DecMapFloat32Float64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32Float64V(v map[float32]float64, canChange bool,
	d *Decoder) (_ map[float32]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[float32]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float32
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat32BoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float32]bool)
		if v, changed := fastpathTV.DecMapFloat32BoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat32BoolV(rv2i(rv).(map[float32]bool), false, d)
}
func (f fastpathT) DecMapFloat32BoolX(vp *map[float32]bool, d *Decoder) {
	if v, changed := f.DecMapFloat32BoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat32BoolV(v map[float32]bool, canChange bool,
	d *Decoder) (_ map[float32]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[float32]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk float32
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = float32(dd.DecodeFloat(true))
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapFloat64IntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[float64]interface{})
		if v, changed := fastpathTV.DecMapFloat64IntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapFloat64IntfV(rv2i(rv).(map[float64]interface{}), false, d)
}
func (f fastpathT) DecMapFloat64IntfX(vp *map[float64]interface{}, d *Decoder) {
	if v, changed := f.DecMapFloat64IntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapFloat64IntfV(v map[float64]interface{}, canChange bool,
	d *Decoder) (_ map[float64]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 24)
		v = make(map[float64]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk float64
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeFloat(false)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {€€