
Š€€€// +build !notfastpath

// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
// Use of this source code is governed by a MIT license found in the LICENSE file.

// ************************************************************
// DO NOT EDIT.
// THIS FILE IS AUTO-GENERATED from fast-path.go.tmpl
// ************************************************************

package codec

// Fast path functions try to create a fast path encode or decode implementation
// for common maps and slices.
//
// We define the functions and register then in this single file
// so as not to pollute the encode.go and decode.go, and create a dependency in there.
// This file can be omitted without causing a build failure.
//
// The advantage of fast paths is:
//    - Many calls bypass reflection altogether
//
// Currently support
//    - slice of all builtin types,
//    - map of all builtin types to string or interface value
//    - symmetrical maps of all builtin types (e.g. str-str, uint8-uint8)
// This should provide adequate "typical" implementations.
//
// Note that fast track decode functions must handle values for which an address cannot be obtained.
// For example:
//   m2 := map[string]int{}
//   p2 := []interface{}{m2}
//   // decoding into p2 will bomb if fast track functions do not treat like unaddressable.
//

import (
	"reflect"
	"sort"
)

const fastpathEnabled = true

type fastpathT struct{}

var fastpathTV fastpathT

type fastpathE struct {
	rtid  uintptr
	rt    reflect.Type
	encfn func(*Encoder, *codecFnInfo, reflect.Value)
	decfn func(*Decoder, *codecFnInfo, reflect.Value)
}

type fastpathA [271]fastpathE

func (x *fastpathA) index(rtid uintptr) int {
	// use binary search to grab the index (adapted from sort/search.go)
	h, i, j := 0, 0, 271 // len(x)
	for i < j {
		h = i + (j-i)/2
		if x[h].rtid < rtid {
			i = h + 1
		} else {
			j = h
		}
	}
	if i < 271 && x[i].rtid == rtid {
		return i
	}
	return -1
}

type fastpathAslice []fastpathE

func (x fastpathAslice) Len() int           { return len(x) }
func (x fastpathAslice) Less(i, j int) bool { return x[i].rtid < x[j].rtid }
func (x fastpathAslice) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }

var fastpathAV fastpathA

// due to possible initialization loop error, make fastpath in an init()
func init() {
	i := 0
	fn := func(v interface{},
		fe func(*Encoder, *codecFnInfo, reflect.Value),
		fd func(*Decoder, *codecFnInfo, reflect.Value)) (f fastpathE) {
		xrt := reflect.TypeOf(v)
		xptr := rt2id(xrt)
		if useLookupRecognizedTypes {
			recognizedRtids = append(recognizedRtids, xptr)
			recognizedRtidPtrs = append(recognizedRtidPtrs, rt2id(reflect.PtrTo(xrt)))
		}
		fastpathAV[i] = fastpathE{xptr, xrt, fe, fd}
		i++
		return
	}

	fn([]interface{}(nil), (*Encoder).fastpathEncSliceIntfR, (*Decoder).fastpathDecSliceIntfR)
	fn([]string(nil), (*Encoder).fastpathEncSliceStringR, (*Decoder).fastpathDecSliceStringR)
	fn([]float32(nil), (*Encoder).fastpathEncSliceFloat32R, (*Decoder).fastpathDecSliceFloat32R)
	fn([]float64(nil), (*Encoder).fastpathEncSliceFloat64R, (*Decoder).fastpathDecSliceFloat64R)
	fn([]uint(nil), (*Encoder).fastpathEncSliceUintR, (*Decoder).fastpathDecSliceUintR)
	fn([]uint16(nil), (*Encoder).fastpathEncSliceUint16R, (*Decoder).fastpathDecSliceUint16R)
	fn([]uint32(nil), (*Encoder).fastpathEncSliceUint32R, (*Decoder).fastpathDecSliceUint32R)
	fn([]uint64(nil), (*Encoder).fastpathEncSliceUint64R, (*Decoder).fastpathDecSliceUint64R)
	fn([]uintptr(nil), (*Encoder).fastpathEncSliceUintptrR, (*Decoder).fastpathDecSliceUintptrR)
	fn([]int(nil), (*Encoder).fastpathEncSliceIntR, (*Decoder).fastpathDecSliceIntR)
	fn([]int8(nil), (*Encoder).fastpathEncSliceInt8R, (*Decoder).fastpathDecSliceInt8R)
	fn([]int16(nil), (*Encoder).fastpathEncSliceInt16R, (*Decoder).fastpathDecSliceInt16R)
	fn([]int32(nil), (*Encoder).fastpathEncSliceInt32R, (*Decoder).fastpathDecSliceInt32R)
	fn([]int64(nil), (*Encoder).fastpathEncSliceInt64R, (*Decoder).fastpathDecSliceInt64R)
	fn([]bool(nil), (*Encoder).fastpathEncSliceBoolR, (*Decoder).fastpathDecSliceBoolR)

	fn(map[interface{}]interface{}(nil), (*Encoder).fastpathEncMapIntfIntfR, (*Decoder).fastpathDecMapIntfIntfR)
	fn(map[interface{}]string(nil), (*Encoder).fastpathEncMapIntfStringR, (*Decoder).fastpathDecMapIntfStringR)
	fn(map[interface{}]uint(nil), (*Encoder).fastpathEncMapIntfUintR, (*Decoder).fastpathDecMapIntfUintR)
	fn(map[interface{}]uint8(nil), (*Encoder).fastpathEncMapIntfUint8R, (*Decoder).fastpathDecMapIntfUint8R)
	fn(map[interface{}]uint16(nil), (*Encoder).fastpathEncMapIntfUint16R, (*Decoder).fastpathDecMapIntfUint16R)
	fn(map[interface{}]uint32(nil), (*Encoder).fastpathEncMapIntfUint32R, (*Decoder).fastpathDecMapIntfUint32R)
	fn(map[interface{}]uint64(nil), (*Encoder).fastpathEncMapIntfUint64R, (*Decoder).fastpathDecMapIntfUint64R)
	fn(map[interface{}]uintptr(nil), (*Encoder).fastpathEncMapIntfUintptrR, (*Decoder).fastpathDecMapIntfUintptrR)
	fn(map[interface{}]int(nil), (*Encoder).fastpathEncMapIntfIntR, (*Decoder).fastpathDecMapIntfIntR)
	fn(map[interface{}]int8(nil), (*Encoder).fastpathEncMapIntfInt8R, (*Decoder).fastpathDecMapIntfInt8R)
	fn(map[interface{}]int16(nil), (*Encoder).fastpathEncMapIntfInt16R, (*Decoder).fastpathDecMapIntfInt16R)
	fn(map[interface{}]int32(nil), (*Encoder).fastpathEncMapIntfInt32R, (*Decoder).fastpathDecMapIntfInt32R)
	fn(map[interface{}]int64(nil), (*Encoder).fastpathEncMapIntfInt64R, (*Decoder).fastpathDecMapIntfInt64R)
	fn(map[interface{}]float32(nil), (*Encoder).fastpathEncMapIntfFloat32R, (*Decoder).fastpathDecMapIntfFloat32R)
	fn(map[interface{}]float64(nil), (*Encoder).fastpathEncMapIntfFloat64R, (*Decoder).fastpathDecMapIntfFloat64R)
	fn(map[interface{}]bool(nil), (*Encoder).fastpathEncMapIntfBoolR, (*Decoder).fastpathDecMapIntfBoolR)
	fn(map[string]interface{}(nil), (*Encoder).fastpathEncMapStringIntfR, (*Decoder).fastpathDecMapStringIntfR)
	fn(map[string]string(nil), (*Encoder).fastpathEncMapStringStringR, (*Decoder).fastpathDecMapStringStringR)
	fn(map[string]uint(nil), (*Encoder).fastpathEncMapStringUintR, (*Decoder).fastpathDecMapStringUintR)
	fn(map[string]uint8(nil), (*Encoder).fastpathEncMapStringUint8R, (*Decoder).fastpathDecMapStringUint8R)
	fn(map[string]uint16(nil), (*Encoder).fastpathEncMapStringUint16R, (*Decoder).fastpathDecMapStringUint16R)
	fn(map[string]uint32(nil), (*Encoder).fastpathEncMapStringUint32R, (*Decoder).fastpathDecMapStringUint32R)
	fn(map[string]uint64(nil), (*Encoder).fastpathEncMapStringUint64R, (*Decoder).fastpathDecMapStringUint64R)
	fn(map[string]uintptr(nil), (*Encoder).fastpathEncMapStringUintptrR, (*Decoder).fastpathDecMapStringUintptrR)
	fn(map[string]int(nil), (*Encoder).fastpathEncMapStringIntR, (*Decoder).fastpathDecMapStringIntR)
	fn(map[string]int8(nil), (*Encoder).fastpathEncMapStringInt8R, (*Decoder).fastpathDecMapStringInt8R)
	fn(map[string]int16(nil), (*Encoder).fastpathEncMapStringInt16R, (*Decoder).fastpathDecMapStringInt16R)
	fn(map[string]int32(nil), (*Encoder).fastpathEncMapStringInt32R, (*Decoder).fastpathDecMapStringInt32R)
	fn(map[string]int64(nil), (*Encoder).fastpathEncMapStringInt64R, (*Decoder).fastpathDecMapStringInt64R)
	fn(map[string]float32(nil), (*Encoder).fastpathEncMapStringFloat32R, (*Decoder).fastpathDecMapStringFloat32R)
	fn(map[string]float64(nil), (*Encoder).fastpathEncMapStringFloat64R, (*Decoder).fastpathDecMapStringFloat64R)
	fn(map[string]bool(nil), (*Encoder).fastpathEncMapStringBoolR, (*Decoder).fastpathDecMapStringBoolR)
	fn(map[float32]interface{}(nil), (*Encoder).fastpathEncMapFloat32IntfR, (*Decoder).fastpathDecMapFloat32IntfR)
	fn(map[float32]string(nil), (*Encoder).fastpathEncMapFloat32StringR, (*Decoder).fastpathDecMapFloat32StringR)
	fn(map[float32]uint(nil), (*Encoder).fastpathEncMapFloat32UintR, (*Decoder).fastpathDecMapFloat32UintR)
	fn(map[float32]uint8(nil), (*Encoder).fastpathEncMapFloat32Uint8R, (*Decoder).fastpathDecMapFloat32Uint8R)
	fn(map[float32]uint16(nil), (*Encoder).fastpathEncMapFloat32Uint16R, (*Decoder).fastpathDecMapFloat32Uint16R)
	fn(map[float32]uint32(nil), (*Encoder).fastpathEncMapFloat32Uint32R, (*Decoder).fastpathDecMapFloat32Uint32R)
	fn(map[float32]uint64(nil), (*Encoder).fastpathEncMapFloat32Uint64R, (*Decoder).fastpathDecMapFloat32Uint64R)
	fn(map[float32]uintptr(nil), (*Encoder).fastpathEncMapFloat32UintptrR, (*Decoder).fastpathDecMapFloat32UintptrR)
	fn(map[float32]int(nil), (*Encoder).fastpathEncMapFloat32IntR, (*Decoder).fastpathDecMapFloat32IntR)
	fn(map[float32]int8(nil), (*Encoder).fastpathEncMapFloat32Int8R, (*Decoder).fastpathDecMapFloat32Int8R)
	fn(map[float32]int16(nil), (*Encoder).fastpathEncMapFloat32Int16R, (*Decoder).fastpathDecMapFloat32Int16R)
	fn(map[float32]int32(nil), (*Encoder).fastpathEncMapFloat32Int32R, (*Decoder).fastpathDecMapFloat32Int32R)
	fn(map[float32]int64(nil), (*Encoder).fastpathEncMapFloat32Int64R, (*Decoder).fastpathDecMapFloat32Int64R)
	fn(map[float32]float32(nil), (*Encoder).fastpathEncMapFloat32Float32R, (*Decoder).fastpathDecMapFloat32Float32R)
	fn(map[float32]float64(nil), (*Encoder).fastpathEncMapFloat32Float64R, (*Decoder).fastpathDecMapFloat32Float64R)
	fn(map[float32]bool(nil), (*Encoder).fastpathEncMapFloat32BoolR, (*Decoder).fastpathDecMapFloat32BoolR)
	fn(map[float64]interface{}(nil), (*Encoder).fastpathEncMapFloat64IntfR, (*Decoder).fastpathDecMapFloat64IntfR)
	fn(map[float64]string(nil), (*Encoder).fastpathEncMapFloat64StringR, (*Decoder).fastpathDecMapFloat64StringR)
	fn(map[float64]uint(nil), (*Encoder).fastpathEncMapFloat64UintR, (*Decoder).fastpathDecMapFloat64UintR)
	fn(map[float64]uint8(nil), (*Encoder).fastpathEncMapFloat64Uint8R, (*Decoder).fastpathDecMapFloat64Uint8R)
	fn(map[float64]uint16(nil), (*Encoder).fastpathEncMapFloat64Uint16R, (*Decoder).fastpathDecMapFloat64Uint16R)
	fn(map[float64]uint32(nil), (*Encoder).fastpathEncMapFloat64Uint32R, (*Decoder).fastpathDecMapFloat64Uint32R)
	fn(map[float64]uint64(nil), (*Encoder).fastpathEncMapFloat64Uint64R, (*Decoder).fastpathDecMapFloat64Uint64R)
	fn(map[float64]uintptr(nil), (*Encoder).fastpathEncMapFloat64UintptrR, (*Decoder).fastpathDecMapFloat64UintptrR)
	fn(map[float64]int(nil), (*Encoder).fastpathEncMapFloat64IntR, (*Decoder).fastpathDecMapFloat64IntR)
	fn(map[float64]int8(nil), (*Encoder).fastpathEncMapFloat64Int8R, (*Decoder).fastpathDecMapFloat64Int8R)
	fn(map[float64]int16(nil), (*Encoder).fastpathEncMapFloat64Int16R, (*Decoder).fastpathDecMapFloat64Int16R)
	fn(map[float64]int32(nil), (*Encoder).fastpathEncMapFloat64Int32R, (*Decoder).fastpathDecMapFloat64Int32R)
	fn(map[float64]int64(nil), (*Encoder).fastpathEncMapFloat64Int64R, (*Decoder).fastpathDecMapFloat64Int64R)
	fn(map[float64]float32(nil), (*Encoder).fastpathEncMapFloat64Float32R, (*Decoder).fastpathDecMapFloat64Float32R)
	fn(map[float64]float64(nil), (*Encoder).fastpathEncMapFloat64Float64R, (*Decoder).fastpathDecMapFloat64Float64R)
	fn(map[float64]bool(nil), (*Encoder).fastpathEncMapFloat64BoolR, (*Decoder).fastpathDecMapFloat64BoolR)
	fn(map[uint]interface{}(nil), (*Encoder).fastpathEncMapUintIntfR, (*Decoder).fastpathDecMapUintIntfR)
	fn(map[uint]string(nil), (*Encoder).fastpathEncMapUintStringR, (*Decoder).fastpathDecMapUintStringR)
	fn(map[uint]uint(nil), (*Encoder).fastpathEncMapUintUintR, (*Decoder).fastpathDecMapUintUintR)
	fn(map[uint]uint8(nil), (*Encoder).fastpathEncMapUintUint8R, (*Decoder).fastpathDecMapUintUint8R)
	fn(map[uint]uint16(nil), (*Encoder).fastpathEncMapUintUint16R, (*Decoder).fastpathDecMapUintUint16R)
	fn(map[uint]uint32(nil), (*Encoder).fastpathEncMapUintUint32R, (*Decoder).fastpathDecMapUintUint32R)
	fn(map[uint]uint64(nil), (*Encoder).fastpathEncMapUintUint64R, (*Decoder).fastpathDecMapUintUint64R)
	fn(map[uint]uintptr(nil), (*Encoder).fastpathEncMapUintUintptrR, (*Decoder).fastpathDecMapUintUintptrR)
	fn(map[uint]int(nil), (*Encoder).fastpathEncMapUintIntR, (*Decoder).fastpathDecMapUintIntR)
	fn(map[uint]int8(nil), (*Encoder).fastpathEncMapUintInt8R, (*Decoder).fastpathDecMapUintInt8R)
	fn(map[uint]int16(nil), (*Encoder).fastpathEncMapUintInt16R, (*Decoder).fastpathDecMapUintInt16R)
	fn(map[uint]int32(nil), (*Encoder).fastpathEncMapUintInt32R, (*Decoder).fastpathDecMapUintInt32R)
	fn(map[uint]int64(nil), (*Encoder).fastpathEncMapUintInt64R, (*Decoder).fastpathDecMapUintInt64R)
	fn(map[uint]float32(nil), (*Encoder).fastpathEncMapUintFloat32R, (*Decoder).fastpathDecMapUintFloat32R)
	fn(map[uint]float64(nil), (*Encoder).fastpathEncMapUintFloat64R, (*Decoder).fastpathDecMapUintFloat64R)
	fn(map[uint]bool(nil), (*Encoder).fastpathEncMapUintBoolR, (*Decoder).fastpathDecMapUintBoolR)
	fn(map[uint8]interface{}(nil), (*Encoder).fastpathEncMapUint8IntfR, (*Decoder).fastpathDecMapUint8IntfR)
	fn(map[uint8]string(nil), (*Encoder).fastpathEncMapUint8StringR, (*Decoder).fastpathDecMapUint8StringR)
	fn(map[uint8]uint(nil), (*Encoder).fastpathEncMapUint8UintR, (*Decoder).fastpathDecMapUint8UintR)
	fn(map[uint8]uint8(nil), (*Encoder).fastpathEncMapUint8Uint8R, (*Decoder).fastpathDecMapUint8Uint8R)
	fn(map[uint8]uint16(nil), (*Encoder).fastpathEncMapUint8Uint16R, (*Decoder).fastpathDecMapUint8Uint16R)
	fn(map[uint8]uint32(nil), (*Encoder).fastpathEncMapUint8Uint32R, (*Decoder).fastpathDecMapUint8Uint32R)
	fn(map[uint8]uint64(nil), (*Encoder).fastpathEncMapUint8Uint64R, (*Decoder).fastpathDecMapUint8Uint64R)
	fn(map[uint8]uintptr(nil), (*Encoder).fastpathEncMapUint8UintptrR, (*Decoder).fastpathDecMapUint8UintptrR)
	fn(map[uint8]int(nil), (*Encoder).fastpathEncMapUint8IntR, (*Decoder).fastpathDecMapUint8IntR)
	fn(map[uint8]int8(nil), (*Encoder).fastpathEncMapUint8Int8R, (*Decoder).fastpathDecMapUint8Int8R)
	fn(map[uint8]int16(nil), (*Encoder).fastpathEncMapUint8Int16R, (*Decoder).fastpathDecMapUint8Int16R)
	fn(map[uint8]int32(nil), (*Encoder).fastpathEncMapUint8Int32R, (*Decoder).fastpathDecMapUint8Int32R)
	fn(map[uint8]int64(nil), (*Encoder).fastpathEncMapUint8Int64R, (*Decoder).fastpathDecMapUint8Int64R)
	fn(map[uint8]float32(nil), (*Encoder).fastpathEncMapUint8Float32R, (*Decoder).fastpathDecMapUint8Float32R)
	fn(map[uint8]float64(nil), (*Encoder).fastpathEncMapUint8Float64R, (*Decoder).fastpathDecMapUint8Float64R)
	fn(map[uint8]bool(nil), (*Encoder).fastpathEncMapUint8BoolR, (*Decoder).fastpathDecMapUint8BoolR)
	fn(map[uint16]interface{}(nil), (*Encoder).fastpathEncMapUint16IntfR, (*Decoder).fastpathDecMapUint16IntfR)
	fn(map[uint16]string(nil), (*Encoder).fastpathEncMapUint16StringR, (*Decoder).fastpathDecMapUint16StringR)
	fn(map[uint16]uint(nil), (*Encoder).fastpathEncMapUint16UintR, (*Decoder).fastpathDecMapUint16UintR)
	fn(map[uint16]uint8(nil), (*Encoder).fastpathEncMapUint16Uint8R, (*Decoder).fastpathDecMapUint16Uint8R)
	fn(map[uint16]uint16(nil), (*Encoder).fastpathEncMapUint16Uint16R, (*Decoder).fastpathDecMapUint16Uint16R)
	fn(map[uint16]uint32(nil), (*Encoder).fastpathEncMapUint16Uint32R, (*Decoder).fastpathDecMapUint16Uint32R)
	fn(map[uint16]uint64(nil), (*Encoder).fastpathEncMapUint16Uint64R, (*Decoder).fastpathDecMapUint16Uint64R)
	fn(map[uint16]uintptr(nil), (*Encoder).fastpathEncMapUint16UintptrR, (*Decoder).fastpathDecMapUint16UintptrR)
	fn(map[uint16]int(nil), (*Encoder).fastpathEncMapUint16IntR, (*Decoder).fastpathDecMapUint16IntR)
	fn(map[uint16]int8(nil), (*Encoder).fastpathEncMapUint16Int8R, (*Decoder).fastpathDecMapUint16Int8R)
	fn(map[uint16]int16(nil), (*Encoder).fastpathEncMapUint16Int16R, (*Decoder).fastpathDecMapUint16Int16R)
	fn(map[uint16]int32(nil), (*Encoder).fastpathEncMapUint16Int32R, (*Decoder).fastpathDecMapUint16Int32R)
	fn(map[uint16]int64(nil), (*Encoder).fastpathEncMapUint16Int64R, (*Decoder).fastpathDecMapUint16Int64R)
	fn(map[uint16]float32(nil), (*Encoder).fastpathEncMapUint16Float32R, (*Decoder).fastpathDecMapUint16Float32R)
	fn(map[uint16]float64(nil), (*Encoder).fastpathEncMapUint16Float64R, (*Decoder).fastpathDecMapUint16Float64R)
	fn(map[uint16]bool(nil), (*Encoder).fastpathEncMapUint16BoolR, (*Decoder).fastpathDecMapUint16BoolR)
	fn(map[uint32]interface{}(nil), (*Encoder).fastpathEncMapUint32IntfR, (*Decoder).fastpathDecMapUint32IntfR)
	fn(map[uint32]string(nil), (*Encoder).fastpathEncMapUint32StringR, (*Decoder).fastpathDecMapUint32StringR)
	fn(map[uint32]uint(nil), (*Encoder).fastpathEncMapUint32UintR, (*Decoder).fastpathDecMapUint32UintR)
	fn(map[uint32]uint8(nil), (*Encoder).fastpathEncMapUint32Uint8R, (*Decoder).fastpathDecMapUint32Uint8R)
	fn(map[uint32]uint16(nil), (*Encoder).fastpathEncMapUint32Uint16R, (*Decoder).fastpathDecMapUint32Uint16R)
	fn(map[uint32]uint32(nil), (*Encoder).fastpathEncMapUint32Uint32R, (*Decoder).fastpathDecMapUint32Uint32R)
	fn(map[uint32]uint64(nil), (*Encoder).fastpathEncMapUint32Uint64R, (*Decoder).fastpathDecMapUint32Uint64R)
	fn(map[uint32]uintptr(nil), (*Encoder).fastpathEncMapUint32UintptrR, (*Decoder).fastpathDecMapUint32UintptrR)
	fn(map[uint32]int(nil), (*Encoder).fastpathEncMapUint32IntR, (*Decoder).fastpathDecMapUint32IntR)
	fn(map[uint32]int8(nil), (*Encoder).fastpathEncMapUint32Int8R, (*Decoder).fastpathDecMapUint32Int8R)
	fn(map[uint32]int16(nil), (*Encoder).fastpathEncMapUint32Int16R, (*Decoder).fastpathDecMapUint32Int16R)
	fn(map[uint32]int32(nil), (*Encoder).fastpathEncMapUint32Int32R, (*Decoder).fastpathDecMapUint32Int32R)
	fn(map[uint32]int64(nil), (*Encoder).fastpathEncMapUint32Int64R, (*Decoder).fastpathDecMapUint32Int64R)
	fn(map[uint32]float32(nil), (*Encoder).fastpathEncMapUint32Float32R, (*Decoder).fastpathDecMapUint32Float32R)
	fn(map[uint32]float64(nil), (*Encoder).fastpathEncMapUint32Float64R, (*Decoder).fastpathDecMapUint32Float64R)
	fn(map[uint32]bool(nil), (*Encoder).fastpathEncMapUint32BoolR, (*Decoder).fastpathDecMapUint32BoolR)
	fn(map[uint64]interface{}(nil), (*Encoder).fastpathEncMapUint64IntfR, (*Decoder).fastpathDecMapUint64IntfR)
	fn(map[uint64]string(nil), (*Encoder).fastpathEncMapUint64StringR, (*Decoder).fastpathDecMapUint64StringR)
	fn(map[uint64]uint(nil), (*Encoder).fastpathEncMapUint64UintR, (*Decoder).fastpathDecMapUint64UintR)
	fn(map[uint64]uint8(nil), (*Encoder).fastpathEncMapUint64Uint8R, (*Decoder).fastpathDecMapUint64Uint8R)
	fn(map[uint64]uint16(nil), (*Encoder).fastpathEncMapUint64Uint16R, (*Decoder).fastpathDecMapUint64Uint16R)
	fn(map[uint64]uint32(nil), (*Encoder).fastpathEncMapUint64Uint32R, (*Decoder).fastpathDecMapUint64Uint32R)
	fn(map[uint64]uint64(nil), (*Encoder).fastpathEncMapUint64Uint64R, (*Decoder).fastpathDecMapUint64Uint64R)
	fn(map[uint64]uintptr(nil), (*Encoder).fastpathEncMapUint64UintptrR, (*Decoder).fastpathDecMapUint64UintptrR)
	fn(map[uint64]int(nil), (*Encoder).fastpathEncMapUint64IntR, (*Decoder).fastpathDecMapUint64IntR)
	fn(map[uint64]int8(nil), (*Encoder).fastpathEncMapUint64Int8R, (*Decoder).fastpathDecMapUint64Int8R)
	fn(map[uint64]int16(nil), (*Encoder).fastpathEncMapUint64Int16R, (*Decoder).fastpathDecMapUint64Int16R)
	fn(map[uint64]int32(nil), (*Encoder).fastpathEncMapUint64Int32R, (*Decoder).fastpathDecMapUint64Int32R)
	fn(map[uint64]int64(nil), (*Encoder).fastpathEncMapUint64Int64R, (*Decoder).fastpathDecMapUint64Int64R)
	fn(map[uint64]float32(nil), (*Encoder).fastpathEncMapUint64Float32R, (*Decoder).fastpathDecMapUint64Float32R)
	fn(map[uint64]float64(nil), (*Encoder).fastpathEncMapUint64Float64R, (*Decoder).fastpathDecMapUint64Float64R)
	fn(map[uint64]bool(nil), (*Encoder).fastpathEncMapUint64BoolR, (*Decoder).fastpathDecMapUint64BoolR)
	fn(map[uintptr]interface{}(nil), (*Encoder).fastpathEncMapUintptrIntfR, (*Decoder).fastpathDecMapUintptrIntfR)
	fn(map[uintptr]string(nil), (*Encoder).fastpathEncMapUintptrStringR, (*Decoder).fastpathDecMapUintptrStringR)
	fn(map[uintptr]uint(nil), (*Encoder).fastpathEncMapUintptrUintR, (*Decoder).fastpathDecMapUintptrUintR)
	fn(map[uintptr]uint8(nil), (*Encoder).fastpathEncMapUintptrUint8R, (*Decoder).fastpathDecMapUintptrUint8R)
	fn(map[uintptr]uint16(nil), (*Encoder).fastpathEncMapUintptrUint16R, (*Decoder).fastpathDecMapUintptrUint16R)
	fn(map[uintptr]uint32(nil), (*Encoder).fastpathEncMapUintptrUint32R, (*Decoder).fastpathDecMapUintptrUint32R)
	fn(map[uintptr]uint64(nil), (*Encoder).fastpathEncMapUintptrUint64R, (*Decoder).fastpathDecMapUintptrUint64R)
	fn(map[uintptr]uintptr(nil), (*Encoder).fastpathEncMapUintptrUintptrR, (*Decoder).fastpathDecMapUintptrUintptrR)
	fn(map[uintptr]int(nil), (*Encoder).fastpathEncMapUintptrIntR, (*Decoder).fastpathDecMapUintptrIntR)
	fn(map[uintptr]int8(nil), (*Encoder).fastpathEncMapUintptrInt8R, (*Decoder).fastpathDecMapUintptrInt8R)
	fn(map[uintptr]int16(nil), (*Encoder).fastpathEncMapUintptrInt16R, (*Decoder).fastpathDecMapUintptrInt16R)
	fn(map[uintptr]int32(nil), (*Encoder).fastpathEncMapUintptrInt32R, (*Decoder).fastpathDecMapUintptrInt32R)
	fn(map[uintptr]int64(nil), (*Encoder).fastpathEncMapUintptrInt64R, (*Decoder).fastpathDecMapUintptrInt64R)
	fn(map[uintptr]float32(nil), (*Encoder).fastpathEncMapUintptrFloat32R, (*Decoder).fastpathDecMapUintptrFloat32R)
	fn(map[uintptr]float64(nil), (*Encoder).fastpathEncMapUintptrFloat64R, (*Decoder).fastpathDecMapUintptrFloat64R)
	fn(map[uintptr]bool(nil), (*Encoder).fastpathEncMapUintptrBoolR, (*Decoder).fastpathDecMapUintptrBoolR)
	fn(map[int]interface{}(nil), (*Encoder).fastpathEncMapIntIntfR, (*Decoder).fastpathDecMapIntIntfR)
	fn(map[int]string(nil), (*Encoder).fastpathEncMapIntStringR, (*Decoder).fastpathDecMapIntStringR)
	fn(map[int]uint(nil), (*Encoder).fastpathEncMapIntUintR, (*Decoder).fastpathDecMapIntUintR)
	fn(map[int]uint8(nil), (*Encoder).fastpathEncMapIntUint8R, (*Decoder).fastpathDecMapIntUint8R)
	fn(map[int]uint16(nil), (*Encoder).fastpathEncMapIntUint16R, (*Decoder).fastpathDecMapIntUint16R)
	fn(map[int]uint32(nil), (*Encoder).fastpathEncMapIntUint32R, (*Decoder).fastpathDecMapIntUint32R)
	fn(map[int]uint64(nil), (*Encoder).fastpathEncMapIntUint64R, (*Decoder).fastpathDecMapIntUint64R)
	fn(map[int]uintptr(nil), (*Encoder).fastpathEncMapIntUintptrR, (*Decoder).fastpathDecMapIntUintptrR)
	fn(map[int]int(nil), (*Encoder).fastpathEncMapIntIntR, (*Decoder).fastpathDecMapIntIntR)
	fn(map[int]int8(nil), (*Encoder).fastpathEncMapIntInt8R, (*Decoder).fastpathDecMapIntInt8R)
	fn(map[int]int16(nil), (*Encoder).fastpathEncMapIntInt16R, (*Decoder).fastpathDecMapIntInt16R)
	fn(map[int]int32(nil), (*Encoder).fastpathEncMapIntInt32R, (*Decoder).fastpathDecMapIntInt32R)
	fn(map[int]int64(nil), (*Encoder).fastpathEncMapIntInt64R, (*Decoder).fastpathDecMapIntInt64R)
	fn(map[int]float32(nil), (*Encoder).fastpathEncMapIntFloat32R, (*Decoder).fastpathDecMapIntFloat32R)
	fn(map[int]float64(nil), (*Encoder).fastpathEncMapIntFloat64R, (*Decoder).fastpathDecMapIntFloat64R)
	fn(map[int]bool(nil), (*Encoder).fastpathEncMapIntBoolR, (*Decoder).fastpathDecMapIntBoolR)
	fn(map[int8]interface{}(nil), (*Encoder).fastpathEncMapInt8IntfR, (*Decoder).fastpathDecMapInt8IntfR)
	fn(map[int8]string(nil), (*Encoder).fastpathEncMapInt8StringR, (*Decoder).fastpathDecMapInt8StringR)
	fn(map[int8]uint(nil), (*Encoder).fastpathEncMapInt8UintR, (*Decoder).fastpathDecMapInt8UintR)
	fn(map[int8]uint8(nil), (*Encoder).fastpathEncMapInt8Uint8R, (*Decoder).fastpathDecMapInt8Uint8R)
	fn(map[int8]uint16(nil), (*Encoder).fastpathEncMapInt8Uint16R, (*Decoder).fastpathDecMapInt8Uint16R)
	fn(map[int8]uint32(nil), (*Encoder).fastpathEncMapInt8Uint32R, (*Decoder).fastpathDecMapInt8Uint32R)
	fn(map[int8]uint64(nil), (*Encoder).fastpathEncMapInt8Uint64R, (*Decoder).fastpathDecMapInt8Uint64R)
	fn(map[int8]uintptr(nil), (*Encoder).fastpathEncMapInt8UintptrR, (*Decoder).fastpathDecMapInt8UintptrR)
	fn(map[int8]int(nil), (*Encoder).fastpathEncMapInt8IntR, (*Decoder).fastpathDecMapInt8IntR)
	fn(map[int8]int8(nil), (*Encoder).fastpathEncMapInt8Int8R, (*Decoder).fastpathDecMapInt8Int8R)
	fn(map[int8]int16(nil), (*Encoder).fastpathEncMapInt8Int16R, (*Decoder).fastpathDecMapInt8Int16R)
	fn(map[int8]int32(nil), (*Encoder).fastpathEncMapInt8Int32R, (*Decoder).fastpathDecMapInt8Int32R)
	fn(map[int8]int64(nil), (*Encoder).fastpathEncMapInt8Int64R, (*Decoder).fastpathDecMapInt8Int64R)
	fn(map[int8]float32(nil), (*Encoder).fastpathEncMapInt8Float32R, (*Decoder).fastpathDecMapInt8Float32R)
	fn(map[int8]float64(nil), (*Encoder).fastpathEncMapInt8Float64R, (*Decoder).fastpathDecMapInt8Float64R)
	fn(map[int8]bool(nil), (*Encoder).fastpathEncMapInt8BoolR, (*Decoder).fastpathDecMapInt8BoolR)
	fn(map[int16]interface{}(nil), (*Encoder).fastpathEncMapInt16IntfR, (*Decoder).fastpathDecMapInt16IntfR)
	fn(map[int16]string(nil), (*Encoder).fastpathEncMapInt16StringR, (*Decoder).fastpathDecMapInt16StringR)
	fn(map[int16]uint(nil), (*Encoder).fastpathEncMapInt16UintR, (*Decoder).fastpathDecMapInt16UintR)
	fn(map[int16]uint8(nil), (*Encoder).fastpathEncMapInt16Uint8R, (*Decoder).fastpathDecMapInt16Uint8R)
	fn(map[int16]uint16(nil), (*Encoder).fastpathEncMapInt16Uint16R, (*Decoder).fastpathDecMapInt16Uint16R)
	fn(map[int16]uint32(nil), (*Encoder).fastpathEncMapInt16Uint32R, (*Decoder).fastpathDecMapInt16Uint32R)
	fn(map[int16]uint64(nil), (*Encoder).fastpathEncMapInt16Uint64R, (*Decoder).fastpathDecMapInt16Uint64R)
	fn(map[int16]uintptr(nil), (*Encoder).fastpathEncMapInt16UintptrR, (*Decoder).fastpathDecMapInt16UintptrR)
	fn(map[int16]int(nil), (*Encoder).fastpathEncMapInt16IntR, (*Decoder).fastpathDecMapInt16IntR)
	fn(map[int16]int8(nil), (*Encoder).fastpathEncMapInt16Int8R, (*Decoder).fastpathDecMapInt16Int8R)
	fn(map[int16]int16(nil), (*Encoder).fastpathEncMapInt16Int16R, (*Decoder).fastpathDecMapInt16Int16R)
	fn(map[int16]int32(nil), (*Encoder).fastpathEncMapInt16Int32R, (*Decoder).fastpathDecMapInt16Int32R)
	fn(map[int16]int64(nil), (*Encoder).fastpathEncMapInt16Int64R, (*Decoder).fastpathDecMapInt16Int64R)
	fn(map[int16]float32(nil), (*Encoder).fastpathEncMapInt16Float32R, (*Decoder).fastpathDecMapInt16Float32R)
	fn(map[int16]float64(nil), (*Encoder).fastpathEncMapInt16Float64R, (*Decoder).fastpathDecMapInt16Float64R)
	fn(map[int16]bool(nil), (*Encoder).fastpathEncMapInt16BoolR, (*Decoder).fastpathDecMapInt16BoolR)
	fn(map[int32]interface{}(nil), (*Encoder).fastpathEncMapInt32IntfR, (*Decoder).fastpathDecMapInt32IntfR)
	fn(map[int32]string(nil), (*Encoder).fastpathEncMapInt32StringR, (*Decoder).fastpathDecMapInt32StringR)
	fn(map[int32]uint(nil), (*Encoder).fastpathEncMapInt32UintR, (*Decoder).fastpathDecMapInt32UintR)
	fn(map[int32]uint8(nil), (*Encoder).fastpathEncMapInt32Uint8R, (*Decoder).fastpathDecMapInt32Uint8R)
	fn(map[int32]uint16(nil), (*Encoder).fastpathEncMapInt32Uint16R, (*Decoder).fastpathDecMapInt32Uint16R)
	fn(map[int32]uint32(nil), (*Encoder).fastpathEncMapInt32Uint32R, (*Decoder).fastpathDecMapInt32Uint32R)
	fn(map[int32]uint64(nil), (*Encoder).fastpathEncMapInt32Uint64R, (*Decoder).fastpathDecMapInt32Uint64R)
	fn(map[int32]uintptr(nil), (*Encoder).fastpathEncMapInt32UintptrR, (*Decoder).fastpathDecMapInt32UintptrR)
	fn(map[int32]int(nil), (*Encoder).fastpathEncMapInt32IntR, (*Decoder).fastpathDecMapInt32IntR)
	fn(map[int32]int8(nil), (*Encoder).fastpathEncMapInt32Int8R, (*Decoder).fastpathDecMapInt32Int8R)
	fn(map[int32]int16(nil), (*Encoder).fastpathEncMapInt32Int16R, (*Decoder).fastpathDecMapInt32Int16R)
	fn(map[int32]int32(nil), (*Encoder).fastpathEncMapInt32Int32R, (*Decoder).fastpathDecMapInt32Int32R)
	fn(map[int32]int64(nil), (*Encoder).fastpathEncMapInt32Int64R, (*Decoder).fastpathDecMapInt32Int64R)
	fn(map[int32]float32(nil), (*Encoder).fastpathEncMapInt32Float32R, (*Decoder).fastpathDecMapInt32Float32R)
	fn(map[int32]float64(nil), (*Encoder).fastpathEncMapInt32Float64R, (*Decoder).fastpathDecMapInt32Float64R)
	fn(map[int32]bool(nil), (*Encoder).fastpathEncMapInt32BoolR, (*Decoder).fastpathDecMapInt32BoolR)
	fn(map[int64]interface{}(nil), (*Encoder).fastpathEncMapInt64IntfR, (*Decoder).fastpathDecMapInt64IntfR)
	fn(map[int64]string(nil), (*Encoder).fastpathEncMapInt64StringR, (*Decoder).fastpathDecMapInt64StringR)
	fn(map[int64]uint(nil), (*Encoder).fastpathEncMapInt64UintR, (*Decoder).fastpathDecMapInt64UintR)
	fn(map[int64]uint8(nil), (*Encoder).fastpathEncMapInt64Uint8R, (*Decoder).fastpathDecMapInt64Uint8R)
	fn(map[int64]uint16(nil), (*Encoder).fastpathEncMapInt64Uint16R, (*Decoder).fastpathDecMapInt64Uint16R)
	fn(map[int64]uint32(nil), (*Encoder).fastpathEncMapInt64Uint32R, (*Decoder).fastpathDecMapInt64Uint32R)
	fn(map[int64]uint64(nil), (*Encoder).fastpathEncMapInt64Uint64R, (*Decoder).fastpathDecMapInt64Uint64R)
	fn(map[int64]uintptr(nil), (*Encoder).fastpathEncMapInt64UintptrR, (*Decoder).fastpathDecMapInt64UintptrR)
	fn(map[int64]int(nil), (*Encoder).fastpathEncMapInt64IntR, (*Decoder).fastpathDecMapInt64IntR)
	fn(map[int64]int8(nil), (*Encoder).fastpathEncMapInt64Int8R, (*Decoder).fastpathDecMapInt64Int8R)
	fn(map[int64]int16(nil), (*Encoder).fastpathEncMapInt64Int16R, (*Decoder).fastpathDecMapInt64Int16R)
	fn(map[int64]int32(nil), (*Encoder).fastpathEncMapInt64Int32R, (*Decoder).fastpathDecMapInt64Int32R)
	fn(map[int64]int64(nil), (*Encoder).fastpathEncMapInt64Int64R, (*Decoder).fastpathDecMapInt64Int64R)
	fn(map[int64]float32(nil), (*Encoder).fastpathEncMapInt64Float32R, (*Decoder).fastpathDecMapInt64Float32R)
	fn(map[int64]float64(nil), (*Encoder).fastpathEncMapInt64Float64R, (*Decoder).fastpathDecMapInt64Float64R)
	fn(map[int64]bool(nil), (*Encoder).fastpathEncMapInt64BoolR, (*Decoder).fastpathDecMapInt64BoolR)
	fn(map[bool]interface{}(nil), (*Encoder).fastpathEncMapBoolIntfR, (*Decoder).fastpathDecMapBoolIntfR)
	fn(map[bool]string(nil), (*Encoder).fastpathEncMapBoolStringR, (*Decoder).fastpathDecMapBoolStringR)
	fn(map[bool]uint(nil), (*Encoder).fastpathEncMapBoolUintR, (*Decoder).fastpathDecMapBoolUintR)
	fn(map[bool]uint8(nil), (*Encoder).fastpathEncMapBoolUint8R, (*Decoder).fastpathDecMapBoolUint8R)
	fn(map[bool]uint16(nil), (*Encoder).fastpathEncMapBoolUint16R, (*Decoder).fastpathDecMapBoolUint16R)
	fn(map[bool]uint32(nil), (*Encoder).fastpathEncMapBoolUint32R, (*Decoder).fastpathDecMapBoolUint32R)
	fn(map[bool]uint64(nil), (*Encoder).fastpathEncMapBoolUint64R, (*Decoder).fastpathDecMapBoolUint64R)
	fn(map[bool]uintptr(nil), (*Encoder).fastpathEncMapBoolUintptrR, (*Decoder).fastpathDecMapBoolUintptrR)
	fn(map[bool]int(nil), (*Encoder).fastpathEncMapBoolIntR, (*Decoder).fastpathDecMapBoolIntR)
	fn(map[bool]int8(nil), (*Encoder).fastpathEncMapBoolInt8R, (*Decoder).fastpathDecMapBoolInt8R)
	fn(map[bool]int16(nil), (*Encoder).fastpathEncMapBoolInt16R, (*Decoder).fastpathDecMapBoolInt16R)
	fn(map[bool]int32(nil), (*Encoder).fastpathEncMapBoolInt32R, (*Decoder).fastpathDecMapBoolInt32R)
	fn(map[bool]int64(nil), (*Encoder).fastpathEncMapBoolInt64R, (*Decoder).fastpathDecMapBoolInt64R)
	fn(map[bool]float32(nil), (*Encoder).fastpathEncMapBoolFloat32R, (*Decoder).fastpathDecMapBoolFloat32R)
	fn(map[bool]float64(nil), (*Encoder).fastpathEncMapBoolFloat64R, (*Decoder).fastpathDecMapBoolFloat64R)
	fn(map[bool]bool(nil), (*Encoder).fastpathEncMapBoolBoolR, (*Decoder).fastpathDecMapBoolBoolR)

	sort.Sort(fastpathAslice(fastpathAV[:]))
}

// -- encode

// -- -- fast path type switch
func fastpathEncodeTypeSwitch(iv interface{}, e *Encoder) bool {
	switch v := iv.(type) {

	case []interface{}:
		fastpathTV.EncSliceIntfV(v, e)
	case *[]interface{}:
		fastpathTV.EncSliceIntfV(*v, e)

	case map[interface{}]interface{}:
		fastpathTV.EncMapIntfIntfV(v, e)
	case *map[interface{}]interface{}:
		fastpathTV.EncMapIntfIntfV(*v, e)

	case map[interface{}]string:
		fastpathTV.EncMapIntfStringV(v, e)
	case *map[interface{}]string:
		fastpathTV.EncMapIntfStringV(*v, e)

	case map[interface{}]uint:
		fastpathTV.EncMapIntfUintV(v, e)
	case *map[interface{}]uint:
		fastpathTV.EncMapIntfUintV(*v, e)

	case map[interface{}]uint8:
		fastpathTV.EncMapIntfUint8V(v, e)
	case *map[interface{}]uint8:
		fastpathTV.EncMapIntfUint8V(*v, e)

	case map[interface{}]uint16:
		fastpathTV.EncMapIntfUint16V(v, e)
	case *map[interface{}]uint16:
		fastpathTV.EncMapIntfUint16V(*v, e)

	case map[interface{}]uint32:
		fastpathTV.EncMapIntfUint32V(v, e)
	case *map[interface{}]uint32:
		fastpathTV.EncMapIntfUint32V(*v, e)

	case map[interface{}]uint64:
		fastpathTV.EncMapIntfUint64V(v, e)
	case *map[interface{}]uint64:
		fastpathTV.EncMapIntfUint64V(*v, e)

	case map[interface{}]uintptr:
		fastpathTV.EncMapIntfUintptrV(v, e)
	case *map[interface{}]uintptr:
		fastpathTV.EncMapIntfUintptrV(*v, e)

	case map[interface{}]int:
		fastpathTV.EncMapIntfIntV(v, e)
	case *map[interface{}]int:
		fastpathTV.EncMapIntfIntV(*v, e)

	case map[interface{}]int8:
		fastpathTV.EncMapIntfInt8V(v, e)
	case *map[interface{}]int8:
		fastpathTV.EncMapIntfInt8V(*v, e)

	case map[interface{}]int16:
		fastpathTV.EncMapIntfInt16V(v, e)
	case *map[interface{}]int16:
		fastpathTV.EncMapIntfInt16V(*v, e)

	case map[interface{}]int32:
		fastpathTV.EncMapIntfInt32V(v, e)
	case *map[interface{}]int32:
		fastpathTV.EncMapIntfInt32V(*v, e)

	case map[interface{}]int64:
		fastpathTV.EncMapIntfInt64V(v, e)
	case *map[interface{}]int64:
		fastpathTV.EncMapIntfInt64V(*v, e)

	case map[interface{}]float32:
		fastpathTV.EncMapIntfFloat32V(v, e)
	case *map[interface{}]float32:
		fastpathTV.EncMapIntfFloat32V(*v, e)

	case map[interface{}]float64:
		fastpathTV.EncMapIntfFloat64V(v, e)
	case *map[interface{}]float64:
		fastpathTV.EncMapIntfFloat64V(*v, e)

	case map[interface{}]bool:
		fastpathTV.EncMapIntfBoolV(v, e)
	case *map[interface{}]bool:
		fastpathTV.EncMapIntfBoolV(*v, e)

	case []string:
		fastpathTV.EncSliceStringV(v, e)
	case *[]string:
		fastpathTV.EncSliceStringV(*v, e)

	case map[string]interface{}:
		fastpathTV.EncMapStringIntfV(v, e)
	case *map[string]interface{}:
		fastpathTV.EncMapStringIntfV(*v, e)

	case map[string]string:
		fastpathTV.EncMapStringStringV(v, e)
	case *map[string]string:
		fastpathTV.EncMapStringStringV(*v, e)

	case map[string]uint:
		fastpathTV.EncMapStringUintV(v, e)
	case *map[string]uint:
		fastpathTV.EncMapStringUintV(*v, e)

	case map[string]uint8:
		fastpathTV.EncMapStringUint8V(v, e)
	case *map[string]uint8:
		fastpathTV.EncMapStringUint8V(*v, e)

	case map[string]uint16:
		fastpathTV.EncMapStringUint16V(v, e)
	case *map[string]uint16:
		fastpathTV.EncMapStringUint16V(*v, e)

	case map[string]uint32:
		fastpathTV.EncMapStringUint32V(v, e)
	case *map[string]uint32:
		fastpathTV.EncMapStringUint32V(*v, e)

	case map[string]uint64:
		fastpathTV.EncMapStringUint64V(v, e)
	case *map[string]uint64:
		fastpathTV.EncMapStringUint64V(*v, e)

	case map[string]uintptr:
		fastpathTV.EncMapStringUintptrV(v, e)
	case *map[string]uintptr:
		fastpathTV.EncMapStringUintptrV(*v, e)

	case map[string]int:
		fastpathTV.EncMapStringIntV(v, e)
	case *map[string]int:
		fastpathTV.EncMapStringIntV(*v, e)

	case map[string]int8:
		fastpathTV.EncMapStringInt8V(v, e)
	case *map[string]int8:
		fastpathTV.EncMapStringInt8V(*v, e)

	case map[string]int16:
		fastpathTV.EncMapStringInt16V(v, e)
	case *map[string]int16:
		fastpathTV.EncMapStringInt16V(*v, e)

	case map[string]int32:
		fastpathTV.EncMapStringInt32V(v, e)
	case *map[string]int32:
		fastpathTV.EncMapStringInt32V(*v, e)

	case map[string]int64:
		fastpathTV.EncMapStringInt64V(v, e)
	case *map[string]int64:
		fastpathTV.EncMapStringInt64V(*v, e)

	case map[string]float32:
		fastpathTV.EncMapStringFloat32V(v, e)
	case *map[string]float32:
		fastpathTV.EncMapStringFloat32V(*v, e)

	case map[string]float64:
		fastpathTV.EncMapStringFloat64V(v, e)
	case *map[string]float64:
		fastpathTV.EncMapStringFloat64V(*v, e)

	case map[string]bool:
		fastpathTV.EncMapStringBoolV(v, e)
	case *map[string]bool:
		fastpathTV.EncMapStringBoolV(*v, e)

	case []float32:
		fastpathTV.EncSliceFloat32V(v, e)
	case *[]float32:
		fastpathTV.EncSliceFloat32V(*v, e)

	case map[float32]interface{}:
		fastpathTV.EncMapFloat32IntfV(v, e)
	case *map[float32]interface{}:
		fastpathTV.EncMapFloat32IntfV(*v, e)

	case map[float32]string:
		fastpathTV.EncMapFloat32StringV(v, e)
	case *map[float32]string:
		fastpathTV.EncMapFloat32StringV(*v, e)

	case map[float32]uint:
		fastpathTV.EncMapFloat32UintV(v, e)
	case *map[float32]uint:
		fastpathTV.EncMapFloat32UintV(*v, e)

	case map[float32]uint8:
		fastpathTV.EncMapFloat32Uint8V(v, e)
	case *map[float32]uint8:
		fastpathTV.EncMapFloat32Uint8V(*v, e)

	case map[float32]uint16:
		fastpathTV.EncMapFloat32Uint16V(v, e)
	case *map[float32]uint16:
		fastpathTV.EncMapFloat32Uint16V(*v, e)

	case map[float32]uint32:
		fastpathTV.EncMapFloat32Uint32V(v, e)
	case *map[float32]uint32:
		fastpathTV.EncMapFloat32Uint32V(*v, e)

	case map[float32]uint64:
		fastpathTV.EncMapFloat32Uint64V(v, e)
	case *map[float32]uint64:
		fastpathTV.EncMapFloat32Uint64V(*v, e)

	case map[float32]uintptr:
		fastpathTV.EncMapFloat32UintptrV(v, e)
	case *map[float32]uintptr:
		fastpathTV.EncMapFloat32UintptrV(*v, e)

	case map[float32]int:
		fastpathTV.EncMapFloat32IntV(v, e)
	case *map[float32]int:
		fastpathTV.EncMapFloat32IntV(*v, e)

	case map[float32]int8:
		fastpathTV.EncMapFloat32Int8V(v, e)
	case *map[float32]int8:
		fastpathTV.EncMapFloat32Int8V(*v, e)

	case map[float32]int16:
		fastpathTV.EncMapFloat32Int16V(v, e)
	case *map[float32]int16:
		fastpathTV.EncMapFloat32Int16V(*v, e)

	case map[float32]int32:
		fastpathTV.EncMapFloat32Int32V(v, e)
	case *map[float32]int32:
		fastpathTV.EncMapFloat32Int32V(*v, e)

	case map[float32]int64:
		fastpathTV.EncMapFloat32Int64V(v, e)
	case *map[float32]int64:
		fastpathTV.EncMapFloat32Int64V(*v, e)

	case map[float32]float32:
		fastpathTV.EncMapFloat32Float32V(v, e)
	case *map[float32]float32:
		fastpathTV.EncMapFloat32Float32V(*v, e)

	case map[float32]float64:
		fastpathTV.EncMapFloat32Float64V(v, e)
	case *map[float32]float64:
		fastpathTV.EncMapFloat32Float64V(*v, e)

	case map[float32]bool:
		fastpathTV.EncMapFloat32BoolV(v, e)
	case *map[float32]bool:
		fastpathTV.EncMapFloat32BoolV(*v, e)

	case []float64:
		fastpathTV.EncSliceFloat64V(v, e)
	case *[]float64:
		fastpathTV.EncSliceFloat64V(*v, e)

	case map[float64]interface{}:
		fastpathTV.EncMapFloat64IntfV(v, e)
	case *map[float64]interface{}:
		fastpathTV.EncMapFloat64IntfV(*v, e)

	case map[float64]string:
		fastpathTV.EncMapFloat64StringV(v, e)
	case *map[float64]string:
		fastpathTV.EncMapFloat64StringV(*v, e)

	case map[float64]uint:
		fastpathTV.EncMapFloat64UintV(v, e)
	case *map[float64]uint:
		fastpathTV.EncMapFloat64UintV(*v, e)

	case map[float64]uint8:
		fastpathTV.EncMapFloat64Uint8V(v, e)
	case *map[float64]uint8:
		fastpathTV.EncMapFloat64Uint8V(*v, e)

	case map[float64]uint16:
		fastpathTV.EncMapFloat64Uint16V(v, e)
	case *map[float64]uint16:
		fastpathTV.EncMapFloat64Uint16V(*v, e)

	case map[float64]uint32:
		fastpathTV.EncMapFloat64Uint32V(v, e)
	case *map[float64]uint32:
		fastpathTV.EncMapFloat64Uint32V(*v, e)

	case map[float64]uint64:
		fastpathTV.EncMapFloat64Uint64V(v, e)
	case *map[float64]uint64:
		fastpathTV.EncMapFloat64Uint64V(*v, e)

	case map[float64]uintptr:
		fastpathTV.EncMapFloat64UintptrV(v, e)
	case *map[float64]uintptr:
		fastpathTV.EncMapFloat64UintptrV(*v, e)

	case map[float64]int:
		fastpathTV.EncMapFloat64IntV(v, e)
	case *map[float64]int:
		fastpathTV.EncMapFloat64IntV(*v, e)

	case map[float64]int8:
		fastpathTV.EncMapFloat64Int8V(v, e)
	case *map[float64]int8:
		fastpathTV.EncMapFloat64Int8V(*v, e)

	case map[float64]int16:
		fastpathTV.EncMapFloat64Int16V(v, e)
	case *map[float64]int16:
		fastpathTV.EncMapFloat64Int16V(*v, e)

	case map[float64]int32:
		fastpathTV.EncMapFloat64Int32V(v, e)
	case *map[float64]int32:
		fastpathTV.EncMapFloat64Int32V(*v, e)

	case map[float64]int64:
		fastpathTV.EncMapFloat64Int64V(v, e)
	case *map[float64]int64:
		fastpathTV.EncMapFloat64Int64V(*v, e)

	case map[float64]float32:
		fastpathTV.EncMapFloat64Float32V(v, e)
	case *map[float64]float32:
		fastpathTV.EncMapFloat64Float32V(*v, e)

	case map[float64]float64:
		fastpathTV.EncMapFloat64Float64V(v, e)
	case *map[float64]float64:
		fastpathTV.EncMapFloat64Float64V(*v, e)

	case map[float64]bool:
		fastpathTV.EncMapFloat64BoolV(v, e)
	case *map[float64]bool:
		fastpathTV.EncMapFloat64BoolV(*v, e)

	case []uint:
		fastpathTV.EncSliceUintV(v, e)
	case *[]uint:
		fastpathTV.EncSliceUintV(*v, e)

	case map[uint]interface{}:
		fastpathTV.EncMapUintIntfV(v, e)
	case *map[uint]interface{}:
		fastpathTV.EncMapUintIntfV(*v, e)

	case map[uint]string:
		fastpathTV.EncMapUintStringV(v, e)
	case *map[uint]string:
		fastpathTV.EncMapUintStringV(*v, e)

	case map[uint]uint:
		fastpathTV.EncMapUintUintV(v, e)
	case *map[uint]uint:
		fastpathTV.EncMapUintUintV(*v, e)

	case map[uint]uint8:
		fastpathTV.EncMapUintUint8V(v, e)
	case *map[uint]uint8:
		fastpathTV.EncMapUintUint8V(*v, e)

	case map[uint]uint16:
		fastpathTV.EncMapUintUint16V(v, e)
	case *map[uint]uint16:
		fastpathTV.EncMapUintUint16V(*v, e)

	case map[uint]uint32:
		fastpathTV.EncMapUintUint32V(v, e)
	case *map[uint]uint32:
		fastpathTV.EncMapUintUint32V(*v, e)

	case map[uint]uint64:
		fastpathTV.EncMapUintUint64V(v, e)
	case *map[uint]uint64:
		fastpathTV.EncMapUintUint64V(*v, e)

	case map[uint]uintptr:
		fastpathTV.EncMapUintUintptrV(v, e)
	case *map[uint]uintptr:
		fastpathTV.EncMapUintUintptrV(*v, e)

	case map[uint]int:
		fastpathTV.EncMapUintIntV(v, e)
	case *map[uint]int:
		fastpathTV.EncMapUintIntV(*v, e)

	case map[uint]int8:
		fastpathTV.EncMapUintInt8V(v, e)
	case *map[uint]int8:
		fastpathTV.EncMapUintInt8V(*v, e)

	case map[uint]int16:
		fastpathTV.EncMapUintInt16V(v, e)
	case *map[uint]int16:
		fastpathTV.EncMapUintInt16V(*v, e)

	case map[uint]int32:
		fastpathTV.EncMapUintInt32V(v, e)
	case *map[uint]int32:
		fastpathTV.EncMapUintInt32V(*v, e)

	case map[uint]int64:
		fastpathTV.EncMapUintInt64V(v, e)
	case *map[uint]int64:
		fastpathTV.EncMapUintInt64V(*v, e)

	case map[uint]float32:
		fastpathTV.EncMapUintFloat32V(v, e)
	case *map[uint]float32:
		fastpathTV.EncMapUintFloat32V(*v, e)

	case map[uint]float64:
		fastpathTV.EncMapUintFloat64V(v, e)
	case *map[uint]float64:
		fastpathTV.EncMapUintFloat64V(*v, e)

	case map[uint]bool:
		fastpathTV.EncMapUintBoolV(v, e)
	case *map[uint]bool:
		fastpathTV.EncMapUintBoolV(*v, e)

	case map[uint8]interface{}:
		fastpathTV.EncMapUint8IntfV(v, e)
	case *map[uint8]interface{}:
		fastpathTV.EncMapUint8IntfV(*v, e)

	case map[uint8]string:
		fastpathTV.EncMapUint8StringV(v, e)
	case *map[uint8]string:
		fastpathTV.EncMapUint8StringV(*v, e)

	case map[uint8]uint:
		fastpathTV.EncMapUint8UintV(v, e)
	case *map[uint8]uint:
		fastpathTV.EncMapUint8UintV(*v, e)

	case map[uint8]uint8:
		fastpathTV.EncMapUint8Uint8V(v, e)
	case *map[uint8]uint8:
		fastpathTV.EncMapUint8Uint8V(*v, e)

	case map[uint8]uint16:
		fastpathTV.EncMapUint8Uint16V(v, e)
	case *map[uint8]uint16:
		fastpathTV.EncMapUint8Uint16V(*v, e)

	case map[uint8]uint32:
		fastpathTV.EncMapUint8Uint32V(v, e)
	case *map[uint8]uint32:
		fastpathTV.EncMapUint8Uint32V(*v, e)

	case map[uint8]uint64:
		fastpathTV.EncMapUint8Uint64V(v, e)
	case *map[uint8]uint64:
		fastpathTV.EncMapUint8Uint64V(*v, e)

	case map[uint8]uintptr:
		fastpathTV.EncMapUint8UintptrV(v, e)
	case *map[uint8]uintptr:
		fastpathTV.EncMapUint8UintptrV(*v, e)

	case map[uint8]int:
		fastpathTV.EncMapUint8IntV(v, e)
	case *map[uint8]int:
		fastpathTV.EncMapUint8IntV(*v, e)

	case map[uint8]int8:
		fastpathTV.EncMapUint8Int8V(v, e)
	case *map[uint8]int8:
		fastpathTV.EncMapUint8Int8V(*v, e)

	case map[uint8]int16:
		fastpathTV.EncMapUint8Int16V(v, e)
	case *map[uint8]int16:
		fastpathTV.EncMapUint8Int16V(*v, e)

	case map[uint8]int32:
		fastpathTV.EncMapUint8Int32V(v, e)
	case *map[uint8]int32:
		fastpathTV.EncMapUint8Int32V(*v, e)

	case map[uint8]int64:
		fastpathTV.EncMapUint8Int64V(v, e)
	case *map[uint8]int64:
		fastpathTV.EncMapUint8Int64V(*v, e)

	case map[uint8]float32:
		fastpathTV.EncMapUint8Float32V(v, e)
	case *map[uint8]float32:
		fastpathTV.EncMapUint8Float32V(*v, e)

	case map[uint8]float64:
		fastpathTV.EncMapUint8Float64V(v, e)
	case *map[uint8]float64:
		fastpathTV.EncMapUint8Float64V(*v, e)

	case map[uint8]bool:
		fastpathTV.EncMapUint8BoolV(v, e)
	case *map[uint8]bool:
		fastpathTV.EncMapUint8BoolV(*v, e)

	case []uint16:
		fastpathTV.EncSliceUint16V(v, e)
	case *[]uint16:
		fastpathTV.EncSliceUint16V(*v, e)

	case map[uint16]interface{}:
		fastpathTV.EncMapUint16IntfV(v, e)
	case *map[uint16]interface{}:
		fastpathTV.EncMapUint16IntfV(*v, e)

	case map[uint16]string:
		fastpathTV.EncMapUint16StringV(v, e)
	case *map[uint16]string:
		fastpathTV.EncMapUint16StringV(*v, e)

	case map[uint16]uint:
		fastpathTV.EncMapUint16UintV(v, e)
	case *map[uint16]uint:
		fastpathTV.EncMapUint16UintV(*v, e)

	case map[uint16]uint8:
		fastpathTV.EncMapUint16Uint8V(v, e)
	case *map[uint16]uint8:
		fastpathTV.EncMapUint16Uint8V(*v, e)

	case map[uint16]uint16:
		fastpathTV.EncMapUint16Uint16V(v, e)
	case *map[uint16]uint16:
		fastpathTV.EncMapUint16Uint16V(*v, e)

	case map[uint16]uint32:
		fastpathTV.EncMapUint16Uint32V(v, e)
	case *map[uint16]uint32:
		fastpathTV.EncMapUint16Uint32V(*v, e)

	case map[uint16]uint64:
		fastpathTV.EncMapUint16Uint64V(v, e)
	case *map[uint16]uint64:
		fastpathTV.EncMapUint16Uint64V(*v, e)

	case map[uint16]uintptr:
		fastpathTV.EncMapUint16UintptrV(v, e)
	case *map[uint16]uintptr:
		fastpathTV.EncMapUint16UintptrV(*v, e)

	case map[uint16]int:
		fastpathTV.EncMapUint16IntV(v, e)
	case *map[uint16]int:
		fastpathTV.EncMapUint16IntV(*v, e)

	case map[uint16]int8:
		fastpathTV.EncMapUint16Int8V(v, e)
	case *map[uint16]int8:
		fastpathTV.EncMapUint16Int8V(*v, e)

	case map[uint16]int16:
		fastpathTV.EncMapUint16Int16V(v, e)
	case *map[uint16]int16:
		fastpathTV.EncMapUint16Int16V(*v, e)

	case map[uint16]int32:
		fastpathTV.EncMapUint16Int32V(v, e)
	case *map[uint16]int32:
		fastpathTV.EncMapUint16Int32V(*v, e)

	case map[uint16]int64:
		fastpathTV.EncMapUint16Int64V(v, e)
	case *map[uint16]int64:
		fastpathTV.EncMapUint16Int64V(*v, e)

	case map[uint16]float32:
		fastpathTV.EncMapUint16Float32V(v, e)
	case *map[uint16]float32:
		fastpathTV.EncMapUint16Float32V(*v, e)

	case map[uint16]float64:
		fastpathTV.EncMapUint16Float64V(v, e)
	case *map[uint16]float64:
		fastpathTV.EncMapUint16Float64V(*v, e)

	case map[uint16]bool:
		fastpathTV.EncMapUint16BoolV(v, e)
	case *map[uint16]bool:
		fastpathTV.EncMapUint16BoolV(*v, e)

	case []uint32:
		fastpathTV.EncSliceUint32V(v, e)
	case *[]uint32:
		fastpathTV.EncSliceUint32V(*v, e)

	case map[uint32]interface{}:
		fastpathTV.EncMapUint32IntfV(v, e)
	case *map[uint32]interface{}:
		fastpathTV.EncMapUint32IntfV(*v, e)

	case map[uint32]string:
		fastpathTV.EncMapUint32StringV(v, e)
	case *map[uint32]string:
		fastpathTV.EncMapUint32StringV(*v, e)

	case map[uint32]uint:
		fastpathTV.EncMapUint32UintV(v, e)
	case *map[uint32]uint:
		fastpathTV.EncMapUint32UintV(*v, e)

	case map[uint32]uint8:
		fastpathTV.EncMapUint32Uint8V(v, e)
	case *map[uint32]uint8:
		fastpathTV.EncMapUint32Uint8V(*v, e)

	case map[uint32]uint16:
		fastpathTV.EncMapUint32Uint16V(v, e)
	case *map[uint32]uint16:
		fastpathTV.EncMapUint32Uint16V(*v, e)

	case map[uint32]uint32:
		fastpathTV.EncMapUint32Uint32V(v, e)
	case *map[uint32]uint32:
		fastpathTV.EncMapUint32Uint32V(*v, e)

	case map[uint32]uint64:
		fastpathTV.EncMapUint32Uint64V(v, e)
	case *map[uint32]uint64:
		fastpathTV.EncMapUint32Uint64V(*v, e)

	case map[uint32]uintptr:
		fastpathTV.EncMapUint32UintptrV(v, e)
	case *map[uint32]uintptr:
		fastpathTV.EncMapUint32UintptrV(*v, e)

	case map[uint32]int:
		fastpathTV.EncMapUint32IntV(v, e)
	case *map[uint32]int:
		fastpathTV.EncMapUint32IntV(*v, e)

	case map[uint32]int8:
		fastpathTV.EncMapUint32Int8V(v, e)
	case *map[uint32]int8:
		fastpathTV.EncMapUint32Int8V(*v, e)

	case map[uint32]int16:
		fastpathTV.EncMapUint32Int16V(v, e)
	case *map[uint32]int16:
		fastpathTV.EncMapUint32Int16V(*v, e)

	case map[uint32]int32:
		fastpathTV.EncMapUint32Int32V(v, e)
	case *map[uint32]int32:
		fastpathTV.EncMapUint32Int32V(*v, e)

	case map[uint32]int64:
		fastpathTV.EncMapUint32Int64V(v, e)
	case *map[uint32]int64:
		fastpathTV.EncMapUint32Int64V(*v, e)

	case map[uint32]float32:
		fastpathTV.EncMapUint32Float32V(v, e)
	case *map[uint32]float32:
		fastpathTV.EncMapUint32Float32V(*v, e)

	case map[uint32]float64:
		fastpathTV.EncMapUint32Float64V(v, e)
	case *map[uint32]float64:
		fastpathTV.EncMapUint32Float64V(*v, e)

	case map[uint32]bool:
		fastpathTV.EncMapUint32BoolV(v, e)
	case *map[uint32]bool:
		fastpathTV.EncMapUint32BoolV(*v, e)

	case []uint64:
		fastpathTV.EncSliceUint64V(v, e)
	case *[]uint64:
		fastpathTV.EncSliceUint64V(*v, e)

	case map[uint64]interface{}:
		fastpathTV.EncMapUint64IntfV(v, e)
	case *map[uint64]interface{}:
		fastpathTV.EncMapUint64IntfV(*v, e)

	case map[uint64]string:
		fastpathTV.EncMapUint64StringV(v, e)
	case *map[uint64]string:
		fastpathTV.EncMapUint64StringV(*v, e)

	case map[uint64]uint:
		fastpathTV.EncMapUint64UintV(v, e)
	case *map[uint64]uint:
		fastpathTV.EncMapUint64UintV(*v, e)

	case map[uint64]uint8:
		fastpathTV.EncMapUint64Uint8V(v, e)
	case *map[uint64]uint8:
		fastpathTV.EncMapUint64Uint8V(*v, e)

	case map[uint64]uint16:
		fastpathTV.EncMapUint64Uint16V(v, e)
	case *map[uint64]uint16:
		fastpathTV.EncMapUint64Uint16V(*v, e)

	case map[uint64]uint32:
		fastpathTV.EncMapUint64Uint32V(v, e)
	case *map[uint64]uint32:
		fastpathTV.EncMapUint64Uint32V(*v, e)

	case map[uint64]uint64:
		fastpathTV.EncMapUint64Uint64V(v, e)
	case *map[uint64]uint64:
		fastpathTV.EncMapUint64Uint64V(*v, e)

	case map[uint64]uintptr:
		fastpathTV.EncMapUint64UintptrV(v, e)
	case *map[uint64]uintptr:
		fastpathTV.EncMapUint64UintptrV(*v, e)

	case map[uint64]int:
		fastpathTV.EncMapUint64IntV(v, e)
	case *map[uint64]int:
		fastpathTV.EncMapUint64IntV(*v, e)

	case map[uint64]int8:
		fastpathTV.EncMapUint64Int8V(v, e)
	case *map[uint64]int8:
		fastpathTV.EncMapUint64Int8V(*v, e)

	case map[uint64]int16:
		fastpathTV.EncMapUint64Int16V(v, e)
	case *map[uint64]int16:
		fastpathTV.EncMapUint64Int16V(*v, e)

	case map[uint64]int32:
		fastpathTV.EncMapUint64Int32V(v, e)
	case *map[uint64]int32:
		fastpathTV.EncMapUint64Int32V(*v, e)

	case map[uint64]int64:
		fastpathTV.EncMapUint64Int64V(v, e)
	case *map[uint64]int64:
		fastpathTV.EncMapUint64Int64V(*v, e)

	case map[uint64]float32:
		fastpathTV.EncMapUint64Float32V(v, e)
	case *map[uint64]float32:
		fastpathTV.EncMapUint64Float32V(*v, e)

	case map[uint64]float64:
		fastpathTV.EncMapUint64Float64V(v, e)
	case *map[uint64]float64:
		fastpathTV.EncMapUint64Float64V(*v, e)

	case map[uint64]bool:
		fastpathTV.EncMapUint64BoolV(v, e)
	case *map[uint64]bool:
		fastpathTV.EncMapUint64BoolV(*v, e)

	case []uintptr:
		fastpathTV.EncSliceUintptrV(v, e)
	case *[]uintptr:
		fastpathTV.EncSliceUintptrV(*v, e)

	case map[uintptr]interface{}:
		fastpathTV.EncMapUintptrIntfV(v, e)
	case *map[uintptr]interface{}:
		fastpathTV.EncMapUintptrIntfV(*v, e)

	case map[uintptr]string:
		fastpathTV.EncMapUintptrStringV(v, e)
	case *map[uintptr]string:
		fastpathTV.EncMapUintptrStringV(*v, e)

	case map[uintptr]uint:
		fastpathTV.EncMapUintptrUintV(v, e)
	case *map[uintptr]uint:
		fastpathTV.EncMapUintptrUintV(*v, e)

	case map[uintptr]uint8:
		fastpathTV.EncMapUintptrUint8V(v, e)
	case *map[uintptr]uint8:
		fastpathTV.EncMapUintptrUint8V(*v, e)

	case map[uintptr]uint16:
		fastpathTV.EncMapUintptrUint16V(v, e)
	case *map[uintptr]uint16:
		fastpathTV.EncMapUintptrUint16V(*v, e)

	case map[uintptr]uint32:
		fastpathTV.EncMapUintptrUint32V(v, e)
	case *map[uintptr]uint32:
		fastpathTV.EncMapUintptrUint32V(*v, e)

	case map[uintptr]uint64:
		fastpathTV.EncMapUintptrUint64V(v, e)
	case *map[uintptr]uint64:
		fastpathTV.EncMapUintptrUint64V(*v, e)

	case map[uintptr]uintptr:
		fastpathTV.EncMapUintptrUintptrV(v, e)
	case *map[uintptr]uintptr:
		fastpathTV.EncMapUintptrUintptrV(*v, e)

	case map[uintptr]int:
		fastpathTV.EncMapUintptrIntV(v, e)
	case *map[uintptr]int:
		fastpathTV.EncMapUintptrIntV(*v, e)

	case map[uintptr]int8:
		fastpathTV.EncMapUintptrInt8V(v, e)
	case *map[uintptr]int8:
		fastpathTV.EncMapUintptrInt8V(*v, e)

	case map[uintptr]int16:
		fastpathTV.EncMapUintptrInt16V(v, e)
	case *map[uintptr]int16:
		fastpathTV.EncMapUintptrInt16V(*v, e)

	case map[uintptr]int32:
		fastpathTV.EncMapUintptrInt32V(v, e)
	case *map[uintptr]int32:
		fastpathTV.EncMapUintptrInt32V(*v, e)

	case map[uintptr]int64:
		fastpathTV.EncMapUintptrInt64V(v, e)
	case *map[uintptr]int64:
		fastpathTV.EncMapUintptrInt64V(*v, e)

	case map[uintptr]float32:
		fastpathTV.EncMapUintptrFloat32V(v, e)
	case *map[uintptr]float32:
		fastpathTV.EncMapUintptrFloat32V(*v, e)

	case map[uintptr]float64:
		fastpathTV.EncMapUintptrFloat64V(v, e)
	case *map[uintptr]float64:
		fastpathTV.EncMapUintptrFloat64V(*v, e)

	case map[uintptr]bool:
		fastpathTV.EncMapUintptrBoolV(v, e)
	case *map[uintptr]bool:
		fastpathTV.EncMapUintptrBoolV(*v, e)

	case []int:
		fastpathTV.EncSliceIntV(v, e)
	case *[]int:
		fastpathTV.EncSliceIntV(*v, e)

	case map[int]interface{}:
		fastpathTV.EncMapIntIntfV(v, e)
	case *map[int]interface{}:
		fastpathTV.EncMapIntIntfV(*v, e)

	case map[int]string:
		fastpathTV.EncMapIntStringV(v, e)
	case *map[int]string:
		fastpathTV.EncMapIntStringV(*v, e)

	case map[int]uint:
		fastpathTV.EncMapIntUintV(v, e)
	case *map[int]uint:
		fastpathTV.EncMapIntUintV(*v, e)

	case map[int]uint8:
		fastpathTV.EncMapIntUint8V(v, e)
	case *map[int]uint8:
		fastpathTV.EncMapIntUint8V(*v, e)

	case map[int]uint16:
		fastpathTV.EncMapIntUint16V(v, e)
	case *map[int]uint16:
		fastpathTV.EncMapIntUint16V(*v, e)

	case map[int]uint32:
		fastpathTV.EncMapIntUint32V(v, e)
	case *map[int]uint32:
		fastpathTV.EncMapIntUint32V(*v, e)

	case map[int]uint64:
		fastpathTV.EncMapIntUint64V(v, e)
	case *map[int]uint64:
		fastpathTV.EncMapIntUint64V(*v, e)

	case map[int]uintptr:
		fastpathTV.EncMapIntUintptrV(v, e)
	case *map[int]uintptr:
		fastpathTV.EncMapIntUintptrV(*v, e)

	case map[int]int:
		fastpathTV.EncMapIntIntV(v, e)
	case *map[int]int:
		fastpathTV.EncMapIntIntV(*v, e)

	case map[int]int8:
		fastpathTV.EncMapIntInt8V(v, e)
	case *map[int]int8:
		fastpathTV.EncMapIntInt8V(*v, e)

	case map[int]int16:
		fastpathTV.EncMapIntInt16V(v, e)
	case *map[int]int16:
		fastpathTV.EncMapIntInt16V(*v, e)

	case map[int]int32:
		fastpathTV.EncMapIntInt32V(v, e)
	case *map[int]int32:
		fastpathTV.EncMapIntInt32V(*v, e)

	case map[int]int64:
		fastpathTV.EncMapIntInt64V(v, e)
	case *map[int]int64:
		fastpathTV.EncMapIntInt64V(*v, e)

	case map[int]float32:
		fastpathTV.EncMapIntFloat32V(v, e)
	case *map[int]float32:
		fastpathTV.EncMapIntFloat32V(*v, e)

	case map[int]float64:
		fastpathTV.EncMapIntFloat64V(v, e)
	case *map[int]float64:
		fastpathTV.EncMapIntFloat64V(*v, e)

	case map[int]bool:
		fastpathTV.EncMapIntBoolV(v, e)
	case *map[int]bool:
		fastpathTV.EncMapIntBoolV(*v, e)

	case []int8:
		fastpathTV.EncSliceInt8V(v, e)
	case *[]int8:
		fastpathTV.EncSliceInt8V(*v, e)

	case map[int8]interface{}:
		fastpathTV.EncMapInt8IntfV(v, e)
	case *map[int8]interface{}:
		fastpathTV.EncMapInt8IntfV(*v, e)

	case map[int8]string:
		fastpathTV.EncMapInt8StringV(v, e)
	case *map[int8]string:
		fastpathTV.EncMapInt8StringV(*v, e)

	case map[int8]uint:
		fastpathTV.EncMapInt8UintV(v, e)
	case *map[int8]uint:
		fastpathTV.EncMapInt8UintV(*v, e)

	case map[int8]uint8:
		fastpathTV.EncMapInt8Uint8V(v, e)
	case *map[int8]uint8:
		fastpathTV.EncMapInt8Uint8V(*v, e)

	case map[int8]uint16:
		fastpathTV.EncMapInt8Uint16V(v, e)
	case *map[int8]uint16:
		fastpathTV.EncMapInt8Uint16V(*v, e)

	case map[int8]uint32:
		fastpathTV.EncMapInt8Uint32V(v, e)
	case *map[int8]uint32:
		fastpathTV.EncMapInt8Uint32V(*v, e)

	case map[int8]uint64:
		fastpathTV.EncMapInt8Uint64V(v, e)
	case *map[int8]uint64:
		fastpathTV.EncMapInt8Uint64V(*v, e)

	case map[int8]uintptr:
		fastpathTV.EncMapInt8UintptrV(v, e)
	case *map[int8]uintptr:
		fastpathTV.EncMapInt8UintptrV(*v, e)

	case map[int8]int:
		fastpathTV.EncMapInt8IntV(v, e)
	case *map[int8]int:
		fastpathTV.EncMapInt8IntV(*v, e)

	case map[int8]int8:
		fastpathTV.EncMapInt8Int8V(v, e)
	case *map[int8]int8:
		fastpathTV.EncMapInt8Int8V(*v, e)

	case map[int8]int16:
		fastpathTV.EncMapInt8Int16V(v, e)
	case *map[int8]int16:
		fastpathTV.EncMapInt8Int16V(*v, e)

	case map[int8]int32:
		fastpathTV.EncMapInt8Int32V(v, e)
	case *map[int8]int32:
		fastpathTV.EncMapInt8Int32V(*v, e)

	case map[int8]int64:
		fastpathTV.EncMapInt8Int64V(v, e)
	case *map[int8]int64:
		fastpathTV.EncMapInt8Int64V(*v, e)

	case map[int8]float32:
		fastpathTV.EncMapInt8Float32V(v, e)
	case *map[int8]float32:
		fastpathTV.EncMapInt8Float32V(*v, e)

	case map[int8]float64:
		fastpathTV.EncMapInt8Float64V(v, e)
	case *map[int8]float64:
		fastpathTV.EncMapInt8Float64V(*v, e)

	case map[int8]bool:
		fastpathTV.EncMapInt8BoolV(v, e)
	case *map[int8]bool:
		fastpathTV.EncMapInt8BoolV(*v, e)

	case []int16:
		fastpathTV.EncSliceInt16V(v, e)
	case *[]int16:
		fastpathTV.EncSliceInt16V(*v, e)

	case map[int16]interface{}:
		fastpathTV.EncMapInt16IntfV(v, e)
	case *map[int16]interface{}:
		fastpathTV.EncMapInt16IntfV(*v, e)

	case map[int16]string:
		fastpathTV.EncMapInt16StringV(v, e)
	case *map[int16]string:
		fastpathTV.EncMapInt16StringV(*v, e)

	case map[int16]uint:
		fastpathTV.EncMapInt16UintV(v, e)
	case *map[int16]uint:
		fastpathTV.EncMapInt16UintV(*v, e)

	case map[int16]uint8:
		fastpathTV.EncMapInt16Uint8V(v, e)
	case *map[int16]uint8:
		fastpathTV.EncMapInt16Uint8V(*v, e)

	case map[int16]uint16:
		fastpathTV.EncMapInt16Uint16V(v, e)
	case *map[int16]uint16:
		fastpathTV.EncMapInt16Uint16V(*v, e)

	case map[int16]uint32:
		fastpathTV.EncMapInt16Uint32V(v, e)
	case *map[int16]uint32:
		fastpathTV.EncMapInt16Uint32V(*v, e)

	case map[int16]uint64:
		fastpathTV.EncMapInt16Uint64V(v, e)
	case *map[int16]uint64:
		fastpathTV.EncMapInt16Uint64V(*v, e)

	case map[int16]uintptr:
		fastpathTV.EncMapInt16UintptrV(v, e)
	case *map[int16]uintptr:
		fastpathTV.EncMapInt16UintptrV(*v, e)

	case map[int16]int:
		fastpathTV.EncMapInt16IntV(v, e)
	case *map[int16]int:
		fastpathTV.EncMapInt16IntV(*v, e)

	case map[int16]int8:
		fastpathTV.EncMapInt16Int8V(v, e)
	case *map[int16]int8:
		fastpathTV.EncMapInt16Int8V(*v, e)

	case map[int16]int16:
		fastpathTV.EncMapInt16Int16V(v, e)
	case *map[int16]int16:
		fastpathTV.EncMapInt16Int16V(*v, e)

	case map[int16]int32:
		fastpathTV.EncMapInt16Int32V(v, e)
	case *map[int16]int32:
		fastpathTV.EncMapInt16Int32V(*v, e)

	case map[int16]int64:
		fastpathTV.EncMapInt16Int64V(v, e)
	case *map[int16]int64:
		fastpathTV.EncMapInt16Int64V(*v, e)

	case map[int16]float32:
		fastpathTV.EncMapInt16Float32V(v, e)
	case *map[int16]float32:
		fastpathTV.EncMapInt16Float32V(*v, e)

	case map[int16]float64:
		fastpathTV.EncMapInt16Float64V(v, e)
	case *map[int16]float64:
		fastpathTV.EncMapInt16Float64V(*v, e)

	case map[int16]bool:
		fastpathTV.EncMapInt16BoolV(v, e)
	case *map[int16]bool:
		fastpathTV.EncMapInt16BoolV(*v, e)

	case []int32:
		fastpathTV.EncSliceInt32V(v, e)
	case *[]int32:
		fastpathTV.EncSliceInt32V(*v, e)

	case map[int32]interface{}:
		fastpathTV.EncMapInt32IntfV(v, e)
	case *map[int32]interface{}:
		fastpathTV.EncMapInt32IntfV(*v, e)

	case map[int32]string:
		fastpathTV.EncMapInt32StringV(v, e)
	case *map[int32]string:
		fastpathTV.EncMapInt32StringV(*v, e)

	case map[int32]uint:
		fastpathTV.EncMapInt32UintV(v, e)
	case *map[int32]uint:
		fastpathTV.EncMapInt32UintV(*v, e)

	case map[int32]uint8:
		fastpathTV.EncMapInt32Uint8V(v, e)
	case *map[int32]uint8:
		fastpathTV.EncMapInt32Uint8V(*v, e)

	case map[int32]uint16:
		fastpathTV.EncMapInt32Uint16V(v, e)
	case *map[int32]uint16:
		fastpathTV.EncMapInt32Uint16V(*v, e)

	case map[int32]uint32:
		fastpathTV.EncMapInt32Uint32V(v, e)
	case *map[int32]uint32:
		fastpathTV.EncMapInt32Uint32V(*v, e)

	case map[int32]uint64:
		fastpathTV.EncMapInt32Uint64V(v, e)
	case *map[int32]uint64:
		fastpathTV.EncMapInt32Uint64V(*v, e)

	case map[int32]uintptr:
		fastpathTV.EncMapInt32UintptrV(v, e)
	case *map[int32]uintptr:
		fastpathTV.EncMapInt32UintptrV(*v, e)

	case map[int32]int:
		fastpathTV.EncMapInt32IntV(v, e)
	case *map[int32]int:
		fastpathTV.EncMapInt32IntV(*v, e)

	case map[int32]int8:
		fastpathTV.EncMapInt32Int8V(v, e)
	case *map[int32]int8:
		fastpathTV.EncMapInt32Int8V(*v, e)

	case map[int32]int16:
		fastpathTV.EncMapInt32Int16V(v, e)
	case *map[int32]int16:
		fastpathTV.EncMapInt32Int16V(*v, e)

	case map[int32]int32:
		fastpathTV.EncMapInt32Int32V(v, e)
	case *map[int32]int32:
		fastpathTV.EncMapInt32Int32V(*v, e)

	case map[int32]int64:
		fastpathTV.EncMapInt32Int64V(v, e)
	case *map[int32]int64:
		fastpathTV.EncMapInt32Int64V(*v, e)

	case map[int32]float32:
		fastpathTV.EncMapInt32Float32V(v, e)
	case *map[int32]float32:
		fastpathTV.EncMapInt32Float32V(*v, e)

	case map[int32]float64:
		fastpathTV.EncMapInt32Float64V(v, e)
	case *map[int32]float64:
		fastpathTV.EncMapInt32Float64V(*v, e)

	case map[int32]bool:
		fastpathTV.EncMapInt32BoolV(v, e)
	case *map[int32]bool:
		fastpathTV.EncMapInt32BoolV(*v, e)

	case []int64:
		fastpathTV.EncSliceInt64V(v, e)
	case *[]int64:
		fastpathTV.EncSliceInt64V(*v, e)

	case map[int64]interface{}:
		fastpathTV.EncMapInt64IntfV(v, e)
	case *map[int64]interface{}:
		fastpathTV.EncMapInt64IntfV(*v, e)

	case map[int64]string:
		fastpathTV.EncMapInt64StringV(v, e)
	case *map[int64]string:
		fastpathTV.EncMapInt64StringV(*v, e)

	case map[int64]uint:
		fastpathTV.EncMapInt64UintV(v, e)
	case *map[int64]uint:
		fastpathTV.EncMapInt64UintV(*v, e)

	case map[int64]uint8:
		fastpathTV.EncMapInt64Uint8V(v, e)
	case *map[int64]uint8:
		fastpathTV.EncMapInt64Uint8V(*v, e)

	case map[int64]uint16:
		fastpathTV.EncMapInt64Uint16V(v, e)
	case *map[int64]uint16:
		fastpathTV.EncMapInt64Uint16V(*v, e)

	case map[int64]uint32:
		fastpathTV.EncMapInt64Uint32V(v, e)
	case *map[int64]uint32:
		fastpathTV.EncMapInt64Uint32V(*v, e)

	case map[int64]uint64:
		fastpathTV.EncMapInt64Uint64V(v, e)
	case *map[int64]uint64:
		fastpathTV.EncMapInt64Uint64V(*v, e)

	case map[int64]uintptr:
		fastpathTV.EncMapInt64UintptrV(v, e)
	case *map[int64]uintptr:
		fastpathTV.EncMapInt64UintptrV(*v, e)

	case map[int64]int:
		fastpathTV.EncMapInt64IntV(v, e)
	case *map[int64]int:
		fastpathTV.EncMapInt64IntV(*v, e)

	case map[int64]int8:
		fastpathTV.EncMapInt64Int8V(v, e)
	case *map[int64]int8:
		fastpathTV.EncMapInt64Int8V(*v, e)

	case map[int64]int16:
		fastpathTV.EncMapInt64Int16V(v, e)
	case *map[int64]int16:
		fastpathTV.EncMapInt64Int16V(*v, e)

	case map[int64]int32:
		fastpathTV.EncMapInt64Int32V(v, e)
	case *map[int64]int32:
		fastpathTV.EncMapInt64Int32V(*v, e)

	case map[int64]int64:
		fastpathTV.EncMapInt64Int64V(v, e)
	case *map[int64]int64:
		fastpathTV.EncMapInt64Int64V(*v, e)

	case map[int64]float32:
		fastpathTV.EncMapInt64Float32V(v, e)
	case *map[int64]float32:
		fastpathTV.EncMapInt64Float32V(*v, e)

	case map[int64]float64:
		fastpathTV.EncMapInt64Float64V(v, e)
	case *map[int64]float64:
		fastpathTV.EncMapInt64Float64V(*v, e)

	case map[int64]bool:
		fastpathTV.EncMapInt64BoolV(v, e)
	case *map[int64]bool:
		fastpathTV.EncMapInt64BoolV(*v, e)

	case []bool:
		fastpathTV.EncSliceBoolV(v, e)
	case *[]bool:
		fastpathTV.EncSliceBoolV(*v, e)

	case map[bool]interface{}:
		fastpathTV.EncMapBoolIntfV(v, e)
	case *map[bool]interface{}:
		fastpathTV.EncMapBoolIntfV(*v, e)

	case map[bool]string:
		fastpathTV.EncMapBoolStringV(v, e)
	case *map[bool]string:
		fastpathTV.EncMapBoolStringV(*v, e)

	case map[bool]uint:
		fastpathTV.EncMapBoolUintV(v, e)
	case *map[bool]uint:
		fastpathTV.EncMapBoolUintV(*v, e)

	case map[bool]uint8:
		fastpathTV.EncMapBoolUint8V(v, e)
	case *map[bool]uint8:
		fastpathTV.EncMapBoolUint8V(*v, e)

	case map[bool]uint16:
		fastpathTV.EncMapBoolUint16V(v, e)
	case *map[bool]uint16:
		fastpathTV.EncMapBoolUint16V(*v, e)

	case map[bool]uint32:
		fastpathTV.EncMapBoolUint32V(v, e)
	case *map[bool]uint32:
		fastpathTV.EncMapBoolUint32V(*v, e)

	case map[bool]uint64:
		fastpathTV.EncMapBoolUint64V(v, e)
	case *map[bool]uint64:
		fastpathTV.EncMapBoolUint64V(*v, e)

	case map[bool]uintptr:
		fastpathTV.EncMapBoolUintptrV(v, e)
	case *map[bool]uintptr:
		fastpathTV.EncMapBoolUintptrV(*v, e)

	case map[bool]int:
		fastpathTV.EncMapBoolIntV(v, e)
	case *map[bool]int:
		fastpathTV.EncMapBoolIntV(*v, e)

	case map[bool]int8:
		fastpathTV.EncMapBoolInt8V(v, e)
	case *map[bool]int8:
		fastpathTV.EncMapBoolInt8V(*v, e)

	case map[bool]int16:
		fastpathTV.EncMapBoolInt16V(v, e)
	case *map[bool]int16:
		fastpathTV.EncMapBoolInt16V(*v, e)

	case map[bool]int32:
		fastpathTV.EncMapBoolInt32V(v, e)
	case *map[bool]int32:
		fastpathTV.EncMapBoolInt32V(*v, e)

	case map[bool]int64:
		fastpathTV.EncMapBoolInt64V(v, e)
	case *map[bool]int64:
		fastpathTV.EncMapBoolInt64V(*v, e)

	case map[bool]float32:
		fastpathTV.EncMapBoolFloat32V(v, e)
	case *map[bool]float32:
		fastpathTV.EncMapBoolFloat32V(*v, e)

	case map[bool]float64:
		fastpathTV.EncMapBoolFloat64V(v, e)
	case *map[bool]float64:
		fastpathTV.EncMapBoolFloat64V(*v, e)

	case map[bool]bool:
		fastpathTV.EncMapBoolBoolV(v, e)
	case *map[bool]bool:
		fastpathTV.EncMapBoolBoolV(*v, e)

	default:
		_ = v // TODO: workaround https://github.com/golang/go/issues/12927 (remove after go 1.6 release)
		return false
	}
	return true
}

func fastpathEncodeTypeSwitchSlice(iv interface{}, e *Encoder) bool {
	switch v := iv.(type) {

	case []interface{}:
		fastpathTV.EncSliceIntfV(v, e)
	case *[]interface{}:
		fastpathTV.EncSliceIntfV(*v, e)

	case []string:
		fastpathTV.EncSliceStringV(v, e)
	case *[]string:
		fastpathTV.EncSliceStringV(*v, e)

	case []float32:
		fastpathTV.EncSliceFloat32V(v, e)
	case *[]float32:
		fastpathTV.EncSliceFloat32V(*v, e)

	case []float64:
		fastpathTV.EncSliceFloat64V(v, e)
	case *[]float64:
		fastpathTV.EncSliceFloat64V(*v, e)

	case []uint:
		fastpathTV.EncSliceUintV(v, e)
	case *[]uint:
		fastpathTV.EncSliceUintV(*v, e)

	case []uint16:
		fastpathTV.EncSliceUint16V(v, e)
	case *[]uint16:
		fastpathTV.EncSliceUint16V(*v, e)

	case []uint32:
		fastpathTV.EncSliceUint32V(v, e)
	case *[]uint32:
		fastpathTV.EncSliceUint32V(*v, e)

	case []uint64:
		fastpathTV.EncSliceUint64V(v, e)
	case *[]uint64:
		fastpathTV.EncSliceUint64V(*v, e)

	case []uintptr:
		fastpathTV.EncSliceUintptrV(v, e)
	case *[]uintptr:
		fastpathTV.EncSliceUintptrV(*v, e)

	case []int:
		fastpathTV.EncSliceIntV(v, e)
	case *[]int:
		fastpathTV.EncSliceIntV(*v, e)

	case []int8:
		fastpathTV.EncSliceInt8V(v, e)
	case *[]int8:
		fastpathTV.EncSliceInt8V(*v, e)

	case []int16:
		fastpathTV.EncSliceInt16V(v, e)
	case *[]int16:
		fastpathTV.EncSliceInt16V(*v, e)

	case []int32:
		fastpathTV.EncSliceInt32V(v, e)
	case *[]int32:
		fastpathTV.EncSliceInt32V(*v, e)

	case []int64:
		fastpathTV.EncSliceInt64V(v, e)
	case *[]int64:
		fastpathTV.EncSliceInt64V(*v, e)

	case []bool:
		fastpathTV.EncSliceBoolV(v, e)
	case *[]bool:
		fastpathTV.EncSliceBoolV(*v, e)

	default:
		_ = v // TODO: workaround https://github.com/golang/go/issues/12927 (remove after go 1.6 release)
		return false
	}
	return true
}

func fastpathEncodeTypeSwitchMap(iv interface{}, e *Encoder) bool {
	switch v := iv.(type) {

	case map[interface{}]interface{}:
		fastpathTV.EncMapIntfIntfV(v, e)
	case *map[interface{}]interface{}:
		fastpathTV.EncMapIntfIntfV(*v, e)

	case map[interface{}]string:
		fastpathTV.EncMapIntfStringV(v, e)
	case *map[interface{}]string:
		fastpathTV.EncMapIntfStringV(*v, e)

	case map[interface{}]uint:
		fastpathTV.EncMapIntfUintV(v, e)
	case *map[interface{}]uint:
		fastpathTV.EncMapIntfUintV(*v, e)

	case map[interface{}]uint8:
		fastpathTV.EncMapIntfUint8V(v, e)
	case *map[interface{}]uint8:
		fastpathTV.EncMapIntfUint8V(*v, e)

	case map[interface{}]uint16:
		fastpathTV.EncMapIntfUint16V(v, e)
	case *map[interface{}]uint16:
		fastpathTV.EncMapIntfUint16V(*v, e)

	case map[interface{}]uint32:
		fastpathTV.EncMapIntfUint32V(v, e)
	case *map[interface{}]uint32:
		fastpathTV.EncMapIntfUint32V(*v, e)

	case map[interface{}]uint64:
		fastpathTV.EncMapIntfUint64V(v, e)
	case *map[interface{}]uint64:
		fastpathTV.EncMapIntfUint64V(*v, e)

	case map[interface{}]uintptr:
		fastpathTV.EncMapIntfUintptrV(v, e)
	case *map[interface{}]uintptr:
		fastpathTV.EncMapIntfUintptrV(*v, e)

	case map[interface{}]int:
		fastpathTV.EncMapIntfIntV(v, e)
	case *map[interface{}]int:
		fastpathTV.EncMapIntfIntV(*v, e)

	case map[interface{}]int8:
		fastpathTV.EncMapIntfInt8V(v, e)
	case *map[interface{}]int8:
		fastpathTV.EncMapIntfInt8V(*v, e)

	case map[interface{}]int16:
		fastpathTV.EncMapIntfInt16V(v, e)
	case *map[interface{}]int16:
		fastpathTV.EncMapIntfInt16V(*v, e)

	case map[interface{}]int32:
		fastpathTV.EncMapIntfInt32V(v, e)
	case *map[interface{}]int32:
		fastpathTV.EncMapIntfInt32V(*v, e)

	case map[interface{}]int64:
		fastpathTV.EncMapIntfInt64V(v, e)
	case *map[interface{}]int64:
		fastpathTV.EncMapIntfInt64V(*v, e)

	case map[interface{}]float32:
		fastpathTV.EncMapIntfFloat32V(v, e)
	case *map[interface{}]float32:
		fastpathTV.EncMapIntfFloat32V(*v, e)

	case map[interface{}]float64:
		fastpathTV.EncMapIntfFloat64V(v, e)
	case *map[interface{}]float64:
		fastpathTV.EncMapIntfFloat64V(*v, e)

	case map[interface{}]bool:
		fastpathTV.EncMapIntfBoolV(v, e)
	case *map[interface{}]bool:
		fastpathTV.EncMapIntfBoolV(*v, e)

	case map[string]interface{}:
		fastpathTV.EncMapStringIntfV(v, e)
	case *map[string]interface{}:
		fastpathTV.EncMapStringIntfV(*v, e)

	case map[string]string:
		fastpathTV.EncMapStringStringV(v, e)
	case *map[string]string:
		fastpathTV.EncMapStringStringV(*v, e)

	case map[string]uint:
		fastpathTV.EncMapStringUintV(v, e)
	case *map[string]uint:
		fastpathTV.EncMapStringUintV(*v, e)

	case map[string]uint8:
		fastpathTV.EncMapStringUint8V(v, e)
	case *map[string]uint8:
		fastpathTV.EncMapStringUint8V(*v, e)

	case map[string]uint16:
		fastpathTV.EncMapStringUint16V(v, e)
	case *map[string]uint16:
		fastpathTV.EncMapStringUint16V(*v, e)

	case map[string]uint32:
		fastpathTV.EncMapStringUint32V(v, e)
	case *map[string]uint32:
		fastpathTV.EncMapStringUint32V(*v, e)

	case map[string]uint64:
		fastpathTV.EncMapStringUint64V(v, e)
	case *map[string]uint64:
		fastpathTV.EncMapStringUint64V(*v, e)

	case map[string]uintptr:
		fastpathTV.EncMapStringUintptrV(v, e)
	case *map[string]uintptr:
		fastpathTV.EncMapStringUintptrV(*v, e)

	case map[string]int:
		fastpathTV.EncMapStringIntV(v, e)
	case *map[string]int:
		fastpathTV.EncMapStringIntV(*v, e)

	case map[string]int8:
		fastpathTV.EncMapStringInt8V(v, e)
	case *map[string]int8:
		fastpathTV.EncMapStringInt8V(*v, e)

	case map[string]int16:
		fastpathTV.EncMapStringInt16V(v, e)
	case *map[string]int16:
		fastpathTV.EncMapStringInt16V(*v, e)

	case map[string]int32:
		fastpathTV.EncMapStringInt32V(v, e)
	case *map[string]int32:
		fastpathTV.EncMapStringInt32V(*v, e)

	case map[string]int64:
		fastpathTV.EncMapStringInt64V(v, e)
	case *map[string]int64:
		fastpathTV.EncMapStringInt64V(*v, e)

	case map[string]float32:
		fastpathTV.EncMapStringFloat32V(v, e)
	case *map[string]float32:
		fastpathTV.EncMapStringFloat32V(*v, e)

	case map[string]float64:
		fastpathTV.EncMapStringFloat64V(v, e)
	case *map[string]float64:
		fastpathTV.EncMapStringFloat64V(*v, e)

	case map[string]bool:
		fastpathTV.EncMapStringBoolV(v, e)
	case *map[string]bool:
		fastpathTV.EncMapStringBoolV(*v, e)

	case map[float32]interface{}:
		fastpathTV.EncMapFloat32IntfV(v, e)
	case *map[float32]interface{}:
		fastpathTV.EncMapFloat32IntfV(*v, e)

	case map[float32]string:
		fastpathTV.EncMapFloat32StringV(v, e)
	case *map[float32]string:
		fastpathTV.EncMapFloat32StringV(*v, e)

	case map[float32]uint:
		fastpathTV.EncMapFloat32UintV(v, e)
	case *map[float32]uint:
		fastpathTV.EncMapFloat32UintV(*v, e)

	case map[float32]uint8:
		fastpathTV.EncMapFloat32Uint8V(v, e)
	case *map[float32]uint8:
		fastpathTV.EncMapFloat32Uint8V(*v, e)

	case map[float32]uint16:
		fastpathTV.EncMapFloat32Uint16V(v, e)
	case *map[float32]uint16:
		fastpathTV.EncMapFloat32Uint16V(*v, e)

	case map[float32]uint32:
		fastpathTV.EncMapFloat32Uint32V(v, e)
	case *map[float32]uint32:
		fastpathTV.EncMapFloat32Uint32V(*v, e)

	case map[float32]uint64:
		fastpathTV.EncMapFloat32Uint64V(v, e)
	case *map[float32]uint64:
		fastpathTV.EncMapFloat32Uint64V(*v, e)

	case map[float32]uintptr:
		fastpathTV.EncMapFloat32UintptrV(v, e)
	case *map[float32]uintptr:
		fastpathTV.EncMapFloat32UintptrV(*v, e)

	case map[float32]int:
		fastpathTV.EncMapFloat32IntV(v, e)
	case *map[float32]int:
		fastpathTV.EncMapFloat32IntV(*v, e)

	case map[float32]int8:
		fastpathTV.EncMapFloat32Int8V(v, e)
	case *map[float32]int8:
		fastpathTV.EncMapFloat32Int8V(*v, e)

	case map[float32]int16:
		fastpathTV.EncMapFloat32Int16V(v, e)
	case *map[float32]int16:
		fastpathTV.EncMapFloat32Int16V(*v, e)

	case map[float32]int32:
		fastpathTV.EncMapFloat32Int32V(v, e)
	case *map[float32]int32:
		fastpathTV.EncMapFloat32Int32V(*v, e)

	case map[float32]int64:
		fastpathTV.EncMapFloat32Int64V(v, e)
	case *map[float32]int64:
		fastpathTV.EncMapFloat32Int64V(*v, e)

	case map[float32]float32:
		fastpathTV.EncMapFloat32Float32V(v, e)
	case *map[float32]float32:
		fastpathTV.EncMapFloat32Float32V(*v, e)

	case map[float32]float64:
		fastpathTV.EncMapFloat32Float64V(v, e)
	case *map[float32]float64:
		fastpathTV.EncMapFloat32Float64V(*v, e)

	case map[float32]bool:
		fastpathTV.EncMapFloat32BoolV(v, e)
	case *map[float32]bool:
		fastpathTV.EncMapFloat32BoolV(*v, e)

	case map[float64]interface{}:
		fastpathTV.EncMapFloat64IntfV(v, e)
	case *map[float64]interface{}:
		fastpathTV.EncMapFloat64IntfV(*v, e)

	case map[float64]string:
		fastpathTV.EncMapFloat64StringV(v, e)
	case *map[float64]string:
		fastpathTV.EncMapFloat64StringV(*v, e)

	case map[float64]uint:
		fastpathTV.EncMapFloat64UintV(v, e)
	case *map[float64]uint:
		fastpathTV.EncMapFloat64UintV(*v, e)

	case map[float64]uint8:
		fastpathTV.EncMapFloat64Uint8V(v, e)
	case *map[float64]uint8:
		fastpathTV.EncMapFloat64Uint8V(*v, e)

	case map[float64]uint16:
		fastpathTV.EncMapFloat64Uint16V(v, e)
	case *map[float64]uint16:
		fastpathTV.EncMapFloat64Uint16V(*v, e)

	case map[float64]uint32:
		fastpathTV.EncMapFloat64Uint32V(v, e)
	case *map[float64]uint32:
		fastpathTV.EncMapFloat64Uint32V(*v, e)

	case map[float64]uint64:
		fastpathTV.EncMapFloat64Uint64V(v, e)
	case *map[float64]uint64:
		fastpathTV.EncMapFloat64Uint64V(*v, e)

	case map[float64]uintptr:
		fastpathTV.EncMapFloat64UintptrV(v, e)
	case *map[float64]uintptr:
		fastpathTV.EncMapFloat64UintptrV(*v, e)

	case map[float64]int:
		fastpathTV.EncMapFloat64IntV(v, e)
	case *map[float64]int:
		fastpathTV.EncMapFloat64IntV(*v, e)

	case map[float64]int8:
		fastpathTV.EncMapFloat64Int8V(v, e)
	case *map[float64]int8:
		fastpathTV.EncMapFloat64Int8V(*v, e)

	case map[float64]int16:
		fastpathTV.EncMapFloat64Int16V(v, e)
	case *map[float64]int16:
		fastpathTV.EncMapFloat64Int16V(*v, e)

	case map[float64]int32:
		fastpathTV.EncMapFloat64Int32V(v, e)
	case *map[float64]int32:
		fastpathTV.EncMapFloat64Int32V(*v, e)

	case map[float64]int64:
		fastpathTV.EncMapFloat64Int64V(v, e)
	case *map[float64]int64:
		fastpathTV.EncMapFloat64Int64V(*v, e)

	case map[float64]float32:
		fastpathTV.EncMapFloat64Float32V(v, e)
	case *map[float64]float32:
		fastpathTV.EncMapFloat64Float32V(*v, e)

	case map[float64]float64:
		fastpathTV.EncMapFloat64Float64V(v, e)
	case *map[float64]float64:
		fastpathTV.EncMapFloat64Float64V(*v, e)

	case map[float64]bool:
		fastpathTV.EncMapFloat64BoolV(v, e)
	case *map[float64]bool:
		fastpathTV.EncMapFloat64BoolV(*v, e)

	case map[uint]interface{}:
		fastpathTV.EncMapUintIntfV(v, e)
	case *map[uint]interface{}:
		fastpathTV.EncMapUintIntfV(*v, e)

	case map[uint]string:
		fastpathTV.EncMapUintStringV(v, e)
	case *map[uint]string:
		fastpathTV.EncMapUintStringV(*v, e)

	case map[uint]uint:
		fastpathTV.EncMapUintUintV(v, e)
	case *map[uint]uint:
		fastpathTV.EncMapUintUintV(*v, e)

	case map[uint]uint8:
		fastpathTV.EncMapUintUint8V(v, e)
	case *map[uint]uint8:
		fastpathTV.EncMapUintUint8V(*v, e)

	case map[uint]uint16:
		fastpathTV.EncMapUintUint16V(v, e)
	case *map[uint]uint16:
		fastpathTV.EncMapUintUint16V(*v, e)

	case map[uint]uint32:
		fastpathTV.EncMapUintUint32V(v, e)
	case *map[uint]uint32:
		fastpathTV.EncMapUintUint32V(*v, e)

	case map[uint]uint64:
		fastpathTV.EncMapUintUint64V(v, e)
	case *map[uint]uint64:
		fastpathTV.EncMapUintUint64V(*v, e)

	case map[uint]uintptr:
		fastpathTV.EncMapUintUintptrV(v, e)
	case *map[uint]uintptr:
		fastpathTV.EncMapUintUintptrV(*v, e)

	case map[uint]int:
		fastpathTV.EncMapUintIntV(v, e)
	case *map[uint]int:
		fastpathTV.EncMapUintIntV(*v, e)

	case map[uint]int8:
		fastpathTV.EncMapUintInt8V(v, e)
	case *map[uint]int8:
		fastpathTV.EncMapUintInt8V(*v, e)

	case map[uint]int16:
		fastpathTV.EncMapUintInt16V(v, e)
	case *map[uint]int16:
		fastpathTV.EncMapUintInt16V(*v, e)

	case map[uint]int32:
		fastpathTV.EncMapUintInt32V(v, e)
	case *map[uint]int32:
		fastpathTV.EncMapUintInt32V(*v, e)

	case map[uint]int64:
		fastpathTV.EncMapUintInt64V(v, e)
	case *map[uint]int64:
		fastpathTV.EncMapUintInt64V(*v, e)

	case map[uint]float32:
		fastpathTV.EncMapUintFloat32V(v, e)
	case *map[uint]float32:
		fastpathTV.EncMapUintFloat32V(*v, e)

	case map[uint]float64:
		fastpathTV.EncMapUintFloat64V(v, e)
	case *map[uint]float64:
		fastpathTV.EncMapUintFloat64V(*v, e)

	case map[uint]bool:
		fastpathTV.EncMapUintBoolV(v, e)
	case *map[uint]bool:
		fastpathTV.EncMapUintBoolV(*v, e)

	case map[uint8]interface{}:
		fastpathTV.EncMapUint8IntfV(v, e)
	case *map[uint8]interface{}:
		fastpathTV.EncMapUint8IntfV(*v, e)

	case map[uint8]string:
		fastpathTV.EncMapUint8StringV(v, e)
	case *map[uint8]string:
		fastpathTV.EncMapUint8StringV(*v, e)

	case map[uint8]uint:
		fastpathTV.EncMapUint8UintV(v, e)
	case *map[uint8]uint:
		fastpathTV.EncMapUint8UintV(*v, e)

	case map[uint8]uint8:
		fastpathTV.EncMapUint8Uint8V(v, e)
	case *map[uint8]uint8:
		fastpathTV.EncMapUint8Uint8V(*v, e)

	case map[uint8]uint16:
		fastpathTV.EncMapUint8Uint16V(v, e)
	case *map[uint8]uint16:
		fastpathTV.EncMapUint8Uint16V(*v, e)

	case map[uint8]uint32:
		fastpathTV.EncMapUint8Uint32V(v, e)
	case *map[uint8]uint32:
		fastpathTV.EncMapUint8Uint32V(*v, e)

	case map[uint8]uint64:
		fastpathTV.EncMapUint8Uint64V(v, e)
	case *map[uint8]uint64:
		fastpathTV.EncMapUint8Uint64V(*v, e)

	case map[uint8]uintptr:
		fastpathTV.EncMapUint8UintptrV(v, e)
	case *map[uint8]uintptr:
		fastpathTV.EncMapUint8UintptrV(*v, e)

	case map[uint8]int:
		fastpathTV.EncMapUint8IntV(v, e)
	case *map[uint8]int:
		fastpathTV.EncMapUint8IntV(*v, e)

	case map[uint8]int8:
		fastpathTV.EncMapUint8Int8V(v, e)
	case *map[uint8]int8:
		fastpathTV.EncMapUint8Int8V(*v, e)

	case map[uint8]int16:
		fastpathTV.EncMapUint8Int16V(v, e)
	case *map[uint8]int16:
		fastpathTV.EncMapUint8Int16V(*v, e)

	case map[uint8]int32:
		fastpathTV.EncMapUint8Int32V(v, e)
	case *map[uint8]int32:
		fastpathTV.EncMapUint8Int32V(*v, e)

	case map[uint8]int64:
		fastpathTV.EncMapUint8Int64V(v, e)
	case *map[uint8]int64:
		fastpathTV.EncMapUint8Int64V(*v, e)

	case map[uint8]float32:
		fastpathTV.EncMapUint8Float32V(v, e)
	case *map[uint8]float32:
		fastpathTV.EncMapUint8Float32V(*v, e)

	case map[uint8]float64:
		fastpathTV.EncMapUint8Float64V(v, e)
	case *map[uint8]float64:
		fastpathTV.EncMapUint8Float64V(*v, e)

	case map[uint8]bool:
		fastpathTV.EncMapUint8BoolV(v, e)
	case *map[uint8]bool:
		fastpathTV.EncMapUint8BoolV(*v, e)

	case map[uint16]interface{}:
		fastpathTV.EncMapUint16IntfV(v, e)
	case *map[uint16]interface{}:
		fastpathTV.EncMapUint16IntfV(*v, e)

	case map[uint16]string:
		fastpathTV.EncMapUint16StringV(v, e)
	case *map[uint16]string:
		fastpathTV.EncMapUint16StringV(*v, e)

	case map[uint16]uint:
		fastpathTV.EncMapUint16UintV(v, e)
	case *map[uint16]uint:
		fastpathTV.EncMapUint16UintV(*v, e)

	case map[uint16]uint8:
		fastpathTV.EncMapUint16Uint8V(v, e)
	case *map[uint16]uint8:
		fastpathTV.EncMapUint16Uint8V(*v, e)

	case map[uint16]uint16:
		fastpathTV.EncMapUint16Uint16V(v, e)
	case *map[uint16]uint16:
		fastpathTV.EncMapUint16Uint16V(*v, e)

	case map[uint16]uint32:
		fastpathTV.EncMapUint16Uint32V(v, e)
	case *map[uint16]uint32:
		fastpathTV.EncMapUint16Uint32V(*v, e)

	case map[uint16]uint64:
		fastpathTV.EncMapUint16Uint64V(v, e)
	case *map[uint16]uint64:
		fastpathTV.EncMapUint16Uint64V(*v, e)

	case map[uint16]uintptr:
		fastpathTV.EncMapUint16UintptrV(v, e)
	case *map[uint16]uintptr:
		fastpathTV.EncMapUint16UintptrV(*v, e)

	case map[uint16]int:
		fastpathTV.EncMapUint16IntV(v, e)
	case *map[uint16]int:
		fastpathTV.EncMapUint16IntV(*v, e)

	case map[uint16]int8:
		fastpathTV.EncMapUint16Int8V(v, e)
	case *map[uint16]int8:
		fastpathTV.EncMapUint16Int8V(*v, e)

	case map[uint16]int16:
		fastpathTV.EncMapUint16Int16V(v, e)
	case *map[uint16]int16:
		fastpathTV.EncMapUint16Int16V(*v, e)

	case map[uint16]int32:
		fastpathTV.EncMapUint16Int32V(v, e)
	case *map[uint16]int32:
		fastpathTV.EncMapUint16Int32V(*v, e)

	case map[uint16]int64:
		fastpathTV.EncMapUint16Int64V(v, e)
	case *map[uint16]int64:
		fastpathTV.EncMapUint16Int64V(*v, e)

	case map[uint16]float32:
		fastpathTV.EncMapUint16Float32V(v, e)
	case *map[uint16]float32:
		fastpathTV.EncMapUint16Float32V(*v, e)

	case map[uint16]float64:
		fastpathTV.EncMapUint16Float64V(v, e)
	case *map[uint16]float64:
		fastpathTV.EncMapUint16Float64V(*v, e)

	case map[uint16]bool:
		fastpathTV.EncMapUint16BoolV(v, e)
	case *map[uint16]bool:
		fastpathTV.EncMapUint16BoolV(*v, e)

	case map[uint32]interface{}:
		fastpathTV.EncMapUint32IntfV(v, e)
	case *map[uint32]interface{}:
		fastpathTV.EncMapUint32IntfV(*v, e)

	case map[uint32]string:
		fastpathTV.EncMapUint32StringV(v, e)
	case *map[uint32]string:
		fastpathTV.EncMapUint32StringV(*v, e)

	case map[uint32]uint:
		fastpathTV.EncMapUint32UintV(v, e)
	case *map[uint32]uint:
		fastpathTV.EncMapUint32UintV(*v, e)

	case map[uint32]uint8:
		fastpathTV.EncMapUint32Uint8V(v, e)
	case *map[uint32]uint8:
		fastpathTV.EncMapUint32Uint8V(*v, e)

	case map[uint32]uint16:
		fastpathTV.EncMapUint32Uint16V(v, e)
	case *map[uint32]uint16:
		fastpathTV.EncMapUint32Uint16V(*v, e)

	case map[uint32]uint32:
		fastpathTV.EncMapUint32Uint32V(v, e)
	case *map[uint32]uint32:
		fastpathTV.EncMapUint32Uint32V(*v, e)

	case map[uint32]uint64:
		fastpathTV.EncMapUint32Uint64V(v, e)
	case *map[uint32]uint64:
		fastpathTV.EncMapUint32Uint64V(*v, e)

	case map[uint32]uintptr:
		fastpathTV.EncMapUint32UintptrV(v, e)
	case *map[uint32]uintptr:
		fastpathTV.EncMapUint32UintptrV(*v, e)

	case map[uint32]int:
		fastpathTV.EncMapUint32IntV(v, e)
	case *map[uint32]int:
		fastpathTV.EncMapUint32IntV(*v, e)

	case map[uint32]int8:
		fastpathTV.EncMapUint32Int8V(v, e)
	case *map[uint32]int8:
		fastpathTV.EncMapUint32Int8V(*v, e)

	case map[uint32]int16:
		fastpathTV.EncMapUint32Int16V(v, e)
	case *map[uint32]int16:
		fastpathTV.EncMapUint32Int16V(*v, e)

	case map[uint32]int32:
		fastpathTV.EncMapUint32Int32V(v, e)
	case *map[uint32]int32:
		fastpathTV.EncMapUint32Int32V(*v, e)

	case map[uint32]int64:
		fastpathTV.EncMapUint32Int64V(v, e)
	case *map[uint32]int64:
		fastpathTV.EncMapUint32Int64V(*v, e)

	case map[uint32]float32:
		fastpathTV.EncMapUint32Float32V(v, e)
	case *map[uint32]float32:
		fastpathTV.EncMapUint32Float32V(*v, e)

	case map[uint32]float64:
		fastpathTV.EncMapUint32Float64V(v, e)
	case *map[uint32]float64:
		fastpathTV.EncMapUint32Float64V(*v, e)

	case map[uint32]bool:
		fastpathTV.EncMapUint32BoolV(v, e)
	case *map[uint32]bool:
		fastpathTV.EncMapUint32BoolV(*v, e)

	case map[uint64]interface{}:
		fastpathTV.EncMapUint64IntfV(v, e)
	case *map[uint64]interface{}:
		fastpathTV.EncMapUint64IntfV(*v, e)

	case map[uint64]string:
		fastpathTV.EncMapUint64StringV(v, e)
	case *map[uint64]string:
		fastpathTV.EncMapUint64StringV(*v, e)

	case map[uint64]uint:
		fastpathTV.EncMapUint64UintV(v, e)
	case *map[uint64]uint:
		fastpathTV.EncMapUint64UintV(*v, e)

	case map[uint64]uint8:
		fastpathTV.EncMapUint64Uint8V(v, e)
	case *map[uint64]uint8:
		fastpathTV.EncMapUint64Uint8V(*v, e)

	case map[uint64]uint16:
		fastpathTV.EncMapUint64Uint16V(v, e)
	case *map[uint64]uint16:
		fastpathTV.EncMapUint64Uint16V(*v, e)

	case map[uint64]uint32:
		fastpathTV.EncMapUint64Uint32V(v, e)
	case *map[uint64]uint32:
		fastpathTV.EncMapUint64Uint32V(*v, e)

	case map[uint64]uint64:
		fastpathTV.EncMapUint64Uint64V(v, e)
	case *map[uint64]uint64:
		fastpathTV.EncMapUint64Uint64V(*v, e)

	case map[uint64]uintptr:
		fastpathTV.EncMapUint64UintptrV(v, e)
	case *map[uint64]uintptr:
		fastpathTV.EncMapUint64UintptrV(*v, e)

	case map[uint64]int:
		fastpathTV.EncMapUint64IntV(v, e)
	case *map[uint64]int:
		fastpathTV.EncMapUint64IntV(*v, e)

	case map[uint64]int8:
		fastpathTV.EncMapUint64Int8V(v, e)
	case *map[uint64]int8:
		fastpathTV.EncMapUint64Int8V(*v, e)

	case map[uint64]int16:
		fastpathTV.EncMapUint64Int16V(v, e)
	case *map[uint64]int16:
		fastpathTV.EncMapUint64Int16V(*v, e)

	case map[uint64]int32:
		fastpathTV.EncMapUint64Int32V(v, e)
	case *map[uint64]int32:
		fastpathTV.EncMapUint64Int32V(*v, e)

	case map[uint64]int64:
		fastpathTV.EncMapUint64Int64V(v, e)
	case *map[uint64]int64:
		fastpathTV.EncMapUint64Int64V(*v, e)

	case map[uint64]float32:
		fastpathTV.EncMapUint64Float32V(v, e)
	case *map[uint64]float32:
		fastpathTV.EncMapUint64Float32V(*v, e)

	case map[uint64]float64:
		fastpathTV.EncMapUint64Float64V(v, e)
	case *map[uint64]float64:
		fastpathTV.EncMapUint64Float64V(*v, e)

	case map[uint64]bool:
		fastpathTV.EncMapUint64BoolV(v, e)
	case *map[uint64]bool:
		fastpathTV.EncMapUint64BoolV(*v, e)

	case map[uintptr]interface{}:
		fastpathTV.EncMapUintptrIntfV(v, e)
	case *map[uintptr]interface{}:
		fastpathTV.EncMapUintptrIntfV(*v, e)

	case map[uintptr]string:
		fastpathTV.EncMapUintptrStringV(v, e)
	case *map[uintptr]string:
		fastpathTV.EncMapUintptrStringV(*v, e)

	case map[uintptr]uint:
		fastpathTV.EncMapUintptrUintV(v, e)
	case *map[uintptr]uint:
		fastpathTV.EncMapUintptrUintV(*v, e)

	case map[uintptr]uint8:
		fastpathTV.EncMapUintptrUint8V(v, e)
	case *map[uintptr]uint8:
		fastpathTV.EncMapUintptrUint8V(*v, e)

	case map[uintptr]uint16:
		fastpathTV.EncMapUintptrUint16V(v, e)
	case *map[uintptr]uint16:
		fastpathTV.EncMapUintptrUint16V(*v, e)

	case map[uintptr]uint32:
		fastpathTV.EncMapUintptrUint32V(v, e)
	case *map[uintptr]uint32:
		fastpathTV.EncMapUintptrUint32V(*v, e)

	case map[uintptr]uint64:
		fastpathTV.EncMapUintptrUint64V(v, e)
	case *map[uintptr]uint64:
		fastpathTV.EncMapUintptrUint64V(*v, e)

	case map[uintptr]uintptr:
		fastpathTV.EncMapUintptrUintptrV(v, e)
	case *map[uintptr]uintptr:
		fastpathTV.EncMapUintptrUintptrV(*v, e)

	case map[uintptr]int:
		fastpathTV.EncMapUintptrIntV(v, e)
	case *map[uintptr]int:
		fastpathTV.EncMapUintptrIntV(*v, e)

	case map[uintptr]int8:
		fastpathTV.EncMapUintptrInt8V(v, e)
	case *map[uintptr]int8:
		fastpathTV.EncMapUintptrInt8V(*v, e)

	case map[uintptr]int16:
		fastpathTV.EncMapUintptrInt16V(v, e)
	case *map[uintptr]int16:
		fastpathTV.EncMapUintptrInt16V(*v, e)

	case map[uintptr]int32:
		fastpathTV.EncMapUintptrInt32V(v, e)
	case *map[uintptr]int32:
		fastpathTV.EncMapUintptrInt32V(*v, e)

	case map[uintptr]int64:
		fastpathTV.EncMapUintptrInt64V(v, e)
	case *map[uintptr]int64:
		fastpathTV.EncMapUintptrInt64V(*v, e)

	case map[uintptr]float32:
		fastpathTV.EncMapUintptrFloat32V(v, e)
	case *map[uintptr]float32:
		fastpathTV.EncMapUintptrFloat32V(*v, e)

	case map[uintptr]float64:
		fastpathTV.EncMapUintptrFloat64V(v, e)
	case *map[uintptr]float64:
		fastpathTV.EncMapUintptrFloat64V(*v, e)

	case map[uintptr]bool:
		fastpathTV.EncMapUintptrBoolV(v, e)
	case *map[uintptr]bool:
		fastpathTV.EncMapUintptrBoolV(*v, e)

	case map[int]interface{}:
		fastpathTV.EncMapIntIntfV(v, e)
	case *map[int]interface{}:
		fastpathTV.EncMapIntIntfV(*v, e)

	case map[int]string:
		fastpathTV.EncMapIntStringV(v, e)
	case *map[int]string:
		fastpathTV.EncMapIntStringV(*v, e)

	case map[int]uint:
		fastpathTV.EncMapIntUintV(v, e)
	case *map[int]uint:
		fastpathTV.EncMapIntUintV(*v, e)

	case map[int]uint8:
		fastpathTV.EncMapIntUint8V(v, e)
	case *map[int]uint8:
		fastpathTV.EncMapIntUint8V(*v, e)

	case map[int]uint16:
		fastpathTV.EncMapIntUint16V(v, e)
	case *map[int]uint16:
		fastpathTV.EncMapIntUint16V(*v, e)

	case map[int]uint32:
		fastpathTV.EncMapIntUint32V(v, e)
	case *map[int]uint32:
		fastpathTV.EncMapIntUint32V(*v, e)

	case map[int]uint64:
		fastpathTV.EncMapIntUint64V(v, e)
	case *map[int]uint64:
		fastpathTV.EncMapIntUint64V(*v, e)

	case map[int]uintptr:
		fastpathTV.EncMapIntUintptrV(v, e)
	case *map[int]uintptr:
		fastpathTV.EncMapIntUintptrV(*v, e)

	case map[int]int:
		fastpathTV.EncMapIntIntV(v, e)
	case *map[int]int:
		fastpathTV.EncMapIntIntV(*v, e)

	case map[int]int8:
		fastpathTV.EncMapIntInt8V(v, e)
	case *map[int]int8:
		fastpathTV.EncMapIntInt8V(*v, e)

	case map[int]int16:
		fastpathTV.EncMapIntInt16V(v, e)
	case *map[int]int16:
		fastpathTV.EncMapIntInt16V(*v, e)

	case map[int]int32:
		fastpathTV.EncMapIntInt32V(v, e)
	case *map[int]int32:
		fastpathTV.EncMapIntInt32V(*v, e)

	case map[int]int64:
		fastpathTV.EncMapIntInt64V(v, e)
	case *map[int]int64:
		fastpathTV.EncMapIntInt64V(*v, e)

	case map[int]float32:
		fastpathTV.EncMapIntFloat32V(v, e)
	case *map[int]float32:
		fastpathTV.EncMapIntFloat32V(*v, e)

	case map[int]float64:
		fastpathTV.EncMapIntFloat64V(v, e)
	case *map[int]float64:
		fastpathTV.EncMapIntFloat64V(*v, e)

	case map[int]bool:
		fastpathTV.EncMapIntBoolV(v, e)
	case *map[int]bool:
		fastpathTV.EncMapIntBoolV(*v, e)

	case map[int8]interface{}:
		fastpathTV.EncMapInt8IntfV(v, e)
	case *map[int8]interface{}:
		fastpathTV.EncMapInt8IntfV(*v, e)

	case map[int8]string:
		fastpathTV.EncMapInt8StringV(v, e)
	case *map[int8]string:
		fastpathTV.EncMapInt8StringV(*v, e)

	case map[int8]uint:
		fastpathTV.EncMapInt8UintV(v, e)
	case *map[int8]uint:
		fastpathTV.EncMapInt8UintV(*v, e)

	case map[int8]uint8:
		fastpathTV.EncMapInt8Uint8V(v, e)
	case *map[int8]uint8:
		fastpathTV.EncMapInt8Uint8V(*v, e)

	case map[int8]uint16:
		fastpathTV.EncMapInt8Uint16V(v, e)
	case *map[int8]uint16:
		fastpathTV.EncMapInt8Uint16V(*v, e)

	case map[int8]uint32:
		fastpathTV.EncMapInt8Uint32V(v, e)
	case *map[int8]uint32:
		fastpathTV.EncMapInt8Uint32V(*v, e)

	case map[int8]uint64:
		fastpathTV.EncMapInt8Uint64V(v, e)
	case *map[int8]uint64:
		fastpathTV.EncMapInt8Uint64V(*v, e)

	case map[int8]uintptr:
		fastpathTV.EncMapInt8UintptrV(v, e)
	case *map[int8]uintptr:
		fastpathTV.EncMapInt8UintptrV(*v, e)

	case map[int8]int:
		fastpathTV.EncMapInt8IntV(v, e)
	case *map[int8]int:
		fastpathTV.EncMapInt8IntV(*v, e)

	case map[int8]int8:
		fastpathTV.EncMapInt8Int8V(v, e)
	case *map[int8]int8:
		fastpathTV.EncMapInt8Int8V(*v, e)

	case map[int8]int16:
		fastpathTV.EncMapInt8Int16V(v, e)
	case *map[int8]int16:
		fastpathTV.EncMapInt8Int16V(*v, e)

	case map[int8]int32:
		fastpathTV.EncMapInt8Int32V(v, e)
	case *map[int8]int32:
		fastpathTV.EncMapInt8Int32V(*v, e)

	case map[int8]int64:
		fastpathTV.EncMapInt8Int64V(v, e)
	case *map[int8]int64:
		fastpathTV.EncMapInt8Int64V(*v, e)

	case map[int8]float32:
		fastpathTV.EncMapInt8Float32V(v, e)
	case *map[int8]float32:
		fastpathTV.EncMapInt8Float32V(*v, e)

	case map[int8]float64:
		fastpathTV.EncMapInt8Float64V(v, e)
	case *map[int8]float64:
		fastpathTV.EncMapInt8Float64V(*v, e)

	case map[int8]bool:
		fastpathTV.EncMapInt8BoolV(v, e)
	case *map[int8]bool:
		fastpathTV.EncMapInt8BoolV(*v, e)

	case map[int16]interface{}:
		fastpathTV.EncMapInt16IntfV(v, e)
	case *map[int16]interface{}:
		fastpathTV.EncMapInt16IntfV(*v, e)

	case map[int16]string:
		fastpathTV.EncMapInt16StringV(v, e)
	case *map[int16]string:
		fastpathTV.EncMapInt16StringV(*v, e)

	case map[int16]uint:
		fastpathTV.EncMapInt16UintV(v, e)
	case *map[int16]uint:
		fastpathTV.EncMapInt16UintV(*v, e)

	case map[int16]uint8:
		fastpathTV.EncMapInt16Uint8V(v, e)
	case *map[int16]uint8:
		fastpathTV.EncMapInt16Uint8V(*v, e)

	case map[int16]uint16:
		fastpathTV.EncMapInt16Uint16V(v, e)
	case *map[int16]uint16:
		fastpathTV.EncMapInt16Uint16V(*v, e)

	case map[int16]uint32:
		fastpathTV.EncMapInt16Uint32V(v, e)
	case *map[int16]uint32:
		fastpathTV.EncMapInt16Uint32V(*v, e)

	case map[int16]uint64:
		fastpathTV.EncMapInt16Uint64V(v, e)
	case *map[int16]uint64:
		fastpathTV.EncMapInt16Uint64V(*v, e)

	case map[int16]uintptr:
		fastpathTV.EncMapInt16UintptrV(v, e)
	case *map[int16]uintptr:
		fastpathTV.EncMapInt16UintptrV(*v, e)

	case map[int16]int:
		fastpathTV.EncMapInt16IntV(v, e)
	case *map[int16]int:
		fastpathTV.EncMapInt16IntV(*v, e)

	case map[int16]int8:
		fastpathTV.EncMapInt16Int8V(v, e)
	case *map[int16]int8:
		fastpathTV.EncMapInt16Int8V(*v, e)

	case map[int16]int16:
		fastpathTV.EncMapInt16Int16V(v, e)
	case *map[int16]int16:
		fastpathTV.EncMapInt16Int16V(*v, e)

	case map[int16]int32:
		fastpathTV.EncMapInt16Int32V(v, e)
	case *map[int16]int32:
		fastpathTV.EncMapInt16Int32V(*v, e)

	case map[int16]int64:
		fastpathTV.EncMapInt16Int64V(v, e)
	case *map[int16]int64:
		fastpathTV.EncMapInt16Int64V(*v, e)

	case map[int16]float32:
		fastpathTV.EncMapInt16Float32V(v, e)
	case *map[int16]float32:
		fastpathTV.EncMapInt16Float32V(*v, e)

	case map[int16]float64:
		fastpathTV.EncMapInt16Float64V(v, e)
	case *map[int16]float64:
		fastpathTV.EncMapInt16Float64V(*v, e)

	case map[int16]bool:
		fastpathTV.EncMapInt16BoolV(v, e)
	case *map[int16]bool:
		fastpathTV.EncMapInt16BoolV(*v, e)

	case map[int32]interface{}:
		fastpathTV.EncMapInt32IntfV(v, e)
	case *map[int32]interface{}:
		fastpathTV.EncMapInt32IntfV(*v, e)

	case map[int32]string:
		fastpathTV.EncMapInt32StringV(v, e)
	case *map[int32]string:
		fastpathTV.EncMapInt32StringV(*v, e)

	case map[int32]uint:
		fastpathTV.EncMapInt32UintV(v, e)
	case *map[int32]uint:
		fastpathTV.EncMapInt32UintV(*v, e)

	case map[int32]uint8:
		fastpathTV.EncMapInt32Uint8V(v, e)
	case *map[int32]uint8:
		fastpathTV.EncMapInt32Uint8V(*v, e)

	case map[int32]uint16:
		fastpathTV.EncMapInt32Uint16V(v, e)
	case *map[int32]uint16:
		fastpathTV.EncMapInt32Uint16V(*v, e)

	case map[int32]uint32:
		fastpathTV.EncMapInt32Uint32V(v, e)
	case *map[int32]uint32:
		fastpathTV.EncMapInt32Uint32V(*v, e)

	case map[int32]uint64:
		fastpathTV.EncMapInt32Uint64V(v, e)
	case *map[int32]uint64:
		fastpathTV.EncMapInt32Uint64V(*v, e)

	case map[int32]uintptr:
		fastpathTV.EncMapInt32UintptrV(v, e)
	case *map[int32]uintptr:
		fastpathTV.EncMapInt32UintptrV(*v, e)

	case map[int32]int:
		fastpathTV.EncMapInt32IntV(v, e)
	case *map[int32]int:
		fastpathTV.EncMapInt32IntV(*v, e)

	case map[int32]int8:
		fastpathTV.EncMapInt32Int8V(v, e)
	case *map[int32]int8:
		fastpathTV.EncMapInt32Int8V(*v, e)

	case map[int32]int16:
		fastpathTV.EncMapInt32Int16V(v, e)
	case *map[int32]int16:
		fastpathTV.EncMapInt32Int16V(*v, e)

	case map[int32]int32:
		fastpathTV.EncMapInt32Int32V(v, e)
	case *map[int32]int32:
		fastpathTV.EncMapInt32Int32V(*v, e)

	case map[int32]int64:
		fastpathTV.EncMapInt32Int64V(v, e)
	case *map[int32]int64:
		fastpathTV.EncMapInt32Int64V(*v, e)

	case map[int32]float32:
		fastpathTV.EncMapInt32Float32V(v, e)
	case *map[int32]float32:
		fastpathTV.EncMapInt32Float32V(*v, e)

	case map[int32]float64:
		fastpathTV.EncMapInt32Float64V(v, e)
	case *map[int32]float64:
		fastpathTV.EncMapInt32Float64V(*v, e)

	case map[int32]bool:
		fastpathTV.EncMapInt32BoolV(v, e)
	case *map[int32]bool:
		fastpathTV.EncMapInt32BoolV(*v, e)

	case map[int64]interface{}:
		fastpathTV.EncMapInt64IntfV(v, e)
	case *map[int64]interface{}:
		fastpathTV.EncMapInt64IntfV(*v, e)

	case map[int64]string:
		fastpathTV.EncMapInt64StringV(v, e)
	case *map[int64]string:
		fastpathTV.EncMapInt64StringV(*v, e)

	case map[int64]uint:
		fastpathTV.EncMapInt64UintV(v, e)
	case *map[int64]uint:
		fastpathTV.EncMapInt64UintV(*v, e)

	case map[int64]uint8:
		fastpathTV.EncMapInt64Uint8V(v, e)
	case *map[int64]uint8:
		fastpathTV.EncMapInt64Uint8V(*v, e)

	case map[int64]uint16:
		fastpathTV.EncMapInt64Uint16V(v, e)
	case *map[int64]uint16:
		fastpathTV.EncMapInt64Uint16V(*v, e)

	case map[int64]uint32:
		fastpathTV.EncMapInt64Uint32V(v, e)
	case *map[int64]uint32:
		fastpathTV.EncMapInt64Uint32V(*v, e)

	case map[int64]uint64:
		fastpathTV.EncMapInt64Uint64V(v, e)
	case *map[int64]uint64:
		fastpathTV.EncMapInt64Uint64V(*v, e)

	case map[int64]uintptr:
		fastpathTV.EncMapInt64UintptrV(v, e)
	case *map[int64]uintptr:
		fastpathTV.EncMapInt64UintptrV(*v, e)

	case map[int64]int:
		fastpathTV.EncMapInt64IntV(v, e)
	case *map[int64]int:
		fastpathTV.EncMapInt64IntV(*v, e)

	case map[int64]int8:
		fastpathTV.EncMapInt64Int8V(v, e)
	case *map[int64]int8:
		fastpathTV.EncMapInt64Int8V(*v, e)

	case map[int64]int16:
		fastpathTV.EncMapInt64Int16V(v, e)
	case *map[int64]int16:
		fastpathTV.EncMapInt64Int16V(*v, e)

	case map[int64]int32:
		fastpathTV.EncMapInt64Int32V(v, e)
	case *map[int64]int32:
		fastpathTV.EncMapInt64Int32V(*v, e)

	case map[int64]int64:
		fastpathTV.EncMapInt64Int64V(v, e)
	case *map[int64]int64:
		fastpathTV.EncMapInt64Int64V(*v, e)

	case map[int64]float32:
		fastpathTV.EncMapInt64Float32V(v, e)
	case *map[int64]float32:
		fastpathTV.EncMapInt64Float32V(*v, e)

	case map[int64]float64:
		fastpathTV.EncMapInt64Float64V(v, e)
	case *map[int64]float64:
		fastpathTV.EncMapInt64Float64V(*v, e)

	case map[int64]bool:
		fastpathTV.EncMapInt64BoolV(v, e)
	case *map[int64]bool:
		fastpathTV.EncMapInt64BoolV(*v, e)

	case map[bool]interface{}:
		fastpathTV.EncMapBoolIntfV(v, e)
	case *map[bool]interface{}:
		fastpathTV.EncMapBoolIntfV(*v, e)

	case map[bool]string:
		fastpathTV.EncMapBoolStringV(v, e)
	case *map[bool]string:
		fastpathTV.EncMapBoolStringV(*v, e)

	case map[bool]uint:
		fastpathTV.EncMapBoolUintV(v, e)
	case *map[bool]uint:
		fastpathTV.EncMapBoolUintV(*v, e)

	case map[bool]uint8:
		fastpathTV.EncMapBoolUint8V(v, e)
	case *map[bool]uint8:
		fastpathTV.EncMapBoolUint8V(*v, e)

	case map[bool]uint16:
		fastpathTV.EncMapBoolUint16V(v, e)
	case *map[bool]uint16:
		fastpathTV.EncMapBoolUint16V(*v, e)

	case map[bool]uint32:
		fastpathTV.EncMapBoolUint32V(v, e)
	case *map[bool]uint32:
		fastpathTV.EncMapBoolUint32V(*v, e)

	case map[bool]uint64:
		fastpathTV.EncMapBoolUint64V(v, e)
	case *map[bool]uint64:
		fastpathTV.EncMapBoolUint64V(*v, e)

	case map[bool]uintptr:
		fastpathTV.EncMapBoolUintptrV(v, e)
	case *map[bool]uintptr:
		fastpathTV.EncMapBoolUintptrV(*v, e)

	case map[bool]int:
		fastpathTV.EncMapBoolIntV(v, e)
	case *map[bool]int:
		fastpathTV.EncMapBoolIntV(*v, e)

	case map[bool]int8:
		fastpathTV.EncMapBoolInt8V(v, e)
	case *map[bool]int8:
		fastpathTV.EncMapBoolInt8V(*v, e)

	case map[bool]int16:
		fastpathTV.EncMapBoolInt16V(v, e)
	case *map[bool]int16:
		fastpathTV.EncMapBoolInt16V(*v, e)

	case map[bool]int32:
		fastpathTV.EncMapBoolInt32V(v, e)
	case *map[bool]int32:
		fastpathTV.EncMapBoolInt32V(*v, e)

	case map[bool]int64:
		fastpathTV.EncMapBoolInt64V(v, e)
	case *map[bool]int64:
		fastpathTV.EncMapBoolInt64V(*v, e)

	case map[bool]float32:
		fastpathTV.EncMapBoolFloat32V(v, e)
	case *map[bool]float32:
		fastpathTV.EncMapBoolFloat32V(*v, e)

	case map[bool]float64:
		fastpathTV.EncMapBoolFloat64V(v, e)
	case *map[bool]float64:
		fastpathTV.EncMapBoolFloat64V(*v, e)

	case map[bool]bool:
		fastpathTV.EncMapBoolBoolV(v, e)
	case *map[bool]bool:
		fastpathTV.EncMapBoolBoolV(*v, e)

	default:
		_ = v // TODO: workaround https://github.com/golang/go/issues/12927 (remove after go 1.6 release)
		return false
	}
	return true
}

// -- -- fast path functions

func (e *Encoder) fastpathEncSliceIntfR(f *codecFnInfo, rv reflect.Value) {
	if f.ti.mbs {
		fastpathTV.EncAsMapSliceIntfV(rv2i(rv).([]interface{}), e)
	} else {
		fastpathTV.EncSliceIntfV(rv2i(rv).([]interface{}), e)
	}
}
func (_ fastpathT) EncSliceIntfV(v []interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v {
		if cr != nil {
			cr.sendContainerState(containerArrayElem)
		}
		e.encode(v2)
	}
	if cr != nil {
		cr.sendContainerState(containerArrayEnd)
	}
}

func (_ fastpathT) EncAsMapSliceIntfV(v []interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	if len(v)%2 == 1 {
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	}
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v {
		if cr != nil {
			if j%2 == 0 {
				cr.sendContainerState(containerMapKey)
			} else {
				cr.sendContainerState(containerMapValue)
			}
		}
		e.encode(v2)
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncSliceStringR(f *codecFnInfo, rv reflect.Value) {
	if f.ti.mbs {
		fastpathTV.EncAsMapSliceStringV(rv2i(rv).([]string), e)
	} else {
		fastpathTV.EncSliceStringV(rv2i(rv).([]string), e)
	}
}
func (_ fastpathT) EncSliceStringV(v []string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v {
		if cr != nil {
			cr.sendContainerState(containerArrayElem)
		}
		ee.EncodeString(c_UTF8, v2)
	}
	if cr != nil {
		cr.sendContainerState(containerArrayEnd)
	}
}

func (_ fastpathT) EncAsMapSliceStringV(v []string, e *Encoder) {
	ee, cr := e.e, e.cr
	if len(v)%2 == 1 {
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	}
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v {
		if cr != nil {
			if j%2 == 0 {
				cr.sendContainerState(containerMapKey)
			} else {
				cr.sendContainerState(containerMapValue)
			}
		}
		ee.EncodeString(c_UTF8, v2)
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncSliceFloat32R(f *codecFnInfo, rv reflect.Value) {
	if f.ti.mbs {
		fastpathTV.EncAsMapSliceFloat32V(rv2i(rv).([]float32), e)
	} else {
		fastpathTV.EncSliceFloat32V(rv2i(rv).([]float32), e)
	}
}
func (_ fastpathT) EncSliceFloat32V(v []float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v {
		if cr != nil {
			cr.sendContainerState(containerArrayElem)
		}
		ee.EncodeFloat32(v2)
	}
	if cr != nil {
		cr.sendContainerState(containerArrayEnd)
	}
}

func (_ fastpathT) EncAsMapSliceFloat32V(v []float32, e *Encoder) {
	ee, cr := e.e, e.cr
	if len(v)%2 == 1 {
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	}
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v {
		if cr != nil {
			if j%2 == 0 {
				cr.sendContainerState(containerMapKey)
			} else {
				cr.sendContainerState(containerMapValue)
			}
		}
		ee.EncodeFloat32(v2)
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncSliceFloat64R(f *codecFnInfo, rv reflect.Value) {
	if f.ti.mbs {
		fastpathTV.EncAsMapSliceFloat64V(rv2i(rv).([]float64), e)
	} else {
		fastpathTV.EncSliceFloat64V(rv2i(rv).([]float64), e)
	}
}
func (_ fastpathT) EncSliceFloat64V(v []float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v {
		if cr != nil {
			cr.sendContainerState(containerArrayElem)
		}
		ee.EncodeFloat64(v2)
	}
	if cr != nil {
		cr.sendContainerState(containerArrayEnd)
	}
}

func (_ fastpathT) EncAsMapSliceFloat64V(v []float64, e *Encoder) {
	ee, cr := e.e, e.cr
	if len(v)%2 == 1 {
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	}
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v {
		if cr != nil {
			if j%2 == 0 {
				cr.sendContainerState(containerMapKey)
			} else {
				cr.sendContainerState(containerMapValue)
			}
		}
		ee.EncodeFloat64(v2)
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncSliceUintR(f *codecFnInfo, rv reflect.Value) {
	if f.ti.mbs {
		fastpathTV.EncAsMapSliceUintV(rv2i(rv).([]uint), e)
	} else {
		fastpathTV.EncSliceUintV(rv2i(rv).([]uint), e)
	}
}
func (_ fastpathT) EncSliceUintV(v []uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v {
		if cr != nil {
			cr.sendContainerState(containerArrayElem)
		}
		ee.EncodeUint(uint64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerArrayEnd)
	}
}

func (_ fastpathT) EncAsMapSliceUintV(v []uint, e *Encoder) {
	ee, cr := e.e, e.cr
	if len(v)%2 == 1 {
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	}
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v {
		if cr != nil {
			if j%2 == 0 {
				cr.sendContainerState(containerMapKey)
			} else {
				cr.sendContainerState(containerMapValue)
			}
		}
		ee.EncodeUint(uint64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncSliceUint16R(f *codecFnInfo, rv reflect.Value) {
	if f.ti.mbs {
		fastpathTV.EncAsMapSliceUint16V(rv2i(rv).([]uint16), e)
	} else {
		fastpathTV.EncSliceUint16V(rv2i(rv).([]uint16), e)
	}
}
func (_ fastpathT) EncSliceUint16V(v []uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v {
		if cr != nil {
			cr.sendContainerState(containerArrayElem)
		}
		ee.EncodeUint(uint64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerArrayEnd)
	}
}

func (_ fastpathT) EncAsMapSliceUint16V(v []uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	if len(v)%2 == 1 {
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	}
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v {
		if cr != nil {
			if j%2 == 0 {
				cr.sendContainerState(containerMapKey)
			} else {
				cr.sendContainerState(containerMapValue)
			}
		}
		ee.EncodeUint(uint64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncSliceUint32R(f *codecFnInfo, rv reflect.Value) {
	if f.ti.mbs {
		fastpathTV.EncAsMapSliceUint32V(rv2i(rv).([]uint32), e)
	} else {
		fastpathTV.EncSliceUint32V(rv2i(rv).([]uint32), e)
	}
}
func (_ fastpathT) EncSliceUint32V(v []uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v {
		if cr != nil {
			cr.sendContainerState(containerArrayElem)
		}
		ee.EncodeUint(uint64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerArrayEnd)
	}
}

func (_ fastpathT) EncAsMapSliceUint32V(v []uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	if len(v)%2 == 1 {
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	}
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v {
		if cr != nil {
			if j%2 == 0 {
				cr.sendContainerState(containerMapKey)
			} else {
				cr.sendContainerState(containerMapValue)
			}
		}
		ee.EncodeUint(uint64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncSliceUint64R(f *codecFnInfo, rv reflect.Value) {
	if f.ti.mbs {
		fastpathTV.EncAsMapSliceUint64V(rv2i(rv).([]uint64), e)
	} else {
		fastpathTV.EncSliceUint64V(rv2i(rv).([]uint64), e)
	}
}
func (_ fastpathT) EncSliceUint64V(v []uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v {
		if cr != nil {
			cr.sendContainerState(containerArrayElem)
		}
		ee.EncodeUint(uint64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerArrayEnd)
	}
}

func (_ fastpathT) EncAsMapSliceUint64V(v []uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	if len(v)%2 == 1 {
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	}
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v {
		if cr != nil {
			if j%2 == 0 {
				cr.sendContainerState(containerMapKey)
			} else {
				cr.sendContainerState(containerMapValue)
			}
		}
		ee.EncodeUint(uint64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncSliceUintptrR(f *codecFnInfo, rv reflect.Value) {
	if f.ti.mbs {
		fastpathTV.EncAsMapSliceUintptrV(rv2i(rv).([]uintptr), e)
	} else {
		fastpathTV.EncSliceUintptrV(rv2i(rv).([]uintptr), e)
	}
}
func (_ fastpathT) EncSliceUintptrV(v []uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v {
		if cr != nil {
			cr.sendContainerState(containerArrayElem)
		}
		e.encode(v2)
	}
	if cr != nil {
		cr.sendContainerState(containerArrayEnd)
	}
}

func (_ fastpathT) EncAsMapSliceUintptrV(v []uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	if len(v)%2 == 1 {
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	}
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v {
		if cr != nil {
			if j%2 == 0 {
				cr.sendContainerState(containerMapKey)
			} else {
				cr.sendContainerState(containerMapValue)
			}
		}
		e.encode(v2)
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncSliceIntR(f *codecFnInfo, rv reflect.Value) {
	if f.ti.mbs {
		fastpathTV.EncAsMapSliceIntV(rv2i(rv).([]int), e)
	} else {
		fastpathTV.EncSliceIntV(rv2i(rv).([]int), e)
	}
}
func (_ fastpathT) EncSliceIntV(v []int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v {
		if cr != nil {
			cr.sendContainerState(containerArrayElem)
		}
		ee.EncodeInt(int64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerArrayEnd)
	}
}

func (_ fastpathT) EncAsMapSliceIntV(v []int, e *Encoder) {
	ee, cr := e.e, e.cr
	if len(v)%2 == 1 {
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	}
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v {
		if cr != nil {
			if j%2 == 0 {
				cr.sendContainerState(containerMapKey)
			} else {
				cr.sendContainerState(containerMapValue)
			}
		}
		ee.EncodeInt(int64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncSliceInt8R(f *codecFnInfo, rv reflect.Value) {
	if f.ti.mbs {
		fastpathTV.EncAsMapSliceInt8V(rv2i(rv).([]int8), e)
	} else {
		fastpathTV.EncSliceInt8V(rv2i(rv).([]int8), e)
	}
}
func (_ fastpathT) EncSliceInt8V(v []int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v {
		if cr != nil {
			cr.sendContainerState(containerArrayElem)
		}
		ee.EncodeInt(int64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerArrayEnd)
	}
}

func (_ fastpathT) EncAsMapSliceInt8V(v []int8, e *Encoder) {
	ee, cr := e.e, e.cr
	if len(v)%2 == 1 {
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	}
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v {
		if cr != nil {
			if j%2 == 0 {
				cr.sendContainerState(containerMapKey)
			} else {
				cr.sendContainerState(containerMapValue)
			}
		}
		ee.EncodeInt(int64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncSliceInt16R(f *codecFnInfo, rv reflect.Value) {
	if f.ti.mbs {
		fastpathTV.EncAsMapSliceInt16V(rv2i(rv).([]int16), e)
	} else {
		fastpathTV.EncSliceInt16V(rv2i(rv).([]int16), e)
	}
}
func (_ fastpathT) EncSliceInt16V(v []int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v {
		if cr != nil {
			cr.sendContainerState(containerArrayElem)
		}
		ee.EncodeInt(int64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerArrayEnd)
	}
}

func (_ fastpathT) EncAsMapSliceInt16V(v []int16, e *Encoder) {
	ee, cr := e.e, e.cr
	if len(v)%2 == 1 {
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	}
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v {
		if cr != nil {
			if j%2 == 0 {
				cr.sendContainerState(containerMapKey)
			} else {
				cr.sendContainerState(containerMapValue)
			}
		}
		ee.EncodeInt(int64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncSliceInt32R(f *codecFnInfo, rv reflect.Value) {
	if f.ti.mbs {
		fastpathTV.EncAsMapSliceInt32V(rv2i(rv).([]int32), e)
	} else {
		fastpathTV.EncSliceInt32V(rv2i(rv).([]int32), e)
	}
}
func (_ fastpathT) EncSliceInt32V(v []int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v {
		if cr != nil {
			cr.sendContainerState(containerArrayElem)
		}
		ee.EncodeInt(int64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerArrayEnd)
	}
}

func (_ fastpathT) EncAsMapSliceInt32V(v []int32, e *Encoder) {
	ee, cr := e.e, e.cr
	if len(v)%2 == 1 {
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	}
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v {
		if cr != nil {
			if j%2 == 0 {
				cr.sendContainerState(containerMapKey)
			} else {
				cr.sendContainerState(containerMapValue)
			}
		}
		ee.EncodeInt(int64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncSliceInt64R(f *codecFnInfo, rv reflect.Value) {
	if f.ti.mbs {
		fastpathTV.EncAsMapSliceInt64V(rv2i(rv).([]int64), e)
	} else {
		fastpathTV.EncSliceInt64V(rv2i(rv).([]int64), e)
	}
}
func (_ fastpathT) EncSliceInt64V(v []int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v {
		if cr != nil {
			cr.sendContainerState(containerArrayElem)
		}
		ee.EncodeInt(int64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerArrayEnd)
	}
}

func (_ fastpathT) EncAsMapSliceInt64V(v []int64, e *Encoder) {
	ee, cr := e.e, e.cr
	if len(v)%2 == 1 {
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	}
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v {
		if cr != nil {
			if j%2 == 0 {
				cr.sendContainerState(containerMapKey)
			} else {
				cr.sendContainerState(containerMapValue)
			}
		}
		ee.EncodeInt(int64(v2))
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncSliceBoolR(f *codecFnInfo, rv reflect.Value) {
	if f.ti.mbs {
		fastpathTV.EncAsMapSliceBoolV(rv2i(rv).([]bool), e)
	} else {
		fastpathTV.EncSliceBoolV(rv2i(rv).([]bool), e)
	}
}
func (_ fastpathT) EncSliceBoolV(v []bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v {
		if cr != nil {
			cr.sendContainerState(containerArrayElem)
		}
		ee.EncodeBool(v2)
	}
	if cr != nil {
		cr.sendContainerState(containerArrayEnd)
	}
}

func (_ fastpathT) EncAsMapSliceBoolV(v []bool, e *Encoder) {
	ee, cr := e.e, e.cr
	if len(v)%2 == 1 {
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	}
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v {
		if cr != nil {
			if j%2 == 0 {
				cr.sendContainerState(containerMapKey)
			} else {
				cr.sendContainerState(containerMapValue)
			}
		}
		ee.EncodeBool(v2)
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfIntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfIntfV(rv2i(rv).(map[interface{}]interface{}), e)
}
func (_ fastpathT) EncMapIntfIntfV(v map[interface{}]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfStringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfStringV(rv2i(rv).(map[interface{}]string), e)
}
func (_ fastpathT) EncMapIntfStringV(v map[interface{}]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfUintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfUintV(rv2i(rv).(map[interface{}]uint), e)
}
func (_ fastpathT) EncMapIntfUintV(v map[interface{}]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfUint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfUint8V(rv2i(rv).(map[interface{}]uint8), e)
}
func (_ fastpathT) EncMapIntfUint8V(v map[interface{}]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfUint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfUint16V(rv2i(rv).(map[interface{}]uint16), e)
}
func (_ fastpathT) EncMapIntfUint16V(v map[interface{}]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfUint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfUint32V(rv2i(rv).(map[interface{}]uint32), e)
}
func (_ fastpathT) EncMapIntfUint32V(v map[interface{}]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfUint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfUint64V(rv2i(rv).(map[interface{}]uint64), e)
}
func (_ fastpathT) EncMapIntfUint64V(v map[interface{}]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfUintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfUintptrV(rv2i(rv).(map[interface{}]uintptr), e)
}
func (_ fastpathT) EncMapIntfUintptrV(v map[interface{}]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfIntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfIntV(rv2i(rv).(map[interface{}]int), e)
}
func (_ fastpathT) EncMapIntfIntV(v map[interface{}]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfInt8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfInt8V(rv2i(rv).(map[interface{}]int8), e)
}
func (_ fastpathT) EncMapIntfInt8V(v map[interface{}]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfInt16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfInt16V(rv2i(rv).(map[interface{}]int16), e)
}
func (_ fastpathT) EncMapIntfInt16V(v map[interface{}]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfInt32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfInt32V(rv2i(rv).(map[interface{}]int32), e)
}
func (_ fastpathT) EncMapIntfInt32V(v map[interface{}]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfInt64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfInt64V(rv2i(rv).(map[interface{}]int64), e)
}
func (_ fastpathT) EncMapIntfInt64V(v map[interface{}]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfFloat32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfFloat32V(rv2i(rv).(map[interface{}]float32), e)
}
func (_ fastpathT) EncMapIntfFloat32V(v map[interface{}]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfFloat64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfFloat64V(rv2i(rv).(map[interface{}]float64), e)
}
func (_ fastpathT) EncMapIntfFloat64V(v map[interface{}]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapIntfBoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapIntfBoolV(rv2i(rv).(map[interface{}]bool), e)
}
func (_ fastpathT) EncMapIntfBoolV(v map[interface{}]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI
		for k2, _ := range v {
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2
			i++
		}
		sort.Sort(bytesISlice(v2))
		for j := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.asis(v2[j].v)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[v2[j].i])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringIntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringIntfV(rv2i(rv).(map[string]interface{}), e)
}
func (_ fastpathT) EncMapStringIntfV(v map[string]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[string(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringStringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringStringV(rv2i(rv).(map[string]string), e)
}
func (_ fastpathT) EncMapStringStringV(v map[string]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v[string(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringUintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringUintV(rv2i(rv).(map[string]uint), e)
}
func (_ fastpathT) EncMapStringUintV(v map[string]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[string(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringUint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringUint8V(rv2i(rv).(map[string]uint8), e)
}
func (_ fastpathT) EncMapStringUint8V(v map[string]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[string(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringUint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringUint16V(rv2i(rv).(map[string]uint16), e)
}
func (_ fastpathT) EncMapStringUint16V(v map[string]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[string(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringUint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringUint32V(rv2i(rv).(map[string]uint32), e)
}
func (_ fastpathT) EncMapStringUint32V(v map[string]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[string(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringUint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringUint64V(rv2i(rv).(map[string]uint64), e)
}
func (_ fastpathT) EncMapStringUint64V(v map[string]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[string(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringUintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringUintptrV(rv2i(rv).(map[string]uintptr), e)
}
func (_ fastpathT) EncMapStringUintptrV(v map[string]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[string(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringIntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringIntV(rv2i(rv).(map[string]int), e)
}
func (_ fastpathT) EncMapStringIntV(v map[string]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[string(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringInt8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringInt8V(rv2i(rv).(map[string]int8), e)
}
func (_ fastpathT) EncMapStringInt8V(v map[string]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[string(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringInt16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringInt16V(rv2i(rv).(map[string]int16), e)
}
func (_ fastpathT) EncMapStringInt16V(v map[string]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[string(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringInt32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringInt32V(rv2i(rv).(map[string]int32), e)
}
func (_ fastpathT) EncMapStringInt32V(v map[string]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[string(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringInt64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringInt64V(rv2i(rv).(map[string]int64), e)
}
func (_ fastpathT) EncMapStringInt64V(v map[string]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[string(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringFloat32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringFloat32V(rv2i(rv).(map[string]float32), e)
}
func (_ fastpathT) EncMapStringFloat32V(v map[string]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v[string(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringFloat64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringFloat64V(rv2i(rv).(map[string]float64), e)
}
func (_ fastpathT) EncMapStringFloat64V(v map[string]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v[string(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapStringBoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapStringBoolV(rv2i(rv).(map[string]bool), e)
}
func (_ fastpathT) EncMapStringBoolV(v map[string]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	if e.h.Canonical {
		v2 := make([]string, len(v))
		var i int
		for k, _ := range v {
			v2[i] = string(k)
			i++
		}
		sort.Sort(stringSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v[string(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			if asSymbols {
				ee.EncodeSymbol(k2)
			} else {
				ee.EncodeString(c_UTF8, k2)
			}
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32IntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32IntfV(rv2i(rv).(map[float32]interface{}), e)
}
func (_ fastpathT) EncMapFloat32IntfV(v map[float32]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[float32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32StringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32StringV(rv2i(rv).(map[float32]string), e)
}
func (_ fastpathT) EncMapFloat32StringV(v map[float32]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v[float32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32UintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32UintV(rv2i(rv).(map[float32]uint), e)
}
func (_ fastpathT) EncMapFloat32UintV(v map[float32]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[float32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32Uint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32Uint8V(rv2i(rv).(map[float32]uint8), e)
}
func (_ fastpathT) EncMapFloat32Uint8V(v map[float32]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[float32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32Uint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32Uint16V(rv2i(rv).(map[float32]uint16), e)
}
func (_ fastpathT) EncMapFloat32Uint16V(v map[float32]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[float32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32Uint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32Uint32V(rv2i(rv).(map[float32]uint32), e)
}
func (_ fastpathT) EncMapFloat32Uint32V(v map[float32]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[float32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32Uint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32Uint64V(rv2i(rv).(map[float32]uint64), e)
}
func (_ fastpathT) EncMapFloat32Uint64V(v map[float32]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[float32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32UintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32UintptrV(rv2i(rv).(map[float32]uintptr), e)
}
func (_ fastpathT) EncMapFloat32UintptrV(v map[float32]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[float32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32IntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32IntV(rv2i(rv).(map[float32]int), e)
}
func (_ fastpathT) EncMapFloat32IntV(v map[float32]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[float32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32Int8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32Int8V(rv2i(rv).(map[float32]int8), e)
}
func (_ fastpathT) EncMapFloat32Int8V(v map[float32]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[float32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32Int16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32Int16V(rv2i(rv).(map[float32]int16), e)
}
func (_ fastpathT) EncMapFloat32Int16V(v map[float32]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[float32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32Int32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32Int32V(rv2i(rv).(map[float32]int32), e)
}
func (_ fastpathT) EncMapFloat32Int32V(v map[float32]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[float32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32Int64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32Int64V(rv2i(rv).(map[float32]int64), e)
}
func (_ fastpathT) EncMapFloat32Int64V(v map[float32]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[float32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32Float32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32Float32V(rv2i(rv).(map[float32]float32), e)
}
func (_ fastpathT) EncMapFloat32Float32V(v map[float32]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v[float32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32Float64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32Float64V(rv2i(rv).(map[float32]float64), e)
}
func (_ fastpathT) EncMapFloat32Float64V(v map[float32]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v[float32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat32BoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat32BoolV(rv2i(rv).(map[float32]bool), e)
}
func (_ fastpathT) EncMapFloat32BoolV(v map[float32]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(float32(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v[float32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat32(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64IntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64IntfV(rv2i(rv).(map[float64]interface{}), e)
}
func (_ fastpathT) EncMapFloat64IntfV(v map[float64]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[float64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64StringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64StringV(rv2i(rv).(map[float64]string), e)
}
func (_ fastpathT) EncMapFloat64StringV(v map[float64]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v[float64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64UintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64UintV(rv2i(rv).(map[float64]uint), e)
}
func (_ fastpathT) EncMapFloat64UintV(v map[float64]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[float64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64Uint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64Uint8V(rv2i(rv).(map[float64]uint8), e)
}
func (_ fastpathT) EncMapFloat64Uint8V(v map[float64]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[float64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64Uint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64Uint16V(rv2i(rv).(map[float64]uint16), e)
}
func (_ fastpathT) EncMapFloat64Uint16V(v map[float64]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[float64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64Uint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64Uint32V(rv2i(rv).(map[float64]uint32), e)
}
func (_ fastpathT) EncMapFloat64Uint32V(v map[float64]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[float64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64Uint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64Uint64V(rv2i(rv).(map[float64]uint64), e)
}
func (_ fastpathT) EncMapFloat64Uint64V(v map[float64]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[float64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64UintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64UintptrV(rv2i(rv).(map[float64]uintptr), e)
}
func (_ fastpathT) EncMapFloat64UintptrV(v map[float64]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[float64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64IntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64IntV(rv2i(rv).(map[float64]int), e)
}
func (_ fastpathT) EncMapFloat64IntV(v map[float64]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[float64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64Int8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64Int8V(rv2i(rv).(map[float64]int8), e)
}
func (_ fastpathT) EncMapFloat64Int8V(v map[float64]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[float64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64Int16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64Int16V(rv2i(rv).(map[float64]int16), e)
}
func (_ fastpathT) EncMapFloat64Int16V(v map[float64]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[float64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64Int32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64Int32V(rv2i(rv).(map[float64]int32), e)
}
func (_ fastpathT) EncMapFloat64Int32V(v map[float64]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[float64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64Int64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64Int64V(rv2i(rv).(map[float64]int64), e)
}
func (_ fastpathT) EncMapFloat64Int64V(v map[float64]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[float64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64Float32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64Float32V(rv2i(rv).(map[float64]float32), e)
}
func (_ fastpathT) EncMapFloat64Float32V(v map[float64]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v[float64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64Float64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64Float64V(rv2i(rv).(map[float64]float64), e)
}
func (_ fastpathT) EncMapFloat64Float64V(v map[float64]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v[float64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapFloat64BoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapFloat64BoolV(rv2i(rv).(map[float64]bool), e)
}
func (_ fastpathT) EncMapFloat64BoolV(v map[float64]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]float64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = float64(k)
			i++
		}
		sort.Sort(floatSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(float64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v[float64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeFloat64(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintIntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintIntfV(rv2i(rv).(map[uint]interface{}), e)
}
func (_ fastpathT) EncMapUintIntfV(v map[uint]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[uint(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintStringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintStringV(rv2i(rv).(map[uint]string), e)
}
func (_ fastpathT) EncMapUintStringV(v map[uint]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v[uint(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintUintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintUintV(rv2i(rv).(map[uint]uint), e)
}
func (_ fastpathT) EncMapUintUintV(v map[uint]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintUint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintUint8V(rv2i(rv).(map[uint]uint8), e)
}
func (_ fastpathT) EncMapUintUint8V(v map[uint]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintUint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintUint16V(rv2i(rv).(map[uint]uint16), e)
}
func (_ fastpathT) EncMapUintUint16V(v map[uint]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintUint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintUint32V(rv2i(rv).(map[uint]uint32), e)
}
func (_ fastpathT) EncMapUintUint32V(v map[uint]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintUint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintUint64V(rv2i(rv).(map[uint]uint64), e)
}
func (_ fastpathT) EncMapUintUint64V(v map[uint]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintUintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintUintptrV(rv2i(rv).(map[uint]uintptr), e)
}
func (_ fastpathT) EncMapUintUintptrV(v map[uint]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[uint(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintIntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintIntV(rv2i(rv).(map[uint]int), e)
}
func (_ fastpathT) EncMapUintIntV(v map[uint]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintInt8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintInt8V(rv2i(rv).(map[uint]int8), e)
}
func (_ fastpathT) EncMapUintInt8V(v map[uint]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintInt16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintInt16V(rv2i(rv).(map[uint]int16), e)
}
func (_ fastpathT) EncMapUintInt16V(v map[uint]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintInt32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintInt32V(rv2i(rv).(map[uint]int32), e)
}
func (_ fastpathT) EncMapUintInt32V(v map[uint]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintInt64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintInt64V(rv2i(rv).(map[uint]int64), e)
}
func (_ fastpathT) EncMapUintInt64V(v map[uint]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintFloat32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintFloat32V(rv2i(rv).(map[uint]float32), e)
}
func (_ fastpathT) EncMapUintFloat32V(v map[uint]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v[uint(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintFloat64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintFloat64V(rv2i(rv).(map[uint]float64), e)
}
func (_ fastpathT) EncMapUintFloat64V(v map[uint]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v[uint(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintBoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintBoolV(rv2i(rv).(map[uint]bool), e)
}
func (_ fastpathT) EncMapUintBoolV(v map[uint]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v[uint(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8IntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8IntfV(rv2i(rv).(map[uint8]interface{}), e)
}
func (_ fastpathT) EncMapUint8IntfV(v map[uint8]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[uint8(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8StringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8StringV(rv2i(rv).(map[uint8]string), e)
}
func (_ fastpathT) EncMapUint8StringV(v map[uint8]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v[uint8(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8UintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8UintV(rv2i(rv).(map[uint8]uint), e)
}
func (_ fastpathT) EncMapUint8UintV(v map[uint8]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8Uint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8Uint8V(rv2i(rv).(map[uint8]uint8), e)
}
func (_ fastpathT) EncMapUint8Uint8V(v map[uint8]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8Uint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8Uint16V(rv2i(rv).(map[uint8]uint16), e)
}
func (_ fastpathT) EncMapUint8Uint16V(v map[uint8]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8Uint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8Uint32V(rv2i(rv).(map[uint8]uint32), e)
}
func (_ fastpathT) EncMapUint8Uint32V(v map[uint8]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8Uint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8Uint64V(rv2i(rv).(map[uint8]uint64), e)
}
func (_ fastpathT) EncMapUint8Uint64V(v map[uint8]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8UintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8UintptrV(rv2i(rv).(map[uint8]uintptr), e)
}
func (_ fastpathT) EncMapUint8UintptrV(v map[uint8]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[uint8(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8IntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8IntV(rv2i(rv).(map[uint8]int), e)
}
func (_ fastpathT) EncMapUint8IntV(v map[uint8]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8Int8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8Int8V(rv2i(rv).(map[uint8]int8), e)
}
func (_ fastpathT) EncMapUint8Int8V(v map[uint8]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8Int16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8Int16V(rv2i(rv).(map[uint8]int16), e)
}
func (_ fastpathT) EncMapUint8Int16V(v map[uint8]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8Int32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8Int32V(rv2i(rv).(map[uint8]int32), e)
}
func (_ fastpathT) EncMapUint8Int32V(v map[uint8]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8Int64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8Int64V(rv2i(rv).(map[uint8]int64), e)
}
func (_ fastpathT) EncMapUint8Int64V(v map[uint8]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint8(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8Float32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8Float32V(rv2i(rv).(map[uint8]float32), e)
}
func (_ fastpathT) EncMapUint8Float32V(v map[uint8]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v[uint8(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8Float64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8Float64V(rv2i(rv).(map[uint8]float64), e)
}
func (_ fastpathT) EncMapUint8Float64V(v map[uint8]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v[uint8(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint8BoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint8BoolV(rv2i(rv).(map[uint8]bool), e)
}
func (_ fastpathT) EncMapUint8BoolV(v map[uint8]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint8(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v[uint8(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16IntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16IntfV(rv2i(rv).(map[uint16]interface{}), e)
}
func (_ fastpathT) EncMapUint16IntfV(v map[uint16]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[uint16(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16StringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16StringV(rv2i(rv).(map[uint16]string), e)
}
func (_ fastpathT) EncMapUint16StringV(v map[uint16]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v[uint16(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16UintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16UintV(rv2i(rv).(map[uint16]uint), e)
}
func (_ fastpathT) EncMapUint16UintV(v map[uint16]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16Uint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16Uint8V(rv2i(rv).(map[uint16]uint8), e)
}
func (_ fastpathT) EncMapUint16Uint8V(v map[uint16]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16Uint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16Uint16V(rv2i(rv).(map[uint16]uint16), e)
}
func (_ fastpathT) EncMapUint16Uint16V(v map[uint16]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16Uint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16Uint32V(rv2i(rv).(map[uint16]uint32), e)
}
func (_ fastpathT) EncMapUint16Uint32V(v map[uint16]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16Uint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16Uint64V(rv2i(rv).(map[uint16]uint64), e)
}
func (_ fastpathT) EncMapUint16Uint64V(v map[uint16]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16UintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16UintptrV(rv2i(rv).(map[uint16]uintptr), e)
}
func (_ fastpathT) EncMapUint16UintptrV(v map[uint16]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[uint16(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16IntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16IntV(rv2i(rv).(map[uint16]int), e)
}
func (_ fastpathT) EncMapUint16IntV(v map[uint16]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16Int8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16Int8V(rv2i(rv).(map[uint16]int8), e)
}
func (_ fastpathT) EncMapUint16Int8V(v map[uint16]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16Int16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16Int16V(rv2i(rv).(map[uint16]int16), e)
}
func (_ fastpathT) EncMapUint16Int16V(v map[uint16]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16Int32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16Int32V(rv2i(rv).(map[uint16]int32), e)
}
func (_ fastpathT) EncMapUint16Int32V(v map[uint16]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16Int64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16Int64V(rv2i(rv).(map[uint16]int64), e)
}
func (_ fastpathT) EncMapUint16Int64V(v map[uint16]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint16(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16Float32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16Float32V(rv2i(rv).(map[uint16]float32), e)
}
func (_ fastpathT) EncMapUint16Float32V(v map[uint16]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v[uint16(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16Float64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16Float64V(rv2i(rv).(map[uint16]float64), e)
}
func (_ fastpathT) EncMapUint16Float64V(v map[uint16]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v[uint16(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint16BoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint16BoolV(rv2i(rv).(map[uint16]bool), e)
}
func (_ fastpathT) EncMapUint16BoolV(v map[uint16]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint16(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v[uint16(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32IntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32IntfV(rv2i(rv).(map[uint32]interface{}), e)
}
func (_ fastpathT) EncMapUint32IntfV(v map[uint32]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[uint32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32StringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32StringV(rv2i(rv).(map[uint32]string), e)
}
func (_ fastpathT) EncMapUint32StringV(v map[uint32]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v[uint32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32UintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32UintV(rv2i(rv).(map[uint32]uint), e)
}
func (_ fastpathT) EncMapUint32UintV(v map[uint32]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32Uint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32Uint8V(rv2i(rv).(map[uint32]uint8), e)
}
func (_ fastpathT) EncMapUint32Uint8V(v map[uint32]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32Uint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32Uint16V(rv2i(rv).(map[uint32]uint16), e)
}
func (_ fastpathT) EncMapUint32Uint16V(v map[uint32]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32Uint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32Uint32V(rv2i(rv).(map[uint32]uint32), e)
}
func (_ fastpathT) EncMapUint32Uint32V(v map[uint32]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32Uint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32Uint64V(rv2i(rv).(map[uint32]uint64), e)
}
func (_ fastpathT) EncMapUint32Uint64V(v map[uint32]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32UintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32UintptrV(rv2i(rv).(map[uint32]uintptr), e)
}
func (_ fastpathT) EncMapUint32UintptrV(v map[uint32]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[uint32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32IntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32IntV(rv2i(rv).(map[uint32]int), e)
}
func (_ fastpathT) EncMapUint32IntV(v map[uint32]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32Int8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32Int8V(rv2i(rv).(map[uint32]int8), e)
}
func (_ fastpathT) EncMapUint32Int8V(v map[uint32]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32Int16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32Int16V(rv2i(rv).(map[uint32]int16), e)
}
func (_ fastpathT) EncMapUint32Int16V(v map[uint32]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32Int32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32Int32V(rv2i(rv).(map[uint32]int32), e)
}
func (_ fastpathT) EncMapUint32Int32V(v map[uint32]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32Int64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32Int64V(rv2i(rv).(map[uint32]int64), e)
}
func (_ fastpathT) EncMapUint32Int64V(v map[uint32]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint32(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32Float32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32Float32V(rv2i(rv).(map[uint32]float32), e)
}
func (_ fastpathT) EncMapUint32Float32V(v map[uint32]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v[uint32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32Float64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32Float64V(rv2i(rv).(map[uint32]float64), e)
}
func (_ fastpathT) EncMapUint32Float64V(v map[uint32]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v[uint32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint32BoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint32BoolV(rv2i(rv).(map[uint32]bool), e)
}
func (_ fastpathT) EncMapUint32BoolV(v map[uint32]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint32(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v[uint32(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64IntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64IntfV(rv2i(rv).(map[uint64]interface{}), e)
}
func (_ fastpathT) EncMapUint64IntfV(v map[uint64]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[uint64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64StringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64StringV(rv2i(rv).(map[uint64]string), e)
}
func (_ fastpathT) EncMapUint64StringV(v map[uint64]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v[uint64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64UintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64UintV(rv2i(rv).(map[uint64]uint), e)
}
func (_ fastpathT) EncMapUint64UintV(v map[uint64]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64Uint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64Uint8V(rv2i(rv).(map[uint64]uint8), e)
}
func (_ fastpathT) EncMapUint64Uint8V(v map[uint64]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64Uint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64Uint16V(rv2i(rv).(map[uint64]uint16), e)
}
func (_ fastpathT) EncMapUint64Uint16V(v map[uint64]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64Uint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64Uint32V(rv2i(rv).(map[uint64]uint32), e)
}
func (_ fastpathT) EncMapUint64Uint32V(v map[uint64]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64Uint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64Uint64V(rv2i(rv).(map[uint64]uint64), e)
}
func (_ fastpathT) EncMapUint64Uint64V(v map[uint64]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uint64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64UintptrR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64UintptrV(rv2i(rv).(map[uint64]uintptr), e)
}
func (_ fastpathT) EncMapUint64UintptrV(v map[uint64]uintptr, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[uint64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64IntR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64IntV(rv2i(rv).(map[uint64]int), e)
}
func (_ fastpathT) EncMapUint64IntV(v map[uint64]int, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64Int8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64Int8V(rv2i(rv).(map[uint64]int8), e)
}
func (_ fastpathT) EncMapUint64Int8V(v map[uint64]int8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64Int16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64Int16V(rv2i(rv).(map[uint64]int16), e)
}
func (_ fastpathT) EncMapUint64Int16V(v map[uint64]int16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64Int32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64Int32V(rv2i(rv).(map[uint64]int32), e)
}
func (_ fastpathT) EncMapUint64Int32V(v map[uint64]int32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64Int64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64Int64V(rv2i(rv).(map[uint64]int64), e)
}
func (_ fastpathT) EncMapUint64Int64V(v map[uint64]int64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v[uint64(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeInt(int64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64Float32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64Float32V(rv2i(rv).(map[uint64]float32), e)
}
func (_ fastpathT) EncMapUint64Float32V(v map[uint64]float32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v[uint64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat32(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64Float64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64Float64V(rv2i(rv).(map[uint64]float64), e)
}
func (_ fastpathT) EncMapUint64Float64V(v map[uint64]float64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v[uint64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeFloat64(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUint64BoolR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUint64BoolV(rv2i(rv).(map[uint64]bool), e)
}
func (_ fastpathT) EncMapUint64BoolV(v map[uint64]bool, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(uint64(k2)))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v[uint64(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			ee.EncodeUint(uint64(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeBool(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrIntfR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrIntfV(rv2i(rv).(map[uintptr]interface{}), e)
}
func (_ fastpathT) EncMapUintptrIntfV(v map[uintptr]interface{}, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v[uintptr(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			e.encode(v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrStringR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrStringV(rv2i(rv).(map[uintptr]string), e)
}
func (_ fastpathT) EncMapUintptrStringV(v map[uintptr]string, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v[uintptr(k2)])
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeString(c_UTF8, v2)
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrUintR(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrUintV(rv2i(rv).(map[uintptr]uint), e)
}
func (_ fastpathT) EncMapUintptrUintV(v map[uintptr]uint, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uintptr(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrUint8R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrUint8V(rv2i(rv).(map[uintptr]uint8), e)
}
func (_ fastpathT) EncMapUintptrUint8V(v map[uintptr]uint8, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uintptr(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrUint16R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrUint16V(rv2i(rv).(map[uintptr]uint16), e)
}
func (_ fastpathT) EncMapUintptrUint16V(v map[uintptr]uint16, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uintptr(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrUint32R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrUint32V(rv2i(rv).(map[uintptr]uint32), e)
}
func (_ fastpathT) EncMapUintptrUint32V(v map[uintptr]uint32, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uintptr(k2)]))
		}
	} else {
		for k2, v2 := range v {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(k2)
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v2))
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
}

func (e *Encoder) fastpathEncMapUintptrUint64R(f *codecFnInfo, rv reflect.Value) {
	fastpathTV.EncMapUintptrUint64V(rv2i(rv).(map[uintptr]uint64), e)
}
func (_ fastpathT) EncMapUintptrUint64V(v map[uintptr]uint64, e *Encoder) {
	ee, cr := e.e, e.cr
	ee.EncodeMapStart(len(v))
	if e.h.Canonical {
		v2 := make([]uint64, len(v))
		var i int
		for k, _ := range v {
			v2[i] = uint64(k)
			i++
		}
		sort.Sort(uintSlice(v2))
		for _, k2 := range v2 {
			if cr != nil {
				cr.sendContainerState(containerMapKey)
			}
			e.encode(uintptr(k2))
			if cr != nil {
				cr.sendContainerState(containerMapValue)
			}
			ee.EncodeUint(uint64(v[uin€€