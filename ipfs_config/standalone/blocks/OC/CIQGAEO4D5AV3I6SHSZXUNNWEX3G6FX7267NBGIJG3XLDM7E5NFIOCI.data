
ÓØÉØ
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64UintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]uint)
		if v, changed := fastpathTV.DecMapInt64UintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64UintV(rv2i(rv).(map[int64]uint), false, d)
}
func (f fastpathT) DecMapInt64UintX(vp *map[int64]uint, d *Decoder) {
	if v, changed := f.DecMapInt64UintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64UintV(v map[int64]uint, canChange bool,
	d *Decoder) (_ map[int64]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[int64]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int64
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64Uint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]uint8)
		if v, changed := fastpathTV.DecMapInt64Uint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64Uint8V(rv2i(rv).(map[int64]uint8), false, d)
}
func (f fastpathT) DecMapInt64Uint8X(vp *map[int64]uint8, d *Decoder) {
	if v, changed := f.DecMapInt64Uint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64Uint8V(v map[int64]uint8, canChange bool,
	d *Decoder) (_ map[int64]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[int64]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int64
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64Uint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]uint16)
		if v, changed := fastpathTV.DecMapInt64Uint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64Uint16V(rv2i(rv).(map[int64]uint16), false, d)
}
func (f fastpathT) DecMapInt64Uint16X(vp *map[int64]uint16, d *Decoder) {
	if v, changed := f.DecMapInt64Uint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64Uint16V(v map[int64]uint16, canChange bool,
	d *Decoder) (_ map[int64]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[int64]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int64
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64Uint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]uint32)
		if v, changed := fastpathTV.DecMapInt64Uint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64Uint32V(rv2i(rv).(map[int64]uint32), false, d)
}
func (f fastpathT) DecMapInt64Uint32X(vp *map[int64]uint32, d *Decoder) {
	if v, changed := f.DecMapInt64Uint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64Uint32V(v map[int64]uint32, canChange bool,
	d *Decoder) (_ map[int64]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[int64]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int64
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64Uint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]uint64)
		if v, changed := fastpathTV.DecMapInt64Uint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64Uint64V(rv2i(rv).(map[int64]uint64), false, d)
}
func (f fastpathT) DecMapInt64Uint64X(vp *map[int64]uint64, d *Decoder) {
	if v, changed := f.DecMapInt64Uint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64Uint64V(v map[int64]uint64, canChange bool,
	d *Decoder) (_ map[int64]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[int64]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int64
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64UintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]uintptr)
		if v, changed := fastpathTV.DecMapInt64UintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64UintptrV(rv2i(rv).(map[int64]uintptr), false, d)
}
func (f fastpathT) DecMapInt64UintptrX(vp *map[int64]uintptr, d *Decoder) {
	if v, changed := f.DecMapInt64UintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64UintptrV(v map[int64]uintptr, canChange bool,
	d *Decoder) (_ map[int64]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[int64]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int64
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64IntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]int)
		if v, changed := fastpathTV.DecMapInt64IntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64IntV(rv2i(rv).(map[int64]int), false, d)
}
func (f fastpathT) DecMapInt64IntX(vp *map[int64]int, d *Decoder) {
	if v, changed := f.DecMapInt64IntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64IntV(v map[int64]int, canChange bool,
	d *Decoder) (_ map[int64]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[int64]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int64
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64Int8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]int8)
		if v, changed := fastpathTV.DecMapInt64Int8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64Int8V(rv2i(rv).(map[int64]int8), false, d)
}
func (f fastpathT) DecMapInt64Int8X(vp *map[int64]int8, d *Decoder) {
	if v, changed := f.DecMapInt64Int8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64Int8V(v map[int64]int8, canChange bool,
	d *Decoder) (_ map[int64]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[int64]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int64
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64Int16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]int16)
		if v, changed := fastpathTV.DecMapInt64Int16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64Int16V(rv2i(rv).(map[int64]int16), false, d)
}
func (f fastpathT) DecMapInt64Int16X(vp *map[int64]int16, d *Decoder) {
	if v, changed := f.DecMapInt64Int16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64Int16V(v map[int64]int16, canChange bool,
	d *Decoder) (_ map[int64]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 10)
		v = make(map[int64]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int64
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64Int32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]int32)
		if v, changed := fastpathTV.DecMapInt64Int32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64Int32V(rv2i(rv).(map[int64]int32), false, d)
}
func (f fastpathT) DecMapInt64Int32X(vp *map[int64]int32, d *Decoder) {
	if v, changed := f.DecMapInt64Int32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64Int32V(v map[int64]int32, canChange bool,
	d *Decoder) (_ map[int64]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[int64]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int64
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64Int64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]int64)
		if v, changed := fastpathTV.DecMapInt64Int64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64Int64V(rv2i(rv).(map[int64]int64), false, d)
}
func (f fastpathT) DecMapInt64Int64X(vp *map[int64]int64, d *Decoder) {
	if v, changed := f.DecMapInt64Int64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64Int64V(v map[int64]int64, canChange bool,
	d *Decoder) (_ map[int64]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[int64]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int64
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64Float32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]float32)
		if v, changed := fastpathTV.DecMapInt64Float32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64Float32V(rv2i(rv).(map[int64]float32), false, d)
}
func (f fastpathT) DecMapInt64Float32X(vp *map[int64]float32, d *Decoder) {
	if v, changed := f.DecMapInt64Float32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64Float32V(v map[int64]float32, canChange bool,
	d *Decoder) (_ map[int64]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 12)
		v = make(map[int64]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int64
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64Float64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]float64)
		if v, changed := fastpathTV.DecMapInt64Float64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64Float64V(rv2i(rv).(map[int64]float64), false, d)
}
func (f fastpathT) DecMapInt64Float64X(vp *map[int64]float64, d *Decoder) {
	if v, changed := f.DecMapInt64Float64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64Float64V(v map[int64]float64, canChange bool,
	d *Decoder) (_ map[int64]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 16)
		v = make(map[int64]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int64
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapInt64BoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[int64]bool)
		if v, changed := fastpathTV.DecMapInt64BoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapInt64BoolV(rv2i(rv).(map[int64]bool), false, d)
}
func (f fastpathT) DecMapInt64BoolX(vp *map[int64]bool, d *Decoder) {
	if v, changed := f.DecMapInt64BoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapInt64BoolV(v map[int64]bool, canChange bool,
	d *Decoder) (_ map[int64]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[int64]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk int64
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeInt(64)
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolIntfR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]interface{})
		if v, changed := fastpathTV.DecMapBoolIntfV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolIntfV(rv2i(rv).(map[bool]interface{}), false, d)
}
func (f fastpathT) DecMapBoolIntfX(vp *map[bool]interface{}, d *Decoder) {
	if v, changed := f.DecMapBoolIntfV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolIntfV(v map[bool]interface{}, canChange bool,
	d *Decoder) (_ map[bool]interface{}, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 17)
		v = make(map[bool]interface{}, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}
	mapGet := !d.h.MapValueReset && !d.h.InterfaceReset
	var mk bool
	var mv interface{}
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = nil
			}
			continue
		}
		if mapGet {
			mv = v[mk]
		} else {
			mv = nil
		}
		d.decode(&mv)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolStringR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]string)
		if v, changed := fastpathTV.DecMapBoolStringV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolStringV(rv2i(rv).(map[bool]string), false, d)
}
func (f fastpathT) DecMapBoolStringX(vp *map[bool]string, d *Decoder) {
	if v, changed := f.DecMapBoolStringV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolStringV(v map[bool]string, canChange bool,
	d *Decoder) (_ map[bool]string, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 17)
		v = make(map[bool]string, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk bool
	var mv string
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = ""
			}
			continue
		}
		mv = dd.DecodeString()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolUintR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]uint)
		if v, changed := fastpathTV.DecMapBoolUintV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolUintV(rv2i(rv).(map[bool]uint), false, d)
}
func (f fastpathT) DecMapBoolUintX(vp *map[bool]uint, d *Decoder) {
	if v, changed := f.DecMapBoolUintV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolUintV(v map[bool]uint, canChange bool,
	d *Decoder) (_ map[bool]uint, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[bool]uint, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk bool
	var mv uint
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolUint8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]uint8)
		if v, changed := fastpathTV.DecMapBoolUint8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolUint8V(rv2i(rv).(map[bool]uint8), false, d)
}
func (f fastpathT) DecMapBoolUint8X(vp *map[bool]uint8, d *Decoder) {
	if v, changed := f.DecMapBoolUint8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolUint8V(v map[bool]uint8, canChange bool,
	d *Decoder) (_ map[bool]uint8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 2)
		v = make(map[bool]uint8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk bool
	var mv uint8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint8(dd.DecodeUint(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolUint16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]uint16)
		if v, changed := fastpathTV.DecMapBoolUint16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolUint16V(rv2i(rv).(map[bool]uint16), false, d)
}
func (f fastpathT) DecMapBoolUint16X(vp *map[bool]uint16, d *Decoder) {
	if v, changed := f.DecMapBoolUint16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolUint16V(v map[bool]uint16, canChange bool,
	d *Decoder) (_ map[bool]uint16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 3)
		v = make(map[bool]uint16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk bool
	var mv uint16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint16(dd.DecodeUint(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolUint32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]uint32)
		if v, changed := fastpathTV.DecMapBoolUint32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolUint32V(rv2i(rv).(map[bool]uint32), false, d)
}
func (f fastpathT) DecMapBoolUint32X(vp *map[bool]uint32, d *Decoder) {
	if v, changed := f.DecMapBoolUint32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolUint32V(v map[bool]uint32, canChange bool,
	d *Decoder) (_ map[bool]uint32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[bool]uint32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk bool
	var mv uint32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uint32(dd.DecodeUint(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolUint64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]uint64)
		if v, changed := fastpathTV.DecMapBoolUint64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolUint64V(rv2i(rv).(map[bool]uint64), false, d)
}
func (f fastpathT) DecMapBoolUint64X(vp *map[bool]uint64, d *Decoder) {
	if v, changed := f.DecMapBoolUint64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolUint64V(v map[bool]uint64, canChange bool,
	d *Decoder) (_ map[bool]uint64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[bool]uint64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk bool
	var mv uint64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeUint(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolUintptrR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]uintptr)
		if v, changed := fastpathTV.DecMapBoolUintptrV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolUintptrV(rv2i(rv).(map[bool]uintptr), false, d)
}
func (f fastpathT) DecMapBoolUintptrX(vp *map[bool]uintptr, d *Decoder) {
	if v, changed := f.DecMapBoolUintptrV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolUintptrV(v map[bool]uintptr, canChange bool,
	d *Decoder) (_ map[bool]uintptr, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[bool]uintptr, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk bool
	var mv uintptr
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = uintptr(dd.DecodeUint(uintBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolIntR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]int)
		if v, changed := fastpathTV.DecMapBoolIntV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolIntV(rv2i(rv).(map[bool]int), false, d)
}
func (f fastpathT) DecMapBoolIntX(vp *map[bool]int, d *Decoder) {
	if v, changed := f.DecMapBoolIntV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolIntV(v map[bool]int, canChange bool,
	d *Decoder) (_ map[bool]int, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[bool]int, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk bool
	var mv int
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int(dd.DecodeInt(intBitsize))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolInt8R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]int8)
		if v, changed := fastpathTV.DecMapBoolInt8V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolInt8V(rv2i(rv).(map[bool]int8), false, d)
}
func (f fastpathT) DecMapBoolInt8X(vp *map[bool]int8, d *Decoder) {
	if v, changed := f.DecMapBoolInt8V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolInt8V(v map[bool]int8, canChange bool,
	d *Decoder) (_ map[bool]int8, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 2)
		v = make(map[bool]int8, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk bool
	var mv int8
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int8(dd.DecodeInt(8))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolInt16R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]int16)
		if v, changed := fastpathTV.DecMapBoolInt16V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolInt16V(rv2i(rv).(map[bool]int16), false, d)
}
func (f fastpathT) DecMapBoolInt16X(vp *map[bool]int16, d *Decoder) {
	if v, changed := f.DecMapBoolInt16V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolInt16V(v map[bool]int16, canChange bool,
	d *Decoder) (_ map[bool]int16, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 3)
		v = make(map[bool]int16, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk bool
	var mv int16
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int16(dd.DecodeInt(16))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolInt32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]int32)
		if v, changed := fastpathTV.DecMapBoolInt32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolInt32V(rv2i(rv).(map[bool]int32), false, d)
}
func (f fastpathT) DecMapBoolInt32X(vp *map[bool]int32, d *Decoder) {
	if v, changed := f.DecMapBoolInt32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolInt32V(v map[bool]int32, canChange bool,
	d *Decoder) (_ map[bool]int32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[bool]int32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk bool
	var mv int32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = int32(dd.DecodeInt(32))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolInt64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]int64)
		if v, changed := fastpathTV.DecMapBoolInt64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolInt64V(rv2i(rv).(map[bool]int64), false, d)
}
func (f fastpathT) DecMapBoolInt64X(vp *map[bool]int64, d *Decoder) {
	if v, changed := f.DecMapBoolInt64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolInt64V(v map[bool]int64, canChange bool,
	d *Decoder) (_ map[bool]int64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[bool]int64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk bool
	var mv int64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeInt(64)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolFloat32R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]float32)
		if v, changed := fastpathTV.DecMapBoolFloat32V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolFloat32V(rv2i(rv).(map[bool]float32), false, d)
}
func (f fastpathT) DecMapBoolFloat32X(vp *map[bool]float32, d *Decoder) {
	if v, changed := f.DecMapBoolFloat32V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolFloat32V(v map[bool]float32, canChange bool,
	d *Decoder) (_ map[bool]float32, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 5)
		v = make(map[bool]float32, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk bool
	var mv float32
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = float32(dd.DecodeFloat(true))
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolFloat64R(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]float64)
		if v, changed := fastpathTV.DecMapBoolFloat64V(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolFloat64V(rv2i(rv).(map[bool]float64), false, d)
}
func (f fastpathT) DecMapBoolFloat64X(vp *map[bool]float64, d *Decoder) {
	if v, changed := f.DecMapBoolFloat64V(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolFloat64V(v map[bool]float64, canChange bool,
	d *Decoder) (_ map[bool]float64, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 9)
		v = make(map[bool]float64, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk bool
	var mv float64
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = 0
			}
			continue
		}
		mv = dd.DecodeFloat(false)
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}

func (d *Decoder) fastpathDecMapBoolBoolR(f *codecFnInfo, rv reflect.Value) {
	if rv.Kind() == reflect.Ptr {
		vp := rv2i(rv).(*map[bool]bool)
		if v, changed := fastpathTV.DecMapBoolBoolV(*vp, true, d); changed {
			*vp = v
		}
		return
	}
	fastpathTV.DecMapBoolBoolV(rv2i(rv).(map[bool]bool), false, d)
}
func (f fastpathT) DecMapBoolBoolX(vp *map[bool]bool, d *Decoder) {
	if v, changed := f.DecMapBoolBoolV(*vp, true, d); changed {
		*vp = v
	}
}
func (_ fastpathT) DecMapBoolBoolV(v map[bool]bool, canChange bool,
	d *Decoder) (_ map[bool]bool, changed bool) {
	dd, cr := d.d, d.cr

	containerLen := dd.ReadMapStart()
	if canChange && v == nil {
		xlen := decInferLen(containerLen, d.h.MaxInitLen, 2)
		v = make(map[bool]bool, xlen)
		changed = true
	}
	if containerLen == 0 {
		if cr != nil {
			cr.sendContainerState(containerMapEnd)
		}
		return v, changed
	}

	var mk bool
	var mv bool
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ {
		if cr != nil {
			cr.sendContainerState(containerMapKey)
		}
		mk = dd.DecodeBool()
		if cr != nil {
			cr.sendContainerState(containerMapValue)
		}
		if dd.TryDecodeAsNil() {
			if d.h.DeleteOnNilMapValue {
				delete(v, mk)
			} else {
				v[mk] = false
			}
			continue
		}
		mv = dd.DecodeBool()
		if v != nil {
			v[mk] = mv
		}
	}
	if cr != nil {
		cr.sendContainerState(containerMapEnd)
	}
	return v, changed
}
ÉØ